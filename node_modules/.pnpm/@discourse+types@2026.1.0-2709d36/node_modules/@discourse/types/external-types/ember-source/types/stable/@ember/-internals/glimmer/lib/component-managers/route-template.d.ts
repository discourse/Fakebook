declare module '@ember/-internals/glimmer/lib/component-managers/route-template' {
    import type { InternalOwner } from "@ember/-internals/owner";
    import type { CapturedArguments, CompilableProgram, ComponentDefinition, CustomRenderNode, Destroyable, InternalComponentCapabilities, Template, VMArguments, WithCreateInstance, WithCustomDebugRenderTree } from "@glimmer/interfaces";
    import type { Nullable } from "@ember/-internals/utility-types";
    import type { Reference } from "@glimmer/reference";
    import { type CurriedValue } from "@glimmer/runtime";
    interface RouteTemplateInstanceState {
        self: Reference;
        controller: unknown;
    }
    export interface RouteTemplateDefinitionState {
        name: string;
        templateName: string;
    }
    class RouteTemplateManager implements WithCreateInstance<RouteTemplateInstanceState, RouteTemplateDefinitionState>, WithCustomDebugRenderTree<RouteTemplateInstanceState, RouteTemplateDefinitionState> {
        create(_owner: InternalOwner, _definition: RouteTemplateDefinitionState, args: VMArguments): RouteTemplateInstanceState;
        getSelf({ self }: RouteTemplateInstanceState): Reference;
        getDebugName({ name }: RouteTemplateDefinitionState): string;
        getDebugCustomRenderTree({ name, templateName }: RouteTemplateDefinitionState, state: RouteTemplateInstanceState, args: CapturedArguments): CustomRenderNode[];
        getCapabilities(): InternalComponentCapabilities;
        didRenderLayout(): void;
        didUpdateLayout(): void;
        didCreate(): void;
        didUpdate(): void;
        getDestroyable(): Nullable<Destroyable>;
    }
    /**
     * This "upgrades" a route template into a invocable component. Conceptually
     * it can be 1:1 for each unique `Template`, but it's also cheap to construct,
     * so unless the stability is desirable for other reasons, it's probably not
     * worth caching this.
     */
    export class RouteTemplate implements ComponentDefinition<RouteTemplateDefinitionState, RouteTemplateInstanceState, RouteTemplateManager> {
        handle: number;
        resolvedName: string;
        state: RouteTemplateDefinitionState;
        manager: RouteTemplateManager;
        capabilities: import("@glimmer/interfaces").CapabilityMask;
        compilable: CompilableProgram;
        constructor(name: string, template: Template);
    }
    export function makeRouteTemplate(owner: InternalOwner, name: string, template: Template): CurriedValue;
    export {};
}