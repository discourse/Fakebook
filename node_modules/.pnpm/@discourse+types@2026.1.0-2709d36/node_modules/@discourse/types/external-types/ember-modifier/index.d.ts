declare module 'ember-modifier/-private/signature' {
	/** @private */
	export type ElementFor<S> = 'Element' extends keyof S ? S['Element'] extends Element ? S['Element'] : Element : Element;
	type DefaultPositional = [];
	type GetOrElse<T, K, Fallback> = K extends keyof T ? T[K] : Fallback;
	/**
	 * A convenience type utility, primarily for working with args in the `modify`
	 * hook on class-based modifiers. Given a signature `S` it will return the
	 * correct positional args for that signature. For example:
	 *
	 * ```ts
	 * import Modifier, { NamedArgs } from 'ember-modifier';
	 *
	 * interface OnClickOutsideSig {
	 *   Args: {
	 *     Positional: [handler: () => void];
	 *   };
	 * }
	 *
	 * export default class Example extends Modifier<OnClickOutsideSig> {
	 *   element = null;
	 *
	 *   modify(el: Element, _: [handler]: PositionalArgs<OnClickOutsideSig>) {
	 *     if (!this.element) {
	 *       this.element = el;
	 *     }
	 *
	 *     this.clearHandler();
	 *     this.handler = handler;
	 *
	 *     document.addEventListener('click', this.onClickOutside);
	 *
	 *     // Normally this would be better done in `constructor` or similar.
	 *     unregisterDestructor(this, this.clearHandler);
	 *     registerDestructor(this, this.clearHandler);
	 *   }
	 *
	 *   onClickOutside = (event: MouseEvent) => {
	 *     // SAFETY: a "standard" safe cast for event.target here
	 *     if (!this.element.contains(event.target as Node)) {
	 *       this.handler();
	 *     }
	 *   }
	 *
	 *   clearHandler = () => {
	 *     document.removeEventListener('click', this.onClickOutside);
	 *   }
	 * }
	 * ```
	 *
	 * (This example does not need to be, and should not be, class-based, but is
	 * useful to illustrate how to use the type utility.)
	 */
	export type PositionalArgs<S> = 'Args' extends keyof S ? GetOrElse<S['Args'], 'Positional', DefaultPositional> : DefaultPositional; const Empty: unique symbol;
	export interface EmptyObject {
	    [Empty]?: true;
	}
	type DefaultNamed = EmptyObject;
	/**
	 * A convenience type utility, primarily for working with args in the `modify`
	 * hook on class-based modifiers. Given a signature `S` it will return the
	 * correct named args for that signature:
	 *
	 * ```ts
	 * import Modifier, { NamedArgs } from 'ember-modifier';
	 *
	 * interface PlaySig {
	 *   Element: HTMLElement;
	 *   Args: {
	 *     Named: {
	 *       when: string;
	 *     };
	 *   };
	 * }
	 *
	 * export default class Example extends Modifier<Sig> {
	 *   modify(el: HTMLMediaElement, _: [], { when: shouldPlay }: NamedArgs<PlaySig>) {
	 *     if (shouldPlay) {
	 *       el.play();
	 *     } else {
	 *       el.pause();
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * (This example does not need to be, and should not be, class-based, but is
	 * useful to illustrate the point.)
	 */
	export type NamedArgs<S> = 'Args' extends keyof S ? GetOrElse<S['Args'], 'Named', DefaultNamed> : DefaultNamed;
	/** @private */
	export interface DefaultSignature {
	    Element: Element;
	}
	/**
	 * A convenience type utility, primarily for working with args in the `modify`
	 * hook on class-based modifiers. Given a signature `S` it will return the
	 * correct positional args for that signature, to be used with
	 */
	export interface ArgsFor<S> {
	    named: NamedArgs<S>;
	    positional: PositionalArgs<S>;
	}
	export {};
	//# sourceMappingURL=signature.d.ts.map
}
declare module 'ember-modifier/-private/opaque' {
	 const Brand: unique symbol; class _Opaque<T> {
	    private readonly [Brand];
	}
	interface Opaque<T> extends _Opaque<T> {
	}
	export default Opaque;
	//# sourceMappingURL=opaque.d.ts.map
}
declare module 'ember-modifier/-private/class-based/modifier' {
	import type Owner from '@ember/owner';
	import type { ElementFor, ArgsFor, DefaultSignature, PositionalArgs, NamedArgs } from 'ember-modifier/-private/signature';
	import type Opaque from 'ember-modifier/-private/opaque';
	export default interface ClassBasedModifier<S = DefaultSignature> extends Opaque<S> {
	}
	/**
	 * A base class for modifiers which need more capabilities than function-based
	 * modifiers. Useful if, for example:
	 *
	 * 1. You need to inject services and access them
	 * 2. You need fine-grained control of updates, either for performance or
	 *    convenience reasons, and don't want to teardown the state of your modifier
	 *    every time only to set it up again.
	 * 3. You need to store some local state within your modifier.
	 *
	 * The lifecycle hooks of class modifiers are tracked. When they run, they any
	 * values they access will be added to the modifier, and the modifier will
	 * update if any of those values change.
	 */
	export default class ClassBasedModifier<S = DefaultSignature> {
	    /**
	     *
	     * @param owner An instance of an Owner (for service injection etc.).
	     * @param args The positional and named arguments passed to the modifier.
	     */
	    constructor(owner: Owner, args: ArgsFor<S>);
	    /**
	     * Called when the modifier is installed and any time any tracked state used
	     * in the modifier changes.
	     *
	     * If you need to do first-time-only setup, create a class field representing
	     * the initialization state and check it when running the hook. That is also
	     * where and when you should use `registerDestructor` for any teardown you
	     * need to do. For example:
	     *
	     * ```js
	     * function disconnect(instance) {
	     *  instance.observer?.disconnect();
	     * }
	     *
	     * class IntersectionObserver extends Modifier {
	     *   observer;
	     *
	     *   constructor(owner, args) {
	     *     super(owner, args);
	     *     registerDestructor(this, disconnect);
	     *   }
	     *
	     *   modify(element, callback, options) {
	     *     disconnect(this);
	     *
	     *     this.observer = new IntersectionObserver(callback, options);
	     *     this.observer.observe(element);
	     *   }
	     * }
	     * ```
	     *
	     * @param element The element to which the modifier is applied.
	     * @param positional The positional arguments to the modifier.
	     * @param named The named arguments to the modifier.
	     */
	    modify(element: ElementFor<S>, positional: PositionalArgs<S>, named: NamedArgs<S>): void;
	}
	//# sourceMappingURL=modifier.d.ts.map
}
declare module 'ember-modifier/-private/function-based/modifier' {
	import type { ElementFor, EmptyObject, NamedArgs, PositionalArgs } from 'ember-modifier/-private/signature';
	import type Modifier from 'ember-modifier/-private/class-based/modifier';
	export abstract class FunctionBasedModifierInstance<S> extends Modifier<S> {
	    protected abstract __concrete__: never;
	}
	export type FunctionBasedModifier<S> = abstract new () => FunctionBasedModifierInstance<S>;
	/**
	 * The (optional) return type for a modifier which needs to perform some kind of
	 * cleanup or teardown -- for example, removing an event listener from an
	 * element besides the one passed into the modifier.
	 */
	export type Teardown = () => unknown;
	/**
	 * An API for writing simple modifiers.
	 *
	 * This function runs the first time when the element the modifier was applied
	 * to is inserted into the DOM, and it *autotracks* while running. Any values
	 * that it accesses will be tracked, including any of its arguments that it
	 * accesses, and if any of them changes, the function will run again.
	 *
	 * **Note:** this will *not* automatically rerun because an argument changes. It
	 * will only rerun if it is *using* that argument (the same as with auto-tracked
	 * state in general).
	 *
	 * The modifier can also optionally return a *destructor*. The destructor
	 * function will be run just before the next update, and when the element is
	 * being removed entirely. It should generally clean up the changes that the
	 * modifier made in the first place.
	 *
	 * @param fn The function which defines the modifier.
	 */
	export default function modifier<E extends Element, P extends unknown[], N = EmptyObject>(fn: (element: E, positional: P, named: N) => void | Teardown): FunctionBasedModifier<{
	    Args: {
	        Positional: P;
	        Named: N;
	    };
	    Element: E;
	}>;
	/**
	 * An API for writing simple modifiers.
	 *
	 * This function runs the first time when the element the modifier was applied
	 * to is inserted into the DOM, and it *autotracks* while running. Any values
	 * that it accesses will be tracked, including any of its arguments that it
	 * accesses, and if any of them changes, the function will run again.
	 *
	 * **Note:** this will *not* automatically rerun because an argument changes. It
	 * will only rerun if it is *using* that argument (the same as with auto-tracked
	 * state in general).
	 *
	 * The modifier can also optionally return a *destructor*. The destructor
	 * function will be run just before the next update, and when the element is
	 * being removed entirely. It should generally clean up the changes that the
	 * modifier made in the first place.
	 *
	 * @param fn The function which defines the modifier.
	 */
	export default function modifier<S>(fn: (element: ElementFor<S>, positional: PositionalArgs<S>, named: NamedArgs<S>) => void | Teardown): FunctionBasedModifier<{
	    Element: ElementFor<S>;
	    Args: {
	        Named: NamedArgs<S>;
	        Positional: PositionalArgs<S>;
	    };
	}>;
	/**
	 * @internal
	 */
	export type FunctionBasedModifierDefinition<S> = (element: ElementFor<S>, positional: PositionalArgs<S>, named: NamedArgs<S>) => void | Teardown;
	//# sourceMappingURL=modifier.d.ts.map
}
declare module 'ember-modifier' {
	export { default } from 'declarations/-private/class-based/modifier.ts';
	export { default as modifier } from 'declarations/-private/function-based/modifier.ts';
	export type { FunctionBasedModifier } from 'declarations/-private/function-based/modifier.ts';
	export type { ArgsFor, NamedArgs, PositionalArgs, } from 'declarations/-private/signature.ts';
	//# sourceMappingURL=index.d.ts.map
}
declare module 'ember-modifier/-private/class-based/modifier-manager' {
	import type Owner from '@ember/owner';
	import type ClassBasedModifier from 'ember-modifier/-private/class-based/modifier';
	import type { ArgsFor, ElementFor } from 'ember-modifier/-private/signature';
	/**
	 * The state bucket used throughout the life-cycle of the modifier. Basically a
	 * state *machine*, where the framework calls us with the version we hand back
	 * to it at each phase. The two states are the two `extends` versions of this
	 * below.
	 *
	 * @internal
	 */
	interface State<S> {
	    instance: ClassBasedModifier<S>;
	}
	/**
	 * The `State` after calling `createModifier`, and therefore the state available
	 * at the start of `InstallModifier`.
	 * @internal
	 */
	interface CreatedState<S> extends State<S> {
	    element: null;
	}
	/**
	 * The `State` after calling `installModifier`, and therefore the state
	 * available in all `updateModifier` calls and in `destroyModifier`.
	 * @internal
	 */
	interface InstalledState<S> extends State<S> {
	    element: ElementFor<S>;
	}
	export default class ClassBasedModifierManager<S> {
	    private owner;
	    capabilities: unknown;
	    constructor(owner: Owner);
	    createModifier(modifierClass: typeof ClassBasedModifier, args: ArgsFor<S>): CreatedState<S>;
	    installModifier(createdState: CreatedState<S>, element: ElementFor<S>, args: ArgsFor<S>): void;
	    updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void;
	    destroyModifier({ instance }: InstalledState<S>): void;
	}
	export {};
	//# sourceMappingURL=modifier-manager.d.ts.map
}
declare module 'ember-modifier/-private/function-based/modifier-manager' {
	import type { FunctionBasedModifierDefinition, Teardown } from 'ember-modifier/-private/function-based/modifier';
	import type { ArgsFor, ElementFor } from 'ember-modifier/-private/signature';
	interface State<S> {
	    instance: FunctionBasedModifierDefinition<S>;
	}
	interface CreatedState<S> extends State<S> {
	    element: null;
	}
	interface InstalledState<S> extends State<S> {
	    element: ElementFor<S>;
	    teardown?: Teardown;
	}
	export default class FunctionBasedModifierManager<S> {
	    capabilities: unknown;
	    createModifier(instance: FunctionBasedModifierDefinition<S>): CreatedState<S>;
	    installModifier(createdState: CreatedState<S>, element: ElementFor<S>, args: ArgsFor<S>): void;
	    updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void;
	    destroyModifier(state: InstalledState<S>): void;
	    getDebugName(state: InstalledState<S>): string;
	    getDebugInstance(state: InstalledState<S>): InstalledState<S>;
	}
	export {};
	//# sourceMappingURL=modifier-manager.d.ts.map
}
