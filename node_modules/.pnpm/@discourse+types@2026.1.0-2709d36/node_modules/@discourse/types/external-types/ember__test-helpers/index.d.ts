declare module '@ember/test-helpers/-tuple' {
	export type Lit = string | number | boolean | undefined | null | void | {};
	export default function tuple<T extends Lit[]>(...args: T): T;
	//# sourceMappingURL=-tuple.d.ts.map
}
declare module '@ember/test-helpers/-utils' {
	export const nextTick: (cb: () => void) => Promise<void>;
	export const futureTick: typeof setTimeout;
	/**
	 Retrieves an array of destroyables from the specified property on the object
	 provided, iterates that array invoking each function, then deleting the
	 property (clearing the array).

	 @private
	 @param {Object} object an object to search for the destroyable array within
	 @param {string} property the property on the object that contains the destroyable array
	*/
	export function runDestroyablesFor(object: any, property: string): void;
	/**
	 Returns whether the passed in string consists only of numeric characters.

	 @private
	 @param {string} n input string
	 @returns {boolean} whether the input string consists only of numeric characters
	 */
	export function isNumeric(n: string): boolean;
	/**
	  Checks if an element is considered visible by the focus area spec.

	  @private
	  @param {Element} element the element to check
	  @returns {boolean} `true` when the element is visible, `false` otherwise
	*/
	export function isVisible(element: Element): boolean;
	/**
	  Checks if an element is disabled.

	  @private
	  @param {Element} element the element to check
	  @returns {boolean} `true` when the element is disabled, `false` otherwise
	*/
	export function isDisabled(element: HTMLElement): boolean;
	//# sourceMappingURL=-utils.d.ts.map
}
declare module '@ember/test-helpers/application' {
	import Application from '@ember/application';
	/**
	  Stores the provided application instance so that tests being ran will be aware of the application under test.

	  - Required by `setupApplicationContext` method.
	  - Used by `setupContext` and `setupRenderingContext` when present.

	  @public
	  @param {Ember.Application} application the application that will be tested
	*/
	export function setApplication(application: Application): void;
	/**
	  Retrieve the application instance stored by `setApplication`.

	  @public
	  @returns {Ember.Application} the previously stored application instance under test
	*/
	export function getApplication(): Application | undefined;
	//# sourceMappingURL=application.d.ts.map
}
declare module '@ember/test-helpers/build-owner' {
	import Application from '@ember/application';
	import type { Resolver } from '@ember/owner';
	import type EmberOwner from '@ember/owner';
	import type { SimpleElement } from '@simple-dom/interface';
	export interface Owner extends EmberOwner {
	    _emberTestHelpersMockOwner?: boolean;
	    rootElement?: string | Element | SimpleElement | null;
	    _lookupFactory?(key: string): any;
	    visit(url: string, options?: {
	        [key: string]: any;
	    }): Promise<any>;
	}
	/**
	  Creates an "owner" (an object that either _is_ or duck-types like an
	  `Ember.ApplicationInstance`) from the provided options.

	  If `options.application` is present (e.g. setup by an earlier call to
	  `setApplication`) an `Ember.ApplicationInstance` is built via
	  `application.buildInstance()`.

	  If `options.application` is not present, we fall back to using
	  `options.resolver` instead (setup via `setResolver`). This creates a mock
	  "owner" by using a custom created combination of `Ember.Registry`,
	  `Ember.Container`, `Ember._ContainerProxyMixin`, and
	  `Ember._RegistryProxyMixin`.

	  @private
	  @param {Ember.Application} [application] the Ember.Application to build an instance from
	  @param {Ember.Resolver} [resolver] the resolver to use to back a "mock owner"
	  @returns {Promise<Ember.ApplicationInstance>} a promise resolving to the generated "owner"
	*/
	export default function buildOwner(application: Application | undefined | null, resolver: Resolver | undefined | null): Promise<Owner>;
	//# sourceMappingURL=build-owner.d.ts.map
}
declare module '@ember/test-helpers/global' {
	 const _default: any;
	export default _default;
	//# sourceMappingURL=global.d.ts.map
}
declare module '@ember/test-helpers/has-ember-version' {
	/**
	  Checks if the currently running Ember version is greater than or equal to the
	  specified major and minor version numbers.

	  @private
	  @param {number} major the major version number to compare
	  @param {number} minor the minor version number to compare
	  @returns {boolean} true if the Ember version is >= MAJOR.MINOR specified, false otherwise
	*/
	export default function hasEmberVersion(major: number, minor: number): boolean;
	//# sourceMappingURL=has-ember-version.d.ts.map
}
declare module '@ember/test-helpers/helper-hooks' {
	export type Hook = (...args: any[]) => void | Promise<void>;
	export type HookLabel = 'start' | 'end' | 'targetFound';
	export type HookUnregister = {
	    unregister: () => void;
	};
	/**
	 * Registers a function to be run during the invocation of a test helper.
	 *
	 * @param {string} helperName The name of the test helper in which to run the hook.
	 *                            Test helper names include `blur`, `click`, `doubleClick`, `fillIn`,
	 *                            `fireEvent`, `focus`, `render`, `scrollTo`, `select`, `tab`, `tap`, `triggerEvent`,
	 *                            `triggerKeyEvent`, `typeIn`, and `visit`.
	 * @param {string} label A label to help identify the hook. Built-in labels include `start`, `end`,
	 *                       and `targetFound`, the former designating either the start or end of
	 *                       the helper invocation.
	 * @param {Function} hook The hook function to run when the test helper is invoked.
	 * @returns {HookUnregister} An object containing an `unregister` function that unregisters
	 *                           the specific hook initially registered to the helper.
	 * @example
	 * <caption>
	 *   Registering a hook for the `end` point of the `click` test helper invocation
	 * </caption>
	 *
	 * const hook = registerHook('click', 'end', () => {
	 *   console.log('Running `click:end` test helper hook');
	 * });
	 *
	 * // Unregister the hook at some later point in time
	 * hook.unregister();
	 */
	export function registerHook(helperName: string, label: HookLabel, hook: Hook): HookUnregister;
	/**
	 * Runs all hooks registered for a specific test helper.
	 *
	 * @param {string} helperName The name of the test helper in which to run the hook.
	 *                            Test helper names include `blur`, `click`, `doubleClick`, `fillIn`,
	 *                            `fireEvent`, `focus`, `render`, `scrollTo`, `select`, `tab`, `tap`, `triggerEvent`,
	 *                            `triggerKeyEvent`, `typeIn`, and `visit`.
	 * @param {string} label A label to help identify the hook. Built-in labels include `start`, `end`,
	 *                       and `targetFound`, the former designating either the start or end of
	 *                       the helper invocation.
	 * @param {unknown[]} args Any arguments originally passed to the test helper.
	 * @returns {Promise<void>} A promise representing the serial invocation of the hooks.
	 */
	export function runHooks(helperName: string, label: HookLabel, ...args: unknown[]): Promise<void>;
	//# sourceMappingURL=helper-hooks.d.ts.map
}
declare module '@ember/test-helpers/resolver' {
	import type { Resolver } from '@ember/owner';
	/**
	  Stores the provided resolver instance so that tests being ran can resolve
	  objects in the same way as a normal application.

	  Used by `setupContext` and `setupRenderingContext` as a fallback when `setApplication` was _not_ used.

	  @public
	  @param {Ember.Resolver} resolver the resolver to be used for testing
	*/
	export function setResolver(resolver: Resolver): void;
	/**
	  Retrieve the resolver instance stored by `setResolver`.

	  @public
	  @returns {Ember.Resolver} the previously stored resolver
	*/
	export function getResolver(): Resolver | undefined;
	//# sourceMappingURL=resolver.d.ts.map
}
declare module '@ember/test-helpers/-internal/deprecations' {
	import type { BaseContext } from '@ember/test-helpers/setup-context';
	export interface DeprecationOptions {
	    id: string;
	    until: string;
	    for?: string;
	    since?: {
	        available: string;
	    };
	}
	export interface DeprecationFailure {
	    message: string;
	    options?: DeprecationOptions;
	}
	/**
	 *
	 * Provides the list of deprecation failures associated with a given base context;
	 *
	 * @private
	 * @param {BaseContext} [context] the test context
	 * @return {Array<DeprecationFailure>} the Deprecation Failures associated with the corresponding BaseContext;
	 */
	export function getDeprecationsForContext(context: BaseContext): Array<DeprecationFailure>;
	/**
	 *
	 * Provides the list of deprecation failures associated with a given base
	 * context which occur while a callback is executed. This callback can be
	 * synchronous, or it can be an async function.
	 *
	 * @private
	 * @param {BaseContext} [context] the test context
	 * @param {Function} [callback] The callback that when executed will have its DeprecationFailure recorded
	 * @return {Array<DeprecationFailure>} The Deprecation Failures associated with the corresponding baseContext which occurred while the CallbackFunction was executed
	 */
	export function getDeprecationsDuringCallbackForContext(context: BaseContext, callback: () => void): Array<DeprecationFailure> | Promise<Array<DeprecationFailure>>;
	//# sourceMappingURL=deprecations.d.ts.map
}
declare module '@ember/test-helpers/-internal/warnings' {
	import type { BaseContext } from '@ember/test-helpers/setup-context';
	export interface WarningOptions {
	    id?: string;
	}
	export interface Warning {
	    message: string;
	    options?: WarningOptions;
	}
	/**
	 *
	 * Provides the list of warnings associated with a given base context;
	 *
	 * @private
	 * @param {BaseContext} [context] the test context
	 * @return {Array<Warning>} the warnings associated with the corresponding BaseContext;
	 */
	export function getWarningsForContext(context: BaseContext): Array<Warning>;
	/**
	 *
	 * Provides the list of warnings associated with a given test context which
	 * occurred only while a the provided callback is executed. This callback can be
	 * synchronous, or it can be an async function.
	 *
	 * @private
	 * @param {BaseContext} [context] the test context
	 * @param {Function} [callback] The callback that when executed will have its warnings recorded
	 * @return {Array<Warning>} The warnings associated with the corresponding baseContext which occurred while the CallbackFunction was executed
	 */
	export function getWarningsDuringCallbackForContext(context: BaseContext, callback: () => void): Array<Warning> | Promise<Array<Warning>>;
	//# sourceMappingURL=warnings.d.ts.map
}
declare module '@ember/test-helpers/setup-context' {
	import type { Resolver } from '@ember/owner';
	import { type Owner } from 'declarations/build-owner.ts';
	import { type DeprecationFailure } from 'declarations/-internal/deprecations.ts';
	import { type Warning } from 'declarations/-internal/warnings.ts';
	export interface SetupContextOptions {
	    resolver?: Resolver | undefined;
	}
	export type BaseContext = object;
	/**
	 * The public API for the test context, which test authors can depend on being
	 * available.
	 *
	 * Note: this is *not* user-constructible; it becomes available by calling
	 * `setupContext()` with a base context object.
	 */
	export interface TestContext extends BaseContext {
	    owner: Owner;
	    set<T>(key: string, value: T): T;
	    setProperties<T extends Record<string, unknown>>(hash: T): T;
	    get(key: string): unknown;
	    getProperties(...args: string[]): Record<string, unknown>;
	    pauseTest(): Promise<void>;
	    resumeTest(): void;
	}
	export function isTestContext(context: BaseContext): context is TestContext;
	/**
	  Stores the provided context as the "global testing context".

	  Generally setup automatically by `setupContext`.

	  @public
	  @param {Object} context the context to use
	*/
	export function setContext(context: BaseContext): void;
	/**
	  Retrieve the "global testing context" as stored by `setContext`.

	  @public
	  @returns {Object} the previously stored testing context
	*/
	export function getContext(): BaseContext | undefined;
	/**
	  Clear the "global testing context".

	  Generally invoked from `teardownContext`.

	  @public
	*/
	export function unsetContext(): void;
	/**
	 * Returns a promise to be used to pauses the current test (due to being
	 * returned from the test itself).  This is useful for debugging while testing
	 * or for test-driving.  It allows you to inspect the state of your application
	 * at any point.
	 *
	 * The test framework wrapper (e.g. `ember-qunit` or `ember-mocha`) should
	 * ensure that when `pauseTest()` is used, any framework specific test timeouts
	 * are disabled.
	 *
	 * @public
	 * @returns {Promise<void>} resolves _only_ when `resumeTest()` is invoked
	 * @example <caption>Usage via ember-qunit</caption>
	 *
	 * import { setupRenderingTest } from 'ember-qunit';
	 * import { render, click, pauseTest } from '@ember/test-helpers';
	 *
	 *
	 * module('awesome-sauce', function(hooks) {
	 *   setupRenderingTest(hooks);
	 *
	 *   test('does something awesome', async function(assert) {
	 *     await render(hbs`{{awesome-sauce}}`);
	 *
	 *     // added here to visualize / interact with the DOM prior
	 *     // to the interaction below
	 *     await pauseTest();
	 *
	 *     click('.some-selector');
	 *
	 *     assert.equal(this.element.textContent, 'this sauce is awesome!');
	 *   });
	 * });
	 */
	export function pauseTest(): Promise<void>;
	/**
	  Resumes a test previously paused by `await pauseTest()`.

	  @public
	*/
	export function resumeTest(): void;
	/**
	 * Returns deprecations which have occurred so far for a the current test context
	 *
	 * @public
	 * @returns {Array<DeprecationFailure>} An array of deprecation messages
	 * @example <caption>Usage via ember-qunit</caption>
	 *
	 * import { getDeprecations } from '@ember/test-helpers';
	 *
	 * module('awesome-sauce', function(hooks) {
	 *   setupRenderingTest(hooks);
	 *
	 *   test('does something awesome', function(assert) {
	       const deprecations = getDeprecations() // => returns deprecations which have occurred so far in this test
	 *   });
	 * });
	 */
	export function getDeprecations(): Array<DeprecationFailure>;
	export type { DeprecationFailure };
	/**
	 * Returns deprecations which have occurred so far for a the current test context
	 *
	 * @public
	 * @param {Function} [callback] The callback that when executed will have its DeprecationFailure recorded
	 * @returns {Array<DeprecationFailure> | Promise<Array<DeprecationFailure>>} An array of deprecation messages
	 * @example <caption>Usage via ember-qunit</caption>
	 *
	 * import { getDeprecationsDuringCallback } from '@ember/test-helpers';
	 *
	 * module('awesome-sauce', function(hooks) {
	 *   setupRenderingTest(hooks);
	 *
	 *   test('does something awesome', function(assert) {
	 *     const deprecations = getDeprecationsDuringCallback(() => {
	 *       // code that might emit some deprecations
	 *
	 *     }); // => returns deprecations which occurred while the callback was invoked
	 *   });
	 *
	 *
	 *   test('does something awesome', async function(assert) {
	 *     const deprecations = await getDeprecationsDuringCallback(async () => {
	 *       // awaited code that might emit some deprecations
	 *     }); // => returns deprecations which occurred while the callback was invoked
	 *   });
	 * });
	 */
	export function getDeprecationsDuringCallback(callback: () => void): Array<DeprecationFailure> | Promise<Array<DeprecationFailure>>;
	/**
	 * Returns warnings which have occurred so far for a the current test context
	 *
	 * @public
	 * @returns {Array<Warning>} An array of warnings
	 * @example <caption>Usage via ember-qunit</caption>
	 *
	 * import { getWarnings } from '@ember/test-helpers';
	 *
	 * module('awesome-sauce', function(hooks) {
	 *   setupRenderingTest(hooks);
	 *
	 *   test('does something awesome', function(assert) {
	       const warnings = getWarnings() // => returns warnings which have occurred so far in this test
	 *   });
	 * });
	 */
	export function getWarnings(): Array<Warning>;
	export type { Warning };
	/**
	 * Returns warnings which have occurred so far for a the current test context
	 *
	 * @public
	 * @param {Function} [callback] The callback that when executed will have its warnings recorded
	 * @returns {Array<Warning> | Promise<Array<Warning>>} An array of warnings information
	 * @example <caption>Usage via ember-qunit</caption>
	 *
	 * import { getWarningsDuringCallback } from '@ember/test-helpers';
	 * import { warn } from '@ember/debug';
	 *
	 * module('awesome-sauce', function(hooks) {
	 *   setupRenderingTest(hooks);
	 *
	 *   test('does something awesome', function(assert) {
	 *     const warnings = getWarningsDuringCallback(() => {
	 *     warn('some warning');
	 *
	 *     }); // => returns warnings which occurred while the callback was invoked
	 *   });
	 *
	 *   test('does something awesome', async function(assert) {
	 *     warn('some warning');
	 *
	 *     const warnings = await getWarningsDuringCallback(async () => {
	 *       warn('some other warning');
	 *     }); // => returns warnings which occurred while the callback was invoked
	 *   });
	 * });
	 */
	export function getWarningsDuringCallback(callback: () => void): Array<Warning> | Promise<Array<Warning>>;
	/**
	  Used by test framework addons to setup the provided context for testing.

	  Responsible for:

	  - sets the "global testing context" to the provided context (`setContext`)
	  - create an owner object and set it on the provided context (e.g. `this.owner`)
	  - setup `this.set`, `this.setProperties`, `this.get`, and `this.getProperties` to the provided context
	  - setting up AJAX listeners
	  - setting up `pauseTest` (also available as `this.pauseTest()`) and `resumeTest` helpers

	  @public
	  @param {Object} base the context to setup
	  @param {Object} [options] options used to override defaults
	  @param {Resolver} [options.resolver] a resolver to use for customizing normal resolution
	  @returns {Promise<Object>} resolves with the context that was setup
	*/
	export default function setupContext<T extends object>(base: T, options?: SetupContextOptions): Promise<T & TestContext>;
	//# sourceMappingURL=setup-context.d.ts.map
}
declare module '@ember/test-helpers/teardown-context' {
	import type { TestContext } from '@ember/test-helpers/setup-context';
	export interface TeardownContextOptions {
	    waitForSettled?: boolean | undefined;
	}
	/**
	  Used by test framework addons to tear down the provided context after testing is completed.

	  Responsible for:

	  - un-setting the "global testing context" (`unsetContext`)
	  - destroy the contexts owner object
	  - remove AJAX listeners

	  @public
	  @param {Object} context the context to setup
	  @param {Object} [options] options used to override defaults
	  @param {boolean} [options.waitForSettled=true] should the teardown wait for `settled()`ness
	  @returns {Promise<void>} resolves when settled
	*/
	export default function teardownContext(context: TestContext, { waitForSettled }?: TeardownContextOptions): Promise<void>;
	//# sourceMappingURL=teardown-context.d.ts.map
}
declare module '@ember/test-helpers/setup-rendering-context' {
	import { type BaseContext, type TestContext } from 'declarations/setup-context.ts';
	import type { Owner } from 'declarations/build-owner.ts'; const hasCalledSetupRenderingContext: unique symbol;
	export interface RenderingTestContext extends TestContext {
	    element: Element | Document;
	    [hasCalledSetupRenderingContext]?: true;
	}
	export function isRenderingTestContext(context: BaseContext): context is RenderingTestContext;
	export interface RenderOptions {
	    /**
	      The owner object to use as the basis for the template. In most cases you
	      will not need to specify this, however if you are using ember-engines
	      it is possible to specify the _engine's_ owner instead of the host
	      applications.
	    */
	    owner?: Owner;
	}
	/**
	  Renders the provided template and appends it to the DOM.

	  @public
	  @param {Template|Component} templateFactoryOrComponent the component (or template) to render
	  @param {RenderOptions} options options hash containing engine owner ({ owner: engineOwner })
	  @returns {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Render a div element with the class 'container'.
	  </caption>
	  await render(hbs`<div class="container"></div>`);
	*/
	export function render(templateFactoryOrComponent: object, options?: RenderOptions): Promise<void>;
	/**
	  Clears any templates previously rendered. This is commonly used for
	  confirming behavior that is triggered by teardown (e.g.
	  `willDestroyElement`).

	  @public
	  @returns {Promise<void>} resolves when settled
	*/
	export function clearRender(): Promise<void>;
	/**
	  Used by test framework addons to setup the provided context for rendering.

	  `setupContext` must have been ran on the provided context
	  prior to calling `setupRenderingContext`.

	  Responsible for:

	  - Setup the basic framework used for rendering by the
	    `render` helper.
	  - Ensuring the event dispatcher is properly setup.
	  - Setting `this.element` to the root element of the testing
	    container (things rendered via `render` will go _into_ this
	    element).

	  @public
	  @param {TestContext} context the context to setup for rendering
	  @returns {Promise<RenderingTestContext>} resolves with the context that was setup

	  @example
	  <caption>
	    Rendering out a paragraph element containing the content 'hello', and then clearing that content via clearRender.
	  </caption>

	  await render(hbs`<p>Hello!</p>`);
	  assert.equal(this.element.textContent, 'Hello!', 'has rendered content');
	  await clearRender();
	  assert.equal(this.element.textContent, '', 'has rendered content');
	*/
	export default function setupRenderingContext(context: TestContext): Promise<RenderingTestContext>;
	export {};
	//# sourceMappingURL=setup-rendering-context.d.ts.map
}
declare module '@ember/test-helpers/rerender' {
	/**
	  Returns a promise which will resolve when rendering has completed. In
	  this context, rendering is completed when all auto-tracked state that is
	  consumed in the template (including any tracked state in models, services,
	  etc.  that are then used in a template) has been updated in the DOM.

	  For example, in a test you might want to update some tracked state and
	  then run some assertions after rendering has completed. You _could_ use
	  `await settled()` in that location, but in some contexts you don't want to
	  wait for full settledness (which includes test waiters, pending AJAX/fetch,
	  run loops, etc) but instead only want to know when that updated value has
	  been rendered in the DOM. **THAT** is what `await rerender()` is _perfect_
	  for.
	  @public
	  @returns {Promise<void>} a promise which fulfills when rendering has completed
	*/
	export default function rerender(): Promise<void>;
	//# sourceMappingURL=rerender.d.ts.map
}
declare module '@ember/test-helpers/setup-application-context' {
	import { type BaseContext, type TestContext } from 'declarations/setup-context.ts';
	export interface ApplicationTestContext extends TestContext {
	    element?: Element | null;
	}
	export function isApplicationTestContext(context: BaseContext): context is ApplicationTestContext;
	/**
	  Determines if we have any pending router transitions (used to determine `settled` state)

	  @public
	  @returns {(boolean|null)} if there are pending transitions
	*/
	export function hasPendingTransitions(): boolean | null;
	/**
	  Setup the current router instance with settledness tracking. Generally speaking this
	  is done automatically (during a `visit('/some-url')` invocation), but under some
	  circumstances (e.g. a non-application test where you manually call `this.owner.setupRouter()`)
	  you may want to call it yourself.

	  @public
	 */
	export function setupRouterSettlednessTracking(): void;
	/**
	  Navigate the application to the provided URL.

	  @public
	  @param {string} url The URL to visit (e.g. `/posts`)
	  @param {object} options app boot options
	  @returns {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Visiting the route for post 1.
	  </caption>
	  await visit('/posts/1');

	  @example
	  <caption>
	    Visiting the route for post 1 while also providing the `rootElement` app boot option.
	  </caption>
	  await visit('/', { rootElement: '#container' });
	*/
	export function visit(url: string, options?: Record<string, unknown>): Promise<void>;
	/**
	  @public
	  @returns {string} the currently active route name
	*/
	export function currentRouteName(): string;
	/**
	  @public
	  @returns {string} the applications current url
	*/
	export function currentURL(): string;
	/**
	  Used by test framework addons to setup the provided context for working with
	  an application (e.g. routing).

	  `setupContext` must have been run on the provided context prior to calling
	  `setupApplicationContext`.

	  Sets up the basic framework used by application tests.

	  @public
	  @param {Object} context the context to setup
	  @returns {Promise<void>} resolves when the context is set up
	*/
	export default function setupApplicationContext(context: TestContext): Promise<void>;
	//# sourceMappingURL=setup-application-context.d.ts.map
}
declare module '@ember/test-helpers/-internal/debug-info' {
	import type { DebugInfo as BackburnerDebugInfo } from '@ember/runloop/-private/backburner';
	import { type PendingWaiterState } from '@ember/test-waiters';
	type MaybeDebugInfo = BackburnerDebugInfo | null;
	interface SettledState {
	    hasPendingTimers: boolean;
	    hasRunLoop: boolean;
	    hasPendingLegacyWaiters: boolean;
	    hasPendingTestWaiters: boolean;
	    hasPendingRequests: boolean;
	    isRenderPending: boolean;
	}
	interface SummaryInfo {
	    hasPendingRequests: boolean;
	    hasPendingLegacyWaiters: boolean;
	    hasPendingTestWaiters: boolean;
	    pendingTestWaiterInfo: PendingWaiterState;
	    autorunStackTrace: string | undefined | null;
	    pendingTimersCount: number;
	    hasPendingTimers: boolean;
	    pendingTimersStackTraces: (string | undefined)[];
	    pendingScheduledQueueItemCount: number;
	    pendingScheduledQueueItemStackTraces: (string | undefined)[];
	    hasRunLoop: boolean;
	    isRenderPending: boolean;
	}
	/**
	 * The base functionality which may be present on the `SettledState` interface
	 * in the `settled` module (**not** the one in this module).
	 */
	export default interface DebugInfo {
	    toConsole: () => void;
	}
	/**
	 * Determines if the `getDebugInfo` method is available in the
	 * running verison of backburner.
	 *
	 * @returns {boolean} True if `getDebugInfo` is present in backburner, otherwise false.
	 */
	export function backburnerDebugInfoAvailable(): boolean;
	/**
	 * Retrieves debug information from backburner's current deferred actions queue (runloop instance).
	 * If the `getDebugInfo` method isn't available, it returns `null`.
	 *
	 * @public
	 * @returns {MaybeDebugInfo | null} Backburner debugInfo or, if the getDebugInfo method is not present, null
	 */
	export function getDebugInfo(): MaybeDebugInfo;
	/**
	 * Encapsulates debug information for an individual test. Aggregates information
	 * from:
	 * - info provided by getSettledState
	 *    - hasPendingTimers
	 *    - hasRunLoop
	 *    - hasPendingWaiters
	 *    - hasPendingRequests
	 * - info provided by backburner's getDebugInfo method (timers, schedules, and stack trace info)
	 *
	 */
	export class TestDebugInfo implements DebugInfo {
	    private _settledState;
	    private _debugInfo;
	    private _summaryInfo;
	    constructor(settledState: SettledState, debugInfo?: MaybeDebugInfo);
	    get summary(): SummaryInfo;
	    toConsole(_console?: Console): void;
	    _formatCount(title: string, count: number): string;
	}
	export {};
	//# sourceMappingURL=debug-info.d.ts.map
}
declare module '@ember/test-helpers/settled' {
	import type DebugInfo from 'declarations/-internal/debug-info.ts';
	/**
	  Clears listeners that were previously setup for `ajaxSend` and `ajaxComplete`.

	  @private
	*/
	export function _teardownAJAXHooks(): void;
	/**
	  Sets up listeners for `ajaxSend` and `ajaxComplete`.

	  @private
	*/
	export function _setupAJAXHooks(): void;
	export interface SettledState {
	    hasRunLoop: boolean;
	    hasPendingTimers: boolean;
	    hasPendingWaiters: boolean;
	    hasPendingRequests: boolean;
	    hasPendingTransitions: boolean | null;
	    isRenderPending: boolean;
	    pendingRequestCount: number;
	    debugInfo: DebugInfo;
	}
	/**
	  Check various settledness metrics, and return an object with the following properties:

	  - `hasRunLoop` - Checks if a run-loop has been started. If it has, this will
	    be `true` otherwise it will be `false`.
	  - `hasPendingTimers` - Checks if there are scheduled timers in the run-loop.
	    These pending timers are primarily registered by `Ember.run.schedule`. If
	    there are pending timers, this will be `true`, otherwise `false`.
	  - `hasPendingWaiters` - Checks if any registered test waiters are still
	    pending (e.g. the waiter returns `true`). If there are pending waiters,
	    this will be `true`, otherwise `false`.
	  - `hasPendingRequests` - Checks if there are pending AJAX requests (based on
	    `ajaxSend` / `ajaxComplete` events triggered by `jQuery.ajax`). If there
	    are pending requests, this will be `true`, otherwise `false`.
	  - `hasPendingTransitions` - Checks if there are pending route transitions. If the
	    router has not been instantiated / setup for the test yet this will return `null`,
	    if there are pending transitions, this will be `true`, otherwise `false`.
	  - `pendingRequestCount` - The count of pending AJAX requests.
	  - `debugInfo` - Debug information that's combined with info return from backburner's
	    getDebugInfo method.
	  - `isRenderPending` - Checks if there are any pending render operations. This will be true as long
	    as there are tracked values in the template that have not been rerendered yet.

	  @public
	  @returns {Object} object with properties for each of the metrics used to determine settledness
	*/
	export function getSettledState(): SettledState;
	/**
	  Checks various settledness metrics (via `getSettledState()`) to determine if things are settled or not.

	  Settled generally means that there are no pending timers, no pending waiters,
	  no pending AJAX requests, and no current run loop. However, new settledness
	  metrics may be added and used as they become available.

	  @public
	  @returns {boolean} `true` if settled, `false` otherwise
	*/
	export function isSettled(): boolean;
	/**
	  Returns a promise that resolves when in a settled state (see `isSettled` for
	  a definition of "settled state").

	  @public
	  @returns {Promise<void>} resolves when settled
	*/
	export default function settled(): Promise<void>;
	//# sourceMappingURL=settled.d.ts.map
}
declare module '@ember/test-helpers/wait-until' {
	type Falsy = false | 0 | '' | null | undefined;
	export interface Options {
	    timeout?: number;
	    timeoutMessage?: string;
	}
	/**
	  Wait for the provided callback to return a truthy value.

	  This does not leverage `settled()`, and as such can be used to manage async
	  while _not_ settled (e.g. "loading" or "pending" states).

	  @public
	  @param {Function} callback the callback to use for testing when waiting should stop
	  @param {Object} [options] options used to override defaults
	  @param {number} [options.timeout=1000] the maximum amount of time to wait
	  @param {string} [options.timeoutMessage='waitUntil timed out'] the message to use in the reject on timeout
	  @returns {Promise} resolves with the callback value when it returns a truthy value

	  @example
	  <caption>
	    Waiting until a selected element displays text:
	  </caption>
	  await waitUntil(function() {
	    return find('.my-selector').textContent.includes('something')
	  }, { timeout: 2000 })
	*/
	export default function waitUntil<T>(callback: () => T | void | Falsy, options?: Options): Promise<T>;
	export {};
	//# sourceMappingURL=wait-until.d.ts.map
}
declare module '@ember/test-helpers/validate-error-handler' {
	type ErrorHandlerValidation = Readonly<{
	    isValid: true;
	    message: null;
	}> | Readonly<{
	    isValid: false;
	    message: string;
	}>;
	/**
	 * Validate the provided error handler to confirm that it properly re-throws
	 * errors when `Ember.testing` is true.
	 *
	 * This is intended to be used by test framework hosts (or other libraries) to
	 * ensure that `Ember.onerror` is properly configured. Without a check like
	 * this, `Ember.onerror` could _easily_ swallow all errors and make it _seem_
	 * like everything is just fine (and have green tests) when in reality
	 * everything is on fire...
	 *
	 * @public
	 * @param {Function} [callback=Ember.onerror] the callback to validate
	 * @returns {Object} object with `isValid` and `message`
	 *
	 * @example <caption>Example implementation for `ember-qunit`</caption>
	 *
	 * import { validateErrorHandler } from '@ember/test-helpers';
	 *
	 * test('Ember.onerror is functioning properly', function(assert) {
	 *   let result = validateErrorHandler();
	 *   assert.ok(result.isValid, result.message);
	 * });
	 */
	export default function validateErrorHandler(callback?: Function | undefined): ErrorHandlerValidation;
	export {};
	//# sourceMappingURL=validate-error-handler.d.ts.map
}
declare module '@ember/test-helpers/setup-onerror' {
	import { type BaseContext } from 'declarations/setup-context.ts';
	/**
	 * Sets the `Ember.onerror` function for tests. This value is intended to be reset after
	 * each test to ensure correct test isolation. To reset, you should simply call `setupOnerror`
	 * without an `onError` argument.
	 *
	 * @public
	 * @param {Function} onError the onError function to be set on Ember.onerror
	 *
	 * @example <caption>Example implementation for `ember-qunit` or `ember-mocha`</caption>
	 *
	 * import { setupOnerror } from '@ember/test-helpers';
	 *
	 * test('Ember.onerror is stubbed properly', function(assert) {
	 *   setupOnerror(function(err) {
	 *     assert.ok(err);
	 *   });
	 * });
	 */
	export default function setupOnerror(onError?: (error: Error) => void): void;
	/**
	 * Resets `Ember.onerror` to the value it originally was at the start of the test run.
	 * If there is no context or cached value this is a no-op.
	 *
	 * @public
	 *
	 * @example
	 *
	 * import { resetOnerror } from '@ember/test-helpers';
	 *
	 * QUnit.testDone(function() {
	 *   resetOnerror();
	 * })
	 */
	export function resetOnerror(): void;
	/**
	 * Caches the current value of Ember.onerror. When `setupOnerror` is called without a value
	 * or when `resetOnerror` is called the value will be set to what was cached here.
	 *
	 * @private
	 * @param {BaseContext} context the text context
	 */
	export function _prepareOnerror(context: BaseContext): void;
	/**
	 * Removes the cached value of Ember.onerror.
	 *
	 * @private
	 * @param {BaseContext} context the text context
	 */
	export function _cleanupOnerror(context: BaseContext): void;
	//# sourceMappingURL=setup-onerror.d.ts.map
}
declare module '@ember/test-helpers/-internal/debug-info-helpers' {
	export interface DebugInfoHelper {
	    name: string;
	    log: () => void;
	}
	export const debugInfoHelpers: Set<DebugInfoHelper>;
	/**
	 * Registers a custom debug info helper to augment the output for test isolation validation.
	 *
	 * @public
	 * @param {DebugInfoHelper} debugHelper a custom debug info helper
	 * @example
	 *
	 * import { registerDebugInfoHelper } from '@ember/test-helpers';
	 *
	 * registerDebugInfoHelper({
	 *   name: 'Date override detection',
	 *   log() {
	 *     if (dateIsOverridden()) {
	 *       console.log(this.name);
	 *       console.log('The date object has been overridden');
	 *     }
	 *   }
	 * })
	 */
	export default function registerDebugInfoHelper(debugHelper: DebugInfoHelper): void;
	//# sourceMappingURL=debug-info-helpers.d.ts.map
}
declare module '@ember/test-helpers/test-metadata' {
	import type { BaseContext } from '@ember/test-helpers/setup-context'; class TestMetadata {
	    [key: string]: any;
	    testName?: string;
	    setupTypes: string[];
	    usedHelpers: string[];
	    constructor();
	    get isRendering(): boolean;
	    get isApplication(): boolean;
	}
	export { TestMetadata as __TestMetadata, };
	export type { 
	/**
	 * A non-user-constructible interface representing the metadata associated
	 * with a test, designed for test frameworks to use e.g. with their reporters.
	 */
	TestMetadata, };
	/**
	 * Gets the test metadata associated with the provided test context. Will create
	 * a new test metadata object if one does not exist.
	 *
	 * @param {BaseContext} context the context to use
	 * @returns {TestMetadata} the test metadata for the provided context
	 */
	export default function getTestMetadata(context: BaseContext): TestMetadata;
	//# sourceMappingURL=test-metadata.d.ts.map
}
declare module '@ember/test-helpers/dom/-target' {
	import type { IDOMElementDescriptor } from 'dom-element-descriptors';
	export type Target = string | Element | IDOMElementDescriptor | Document | Window;
	export interface HTMLElementContentEditable extends HTMLElement {
	    isContentEditable: true;
	}
	export function isElement(target: unknown): target is Element;
	export function isWindow(target: Target): target is Window;
	export function isDocument(target: unknown): target is Document;
	export function isContentEditable(element: Element): element is HTMLElementContentEditable;
	//# sourceMappingURL=-target.d.ts.map
}
declare module '@ember/test-helpers/dom/click' {
	import { type Target } from 'declarations/dom/-target.ts';
	/**
	 * Represent a particular mouse button being clicked.
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons for available options.
	 */
	export const DEFAULT_CLICK_OPTIONS: {
	    buttons: number;
	    button: number;
	};
	/**
	  @private
	  @param {Element} element the element to click on
	  @param {MouseEventInit} options the options to be merged into the mouse events
	  @return {Promise<Event | void>} resolves when settled
	*/
	export function __click__(element: Element | Document | Window, options: MouseEventInit): Promise<Event | void>;
	/**
	  Clicks on the specified target.

	  Sends a number of events intending to simulate a "real" user clicking on an
	  element.

	  For non-focusable elements the following events are triggered (in order):

	  - `mousedown`
	  - `mouseup`
	  - `click`

	  For focusable (e.g. form control) elements the following events are triggered
	  (in order):

	  - `mousedown`
	  - `focus`
	  - `focusin`
	  - `mouseup`
	  - `click`

	  The exact listing of events that are triggered may change over time as needed
	  to continue to emulate how actual browsers handle clicking a given element.

	  Use the `options` hash to change the parameters of the [MouseEvents](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent).
	  You can use this to specify modifier keys as well.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to click on
	  @param {MouseEventInit} _options the options to be merged into the mouse events.
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Emulating clicking a button using `click`
	  </caption>
	  click('button');

	  @example
	  <caption>
	    Emulating clicking a button and pressing the `shift` key simultaneously using `click` with `options`.
	  </caption>

	  click('button', { shiftKey: true });
	*/
	export default function click(target: Target, _options?: MouseEventInit): Promise<void>;
	//# sourceMappingURL=click.d.ts.map
}
declare module '@ember/test-helpers/dom/double-click' {
	import { type Target } from 'declarations/dom/-target.ts';
	/**
	  @private
	  @param {Element} element the element to double-click on
	  @param {MouseEventInit} options the options to be merged into the mouse events
	  @returns {Promise<Event | void>} resolves when settled
	*/
	export function __doubleClick__(element: Element | Document | Window, options: MouseEventInit): Promise<Event | void>;
	/**
	  Double-clicks on the specified target.

	  Sends a number of events intending to simulate a "real" user clicking on an
	  element.

	  For non-focusable elements the following events are triggered (in order):

	  - `mousedown`
	  - `mouseup`
	  - `click`
	  - `mousedown`
	  - `mouseup`
	  - `click`
	  - `dblclick`

	  For focusable (e.g. form control) elements the following events are triggered
	  (in order):

	  - `mousedown`
	  - `focus`
	  - `focusin`
	  - `mouseup`
	  - `click`
	  - `mousedown`
	  - `mouseup`
	  - `click`
	  - `dblclick`

	  The exact listing of events that are triggered may change over time as needed
	  to continue to emulate how actual browsers handle clicking a given element.

	  Use the `options` hash to change the parameters of the [MouseEvents](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent).

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to double-click on
	  @param {MouseEventInit} _options the options to be merged into the mouse events
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Emulating double clicking a button using `doubleClick`
	  </caption>

	  doubleClick('button');

	  @example
	  <caption>
	    Emulating double clicking a button and pressing the `shift` key simultaneously using `click` with `options`.
	  </caption>

	  doubleClick('button', { shiftKey: true });
	*/
	export default function doubleClick(target: Target, _options?: MouseEventInit): Promise<void>;
	//# sourceMappingURL=double-click.d.ts.map
}
declare module '@ember/test-helpers/dom/tab' {
	/**
	  Emulates the user pressing the tab button.

	  Sends a number of events intending to simulate a "real" user pressing tab on their
	  keyboard.

	  @public
	  @param {Object} [options] optional tab behaviors
	  @param {boolean} [options.backwards=false] indicates if the the user navigates backwards
	  @param {boolean} [options.unRestrainTabIndex=false] indicates if tabbing should throw an error when tabindex is greater than 0
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Emulating pressing the `TAB` key
	  </caption>
	  tab();

	  @example
	  <caption>
	    Emulating pressing the `SHIFT`+`TAB` key combination
	  </caption>
	  tab({ backwards: true });
	*/
	export default function triggerTab({ backwards, unRestrainTabIndex, }?: {
	    backwards?: boolean | undefined;
	    unRestrainTabIndex?: boolean | undefined;
	}): Promise<void>;
	//# sourceMappingURL=tab.d.ts.map
}
declare module '@ember/test-helpers/dom/tap' {
	import type { Target } from 'declarations/dom/-target.ts';
	/**
	  Taps on the specified target.

	  Sends a number of events intending to simulate a "real" user tapping on an
	  element.

	  For non-focusable elements the following events are triggered (in order):

	  - `touchstart`
	  - `touchend`
	  - `mousedown`
	  - `mouseup`
	  - `click`

	  For focusable (e.g. form control) elements the following events are triggered
	  (in order):

	  - `touchstart`
	  - `touchend`
	  - `mousedown`
	  - `focus`
	  - `focusin`
	  - `mouseup`
	  - `click`

	  The exact listing of events that are triggered may change over time as needed
	  to continue to emulate how actual browsers handle tapping on a given element.

	  Use the `options` hash to change the parameters of the tap events.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to tap on
	  @param {Object} options the options to be merged into the touch events
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Emulating tapping a button using `tap`
	  </caption>

	  tap('button');
	*/
	export default function tap(target: Target, options?: TouchEventInit): Promise<void>;
	//# sourceMappingURL=tap.d.ts.map
}
declare module '@ember/test-helpers/dom/focus' {
	import { type Target } from 'declarations/dom/-target.ts';
	type FocusRecord = {
	    focusTarget: HTMLElement | SVGElement;
	    previousFocusedElement?: HTMLElement | SVGElement | null;
	};
	/**
	  @private
	  @param {Element} element the element to trigger events on
	  @return {Promise<FocusRecord | Event | void>} resolves when settled
	*/
	export function __focus__(element: HTMLElement | Element | Document | SVGElement): Promise<FocusRecord | Event | void>;
	/**
	  Focus the specified target.

	  Sends a number of events intending to simulate a "real" user focusing an
	  element.

	  The following events are triggered (in order):

	  - `focus`
	  - `focusin`

	  The exact listing of events that are triggered may change over time as needed
	  to continue to emulate how actual browsers handle focusing a given element.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to focus
	  @return {Promise<void>} resolves when the application is settled

	  @example
	  <caption>
	    Emulating focusing an input using `focus`
	  </caption>

	  focus('input');
	*/
	export default function focus(target: Target): Promise<void>;
	export {};
	//# sourceMappingURL=focus.d.ts.map
}
declare module '@ember/test-helpers/dom/blur' {
	import type { Target } from 'declarations/dom/-target.ts';
	/**
	  @private
	  @param {Element} element the element to trigger events on
	  @param {Element} relatedTarget the element that is focused after blur
	  @return {Promise<Event | void>} resolves when settled
	*/
	export function __blur__(element: HTMLElement | Element | Document | SVGElement, relatedTarget?: HTMLElement | Element | Document | SVGElement | null): Promise<Event | void>;
	/**
	  Unfocus the specified target.

	  Sends a number of events intending to simulate a "real" user unfocusing an
	  element.

	  The following events are triggered (in order):

	  - `blur`
	  - `focusout`

	  The exact listing of events that are triggered may change over time as needed
	  to continue to emulate how actual browsers handle unfocusing a given element.

	  @public
	  @param {string|Element|IDOMElementDescriptor} [target=document.activeElement] the element, selector, or descriptor to unfocus
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Emulating blurring an input using `blur`
	  </caption>

	  blur('input');
	*/
	export default function blur(target?: Target): Promise<void>;
	//# sourceMappingURL=blur.d.ts.map
}
declare module '@ember/test-helpers/dom/trigger-event' {
	import type { Target } from 'declarations/dom/-target.ts';
	/**
	 * Triggers an event on the specified target.
	 *
	 * @public
	 * @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to trigger the event on
	 * @param {string} eventType the type of event to trigger
	 * @param {Object} options additional properties to be set on the event
	 * @param {boolean} force if true, will bypass availability checks (false by default)
	 * @return {Promise<void>} resolves when the application is settled
	 *
	 * @example
	 * <caption>
	 * Using `triggerEvent` to upload a file
	 *
	 * When using `triggerEvent` to upload a file the `eventType` must be `change` and you must pass the
	 * `options` param as an object with a key `files` containing an array of
	 * [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob).
	 * </caption>
	 *
	 * triggerEvent(
	 *   'input.fileUpload',
	 *   'change',
	 *   { files: [new Blob(['Ember Rules!'])] }
	 * );
	 *
	 *
	 * @example
	 * <caption>
	 * Using `triggerEvent` to upload a dropped file
	 *
	 * When using `triggerEvent` to handle a dropped (via drag-and-drop) file, the `eventType` must be `drop`. Assuming your `drop` event handler uses the [DataTransfer API](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer),
	 * you must pass the `options` param as an object with a key of `dataTransfer`. The `options.dataTransfer`     object should have a `files` key, containing an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
	 * </caption>
	 *
	 * triggerEvent(
	 *   '[data-test-drop-zone]',
	 *   'drop',
	 *   {
	 *     dataTransfer: {
	 *       files: [new File(['Ember Rules!'], 'ember-rules.txt')]
	 *     }
	 *   }
	 * )
	 */
	export default function triggerEvent(target: Target, eventType: string, options?: Record<string, unknown>, force?: boolean): Promise<void>;
	//# sourceMappingURL=trigger-event.d.ts.map
}
declare module '@ember/test-helpers/dom/fire-event' {
	export const KEYBOARD_EVENT_TYPES: ["keydown", "keypress", "keyup"];
	export type KeyboardEventType = (typeof KEYBOARD_EVENT_TYPES)[number];
	export function isKeyboardEventType(eventType: any): eventType is KeyboardEventType; const MOUSE_EVENT_TYPES: ["click", "mousedown", "mouseup", "dblclick", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover"];
	export type MouseEventType = (typeof MOUSE_EVENT_TYPES)[number];
	export function isMouseEventType(eventType: any): eventType is MouseEventType; const FILE_SELECTION_EVENT_TYPES: ["change"];
	export type FileSelectionEventType = (typeof FILE_SELECTION_EVENT_TYPES)[number];
	export function isFileSelectionEventType(eventType: any): eventType is FileSelectionEventType;
	export function isFileSelectionInput(element: any): element is HTMLInputElement; function fireEvent(element: Element | Document | Window, eventType: KeyboardEventType, options?: any): Promise<Event>; function fireEvent(element: Element | Document | Window, eventType: MouseEventType, options?: any): Promise<Event | void>; function fireEvent(element: Element | Document | Window, eventType: string, options?: any): Promise<Event>;
	export default fireEvent;
	export function _buildKeyboardEvent(type: KeyboardEventType, options?: any): Event;
	//# sourceMappingURL=fire-event.d.ts.map
}
declare module '@ember/test-helpers/dom/trigger-key-event' {
	import { type KeyboardEventType } from 'declarations/dom/fire-event.ts';
	import type { Target } from 'declarations/dom/-target.ts';
	export interface KeyModifiers {
	    ctrlKey?: boolean;
	    altKey?: boolean;
	    shiftKey?: boolean;
	    metaKey?: boolean;
	}
	/**
	  @private
	  @param {Element | Document} element the element to trigger the key event on
	  @param {'keydown' | 'keyup' | 'keypress'} eventType the type of event to trigger
	  @param {number|string} key the `keyCode`(number) or `key`(string) of the event being triggered
	  @param {Object} [modifiers] the state of various modifier keys
	  @return {Promise<Event>} resolves when settled
	 */
	export function __triggerKeyEvent__(element: Element | Document, eventType: KeyboardEventType, key: number | string, modifiers?: KeyModifiers): Promise<Event>;
	/**
	  Triggers a keyboard event of given type in the target element.
	  It also requires the developer to provide either a string with the [`key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
	  or the numeric [`keyCode`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode) of the pressed key.
	  Optionally the user can also provide a POJO with extra modifiers for the event.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to trigger the event on
	  @param {'keydown' | 'keyup' | 'keypress'} eventType the type of event to trigger
	  @param {number|string} key the `keyCode`(number) or `key`(string) of the event being triggered
	  @param {Object} [modifiers] the state of various modifier keys
	  @param {boolean} [modifiers.ctrlKey=false] if true the generated event will indicate the control key was pressed during the key event
	  @param {boolean} [modifiers.altKey=false] if true the generated event will indicate the alt key was pressed during the key event
	  @param {boolean} [modifiers.shiftKey=false] if true the generated event will indicate the shift key was pressed during the key event
	  @param {boolean} [modifiers.metaKey=false] if true the generated event will indicate the meta key was pressed during the key event
	  @return {Promise<void>} resolves when the application is settled unless awaitSettled is false

	  @example
	  <caption>
	    Emulating pressing the `ENTER` key on a button using `triggerKeyEvent`
	  </caption>
	  triggerKeyEvent('button', 'keydown', 'Enter');
	*/
	export default function triggerKeyEvent(target: Target, eventType: KeyboardEventType, key: number | string, modifiers?: KeyModifiers): Promise<void>;
	//# sourceMappingURL=trigger-key-event.d.ts.map
}
declare module '@ember/test-helpers/dom/fill-in' {
	import { type Target } from 'declarations/dom/-target.ts';
	/**
	  Fill the provided text into the `value` property (or set `.innerHTML` when
	  the target is a content editable element) then trigger `change` and `input`
	  events on the specified target.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to enter text into
	  @param {string} text the text to fill into the target element
	  @return {Promise<void>} resolves when the application is settled

	  @example
	  <caption>
	    Emulating filling an input with text using `fillIn`
	  </caption>

	  fillIn('input', 'hello world');
	*/
	export default function fillIn(target: Target, text: string): Promise<void>;
	//# sourceMappingURL=fill-in.d.ts.map
}
declare module '@ember/test-helpers/dom/select' {
	import type { Target } from 'declarations/dom/-target.ts';
	/**
	  Set the `selected` property true for the provided option the target is a
	  select element (or set the select property true for multiple options if the
	  multiple attribute is set true on the HTMLSelectElement) then trigger
	  `change` and `input` events on the specified target.

	  @public
	  @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor for the select element
	  @param {string|string[]} options the value/values of the items to select
	  @param {boolean} keepPreviouslySelected a flag keep any existing selections
	  @return {Promise<void>} resolves when the application is settled

	  @example
	  <caption>
	    Emulating selecting an option or multiple options using `select`
	  </caption>

	  select('select', 'apple');

	  select('select', ['apple', 'orange']);

	  select('select', ['apple', 'orange'], true);
	*/
	export default function select(target: Target, options: string | string[], keepPreviouslySelected?: boolean): Promise<void>;
	//# sourceMappingURL=select.d.ts.map
}
declare module '@ember/test-helpers/dom/wait-for' {
	import { type IDOMElementDescriptor } from 'dom-element-descriptors';
	export interface Options {
	    timeout?: number;
	    count?: number | null;
	    timeoutMessage?: string;
	}
	/**
	  Used to wait for a particular selector to appear in the DOM. Due to the fact
	  that it does not wait for general settledness, this is quite useful for testing
	  interim DOM states (e.g. loading states, pending promises, etc).

	  @param {string|IDOMElementDescriptor} target the selector or DOM element descriptor to wait for
	  @param {Object} [options] the options to be used
	  @param {number} [options.timeout=1000] the time to wait (in ms) for a match
	  @param {number} [options.count=null] the number of elements that should match the provided selector (null means one or more)
	  @return {Promise<Element|Element[]>} resolves when the element(s) appear on the page

	  @example
	  <caption>
	    Waiting until a selector is rendered:
	  </caption>
	  await waitFor('.my-selector', { timeout: 2000 })
	*/
	export default function waitFor(target: string | IDOMElementDescriptor, options?: Options): Promise<Element | Element[]>;
	//# sourceMappingURL=wait-for.d.ts.map
}
declare module '@ember/test-helpers/dom/get-root-element' {
	/**
	  Get the root element of the application under test (usually `#ember-testing`)

	  @public
	  @returns {Element} the root element

	  @example
	  <caption>
	    Getting the root element of the application and checking that it is equal
	    to the element with id 'ember-testing'.
	  </caption>
	  assert.equal(getRootElement(), document.querySelector('#ember-testing'));
	*/
	export default function getRootElement(): Element | Document;
	//# sourceMappingURL=get-root-element.d.ts.map
}
declare module '@ember/test-helpers/dom/find' {
	export default function find<K extends keyof (HTMLElementTagNameMap | SVGElementTagNameMap)>(selector: K): HTMLElementTagNameMap[K] | SVGElementTagNameMap[K] | null;
	export default function find<K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K] | null;
	export default function find<K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K] | null;
	export default function find(selector: string): Element | null;
	//# sourceMappingURL=find.d.ts.map
}
declare module '@ember/test-helpers/dom/find-all' {
	export default function findAll<K extends keyof (HTMLElementTagNameMap | SVGElementTagNameMap)>(selector: K): Array<HTMLElementTagNameMap[K] | SVGElementTagNameMap[K]>;
	export default function findAll<K extends keyof HTMLElementTagNameMap>(selector: K): Array<HTMLElementTagNameMap[K]>;
	export default function findAll<K extends keyof SVGElementTagNameMap>(selector: K): Array<SVGElementTagNameMap[K]>;
	export default function findAll(selector: string): Element[];
	//# sourceMappingURL=find-all.d.ts.map
}
declare module '@ember/test-helpers/dom/type-in' {
	import { type Target } from 'declarations/dom/-target.ts';
	export interface Options {
	    delay?: number;
	}
	/**
	 * Mimics character by character entry into the target `input` or `textarea` element.
	 *
	 * Allows for simulation of slow entry by passing an optional millisecond delay
	 * between key events.

	 * The major difference between `typeIn` and `fillIn` is that `typeIn` triggers
	 * keyboard events as well as `input` and `change`.
	 * Typically this looks like `focus` -> `focusin` -> `keydown` -> `keypress` -> `keyup` -> `input` -> `change`
	 * per character of the passed text (this may vary on some browsers).
	 *
	 * @public
	 * @param {string|Element|IDOMElementDescriptor} target the element, selector, or descriptor to enter text into
	 * @param {string} text the test to fill the element with
	 * @param {Object} options {delay: x} (default 50) number of milliseconds to wait per keypress
	 * @return {Promise<void>} resolves when the application is settled
	 *
	 * @example
	 * <caption>
	 *   Emulating typing in an input using `typeIn`
	 * </caption>
	 *
	 * typeIn('input', 'hello world');
	 */
	export default function typeIn(target: Target, text: string, options?: Options): Promise<void>;
	//# sourceMappingURL=type-in.d.ts.map
}
declare module '@ember/test-helpers/dom/scroll-to' {
	import type { IDOMElementDescriptor } from 'dom-element-descriptors';
	/**
	  Scrolls DOM element, selector, or descriptor to the given coordinates.
	  @public
	  @param {string|HTMLElement|IDOMElementDescriptor} target the element, selector, or descriptor to trigger scroll on
	  @param {Number} x x-coordinate
	  @param {Number} y y-coordinate
	  @return {Promise<void>} resolves when settled

	  @example
	  <caption>
	    Scroll DOM element to specific coordinates
	  </caption>

	  scrollTo('#my-long-div', 0, 0); // scroll to top
	  scrollTo('#my-long-div', 0, 100); // scroll down
	*/
	export default function scrollTo(target: string | HTMLElement | IDOMElementDescriptor, x: number, y: number): Promise<void>;
	//# sourceMappingURL=scroll-to.d.ts.map
}
declare module '@ember/test-helpers/dom/wait-for-focus' {
	import { type IDOMElementDescriptor } from 'dom-element-descriptors';
	export interface Options {
	    timeout?: number;
	    count?: number | null;
	    timeoutMessage?: string;
	}
	/**
	  Used to wait for a particular selector to receive focus. Useful for verifying
	  keyboard navigation handling and default focus behaviour, without having to
	  think about timing issues.

	  @param {string|IDOMElementDescriptor} target the selector or DOM element descriptor to wait receiving focus
	  @param {Object} [options] the options to be used
	  @param {number} [options.timeout=1000] the time to wait (in ms) for a match
	  @param {string} [options.timeoutMessage='waitForFocus timed out waiting for selector'] the message to use in the reject on timeout
	  @return {Promise<Element>} resolves when the element received focus

	  @example
	  <caption>
	    Waiting until a selector receive focus:
	  </caption>
	  await waitForFocus('.my-selector', { timeout: 2000 })
	*/
	export default function waitForFocus(target: string | IDOMElementDescriptor, options?: Options): Promise<Element>;
	//# sourceMappingURL=wait-for-focus.d.ts.map
}
declare module '@ember/test-helpers' {
	import type { Backburner, DeferredActionQueues } from '@ember/runloop/-private/backburner';
	export { setResolver, getResolver } from 'declarations/resolver.ts';
	export { getApplication, setApplication } from 'declarations/application.ts';
	export { default as hasEmberVersion } from 'declarations/has-ember-version.ts';
	export type { BaseContext, DeprecationFailure, TestContext, Warning, SetupContextOptions, } from 'declarations/setup-context.ts';
	export { default as setupContext, getContext, setContext, unsetContext, pauseTest, resumeTest, getDeprecations, getDeprecationsDuringCallback, getWarnings, getWarningsDuringCallback, } from 'declarations/setup-context.ts';
	export { default as teardownContext } from 'declarations/teardown-context.ts';
	export type { TeardownContextOptions } from 'declarations/teardown-context.ts';
	export { default as setupRenderingContext, render, clearRender, } from 'declarations/setup-rendering-context.ts';
	export type { RenderingTestContext } from 'declarations/setup-rendering-context.ts';
	export { default as rerender } from 'declarations/rerender.ts';
	export { default as setupApplicationContext, visit, currentRouteName, currentURL, } from 'declarations/setup-application-context.ts';
	export { default as settled, isSettled, getSettledState } from 'declarations/settled.ts';
	export { default as waitUntil } from 'declarations/wait-until.ts';
	export { default as validateErrorHandler } from 'declarations/validate-error-handler.ts';
	export { default as setupOnerror, resetOnerror } from 'declarations/setup-onerror.ts';
	export type { default as DebugInfo } from 'declarations/-internal/debug-info.ts';
	export { getDebugInfo } from 'declarations/-internal/debug-info.ts';
	export { default as registerDebugInfoHelper } from 'declarations/-internal/debug-info-helpers.ts';
	export type { TestMetadata } from 'declarations/test-metadata.ts';
	export { default as getTestMetadata } from 'declarations/test-metadata.ts';
	export { registerHook, runHooks, type Hook, type HookLabel, type HookUnregister, } from 'declarations/helper-hooks.ts';
	export { default as click } from 'declarations/dom/click.ts';
	export { default as doubleClick } from 'declarations/dom/double-click.ts';
	export { default as tab } from 'declarations/dom/tab.ts';
	export { default as tap } from 'declarations/dom/tap.ts';
	export { default as focus } from 'declarations/dom/focus.ts';
	export { default as blur } from 'declarations/dom/blur.ts';
	export { default as triggerEvent } from 'declarations/dom/trigger-event.ts';
	export { default as triggerKeyEvent } from 'declarations/dom/trigger-key-event.ts';
	export { default as fillIn } from 'declarations/dom/fill-in.ts';
	export { default as select } from 'declarations/dom/select.ts';
	export { default as waitFor } from 'declarations/dom/wait-for.ts';
	export { default as getRootElement } from 'declarations/dom/get-root-element.ts';
	export { default as find } from 'declarations/dom/find.ts';
	export { default as findAll } from 'declarations/dom/find-all.ts';
	export { default as typeIn } from 'declarations/dom/type-in.ts';
	export { default as scrollTo } from 'declarations/dom/scroll-to.ts';
	export { default as waitForFocus } from 'declarations/dom/wait-for-focus.ts';
	export type { Target } from 'declarations/dom/-target.ts'; module '@ember/runloop' {
	    interface PrivateBackburner extends Backburner {
	        hasTimers(): boolean;
	        currentInstance: DeferredActionQueues | null;
	    }
	}
	//# sourceMappingURL=index.d.ts.map
}
declare module '@ember/test-helpers/-internal/build-registry' {
	import type { Resolver } from '@ember/owner';
	import EmberObject from '@ember/object';
	import { Registry } from '@ember/-internals/container';
	import type { FullName } from '@ember/owner';
	import { ContainerProxyMixin, RegistryProxyMixin } from '@ember/-internals/runtime';
	interface Owner extends RegistryProxyMixin, ContainerProxyMixin {
	} const Owner: Readonly<typeof EmberObject> & (new (owner?: import("@ember/owner").default) => EmberObject) & import("@ember/object/mixin").default & {
	    _emberTestHelpersMockOwner: boolean;
	    /**
	     * Unregister a factory and its instance.
	     *
	     * Overrides `RegistryProxy#unregister` in order to clear any cached instances
	     * of the unregistered factory.
	     *
	     * @param {string} fullName Name of the factory to unregister.
	     *
	     * @see {@link https://github.com/emberjs/ember.js/pull/12680}
	     * @see {@link https://github.com/emberjs/ember.js/blob/v4.5.0-alpha.5/packages/%40ember/engine/instance.ts#L152-L167}
	     */
	    unregister(this: Owner, fullName: FullName): void;
	};
	/**
	 * @private
	 * @param {Object} resolver the resolver to use with the registry
	 * @returns {Object} owner, container, registry
	 */
	export default function buildRegistry(resolver: Resolver): {
	    registry: Registry;
	    container: import("@ember/-internals/container").Container;
	    owner: Owner;
	};
	export {};
	//# sourceMappingURL=build-registry.d.ts.map
}
declare module '@ember/test-helpers/-internal/is-component' {
	import type { ComponentLike } from '@glint/template'; function isComponent(maybeComponent: object): maybeComponent is ComponentLike;
	export default isComponent;
	//# sourceMappingURL=is-component.d.ts.map
}
declare module '@ember/test-helpers/-internal/is-promise' {
	/**
	 *
	 * detect if a value appears to be a promise
	 *
	 * @private
	 * @param {any} [maybePromise] the value being considered to be a promise
	 * @return {boolean} true if the value appears to be a promise, or false otherwise
	 */
	export default function (maybePromise: any): boolean;
	//# sourceMappingURL=is-promise.d.ts.map
}
declare module '@ember/test-helpers/-internal/render-settled' {
	 let renderSettled: () => Promise<void>;
	export default renderSettled;
	//# sourceMappingURL=render-settled.d.ts.map
}
declare module '@ember/test-helpers/dom/-get-description' {
	import type { Target } from '@ember/test-helpers/dom/-target';
	/**
	  Used internally by the DOM interaction helpers to get a description of a
	  target for debug/error messaging.

	  @private
	  @param {Target} target the target
	  @returns {string} a description of the target
	*/
	export default function getDescription(target: Target): string;
	//# sourceMappingURL=-get-description.d.ts.map
}
declare module '@ember/test-helpers/dom/-get-element' {
	import { type Target } from 'declarations/dom/-target.ts';
	import { type IDOMElementDescriptor } from 'dom-element-descriptors'; function getElement<K extends keyof (HTMLElementTagNameMap | SVGElementTagNameMap)>(target: K): (HTMLElementTagNameMap[K] | SVGElementTagNameMap[K]) | null; function getElement<K extends keyof HTMLElementTagNameMap>(target: K): HTMLElementTagNameMap[K] | null; function getElement<K extends keyof SVGElementTagNameMap>(target: K): SVGElementTagNameMap[K] | null; function getElement(target: string): Element | null; function getElement(target: Element): Element; function getElement(target: IDOMElementDescriptor): Element | null; function getElement(target: Document): Document; function getElement(target: Window): Document; function getElement(target: string | IDOMElementDescriptor): Element | null; function getElement(target: Target): Element | Document | null;
	export default getElement;
	//# sourceMappingURL=-get-element.d.ts.map
}
declare module '@ember/test-helpers/dom/-get-elements' {
	import { type IDOMElementDescriptor } from 'dom-element-descriptors'; function getElements(target: string): NodeListOf<Element>; function getElements(target: IDOMElementDescriptor): Iterable<Element>; function getElements(target: string | IDOMElementDescriptor): Iterable<Element>;
	export default getElements;
	//# sourceMappingURL=-get-elements.d.ts.map
}
declare module '@ember/test-helpers/dom/-get-window-or-element' {
	import { type Target } from 'declarations/dom/-target.ts';
	/**
	  Used internally by the DOM interaction helpers to find either window or an element.

	  @private
	  @param {string|Element} target the window, an element or selector to retrieve
	  @returns {Element|Window} the target or selector
	*/
	export function getWindowOrElement(target: Target): Element | Document | Window | null;
	//# sourceMappingURL=-get-window-or-element.d.ts.map
}
declare module '@ember/test-helpers/dom/-is-form-control' {
	export type FormControl = HTMLInputElement | HTMLButtonElement | HTMLSelectElement | HTMLTextAreaElement;
	/**
	  @private
	  @param {Element} element the element to check
	  @returns {boolean} `true` when the element is a form control, `false` otherwise
	*/
	export default function isFormControl(element: Element | Document | Window): element is FormControl;
	//# sourceMappingURL=-is-form-control.d.ts.map
}
declare module '@ember/test-helpers/dom/-guard-for-maxlength' {
	import type { FormControl } from '@ember/test-helpers/dom/-is-form-control';
	/**
	 * @private
	 * @param {Element} element - the element to check
	 * @param {string} text - the text being added to element
	 * @param {string} testHelper - the test helper context the guard is called from (for Error message)
	 * @throws if `element` has `maxlength` & `value` exceeds `maxlength`
	 */
	export default function guardForMaxlength(element: FormControl, text: string, testHelper: string): void;
	//# sourceMappingURL=-guard-for-maxlength.d.ts.map
}
declare module '@ember/test-helpers/dom/-is-focusable' {
	/**
	  @private
	  @param {Element} element the element to check
	  @returns {boolean} `true` when the element is focusable, `false` otherwise
	*/
	export default function isFocusable(element: HTMLElement | SVGElement | Element | Document | Window): element is HTMLElement | SVGElement;
	//# sourceMappingURL=-is-focusable.d.ts.map
}
declare module '@ember/test-helpers/dom/-is-select-element' {
	/**
	  @private
	  @param {Element} element the element to check
	  @returns {boolean} `true` when the element is a select element, `false` otherwise
	*/
	export default function isSelectElement(element: Element | Document): element is HTMLSelectElement;
	//# sourceMappingURL=-is-select-element.d.ts.map
}
declare module '@ember/test-helpers/dom/-logging' {
	import type { Target } from '@ember/test-helpers/dom/-target';
	/**
	 * Logs a debug message to the console if the `testHelperLogging` query
	 * parameter is set.
	 *
	 * @private
	 * @param {string} helperName Name of the helper
	 * @param {string|Element} target The target element or selector
	 */
	export function log(helperName: string, target: Target, ...args: any[]): void;
	/**
	 * This generates a human-readable description to a DOM element.
	 *
	 * @private
	 * @param {*} el The element that should be described
	 * @returns {string} A human-readable description
	 */
	export function elementToString(el: unknown): string;
	//# sourceMappingURL=-logging.d.ts.map
}
declare module '@ember/test-helpers/dom/-to-array' {
	/**
	  @private
	  @param {NodeList} nodelist the nodelist to convert to an array
	  @returns {Array} an array
	*/
	export default function toArray<T extends Node>(nodelist: NodeListOf<T>): T[];
	//# sourceMappingURL=-to-array.d.ts.map
}
