/**
 * @typedef ProsemirrorEditorArgs
 * @property {string} [value] The markdown content to be rendered in the editor
 * @property {string} [placeholder] The placeholder text to be displayed when the editor is empty
 * @property {boolean} [disabled] Whether the editor should be disabled
 * @property {Record<string, () => void>} [keymap] A mapping of keybindings to commands
 * @property {(value: { target: { value: string } }) => void} [change] A callback called when the editor content changes
 * @property {() => void} [focusIn] A callback called when the editor gains focus
 * @property {() => void} [focusOut] A callback called when the editor loses focus
 * @property {(textManipulation: TextManipulation) => undefined | (() => void)} [onSetup] A callback called when the editor is set up, may return a destructor
 * @property {number} [topicId] The ID of the topic being edited, if any
 * @property {number} [categoryId] The ID of the category of the topic being edited, if any
 * @property {string} [class] The class to be added to the ProseMirror contentEditable editor
 * @property {boolean} [includeDefault] If default node and mark spec/parse/serialize/inputRules definitions from ProseMirror should be included
 * @property {import("discourse/lib/composer/rich-editor-extensions").RichEditorExtension[]} [extensions] A list of extensions to be used with the editor INSTEAD of the ones registered through the API
 * @property {(toolbar: import("discourse/lib/composer/toolbar").ToolbarBase) => void} [replaceToolbar] A function that replaces the default toolbar in a container with a custom/temporary one
 * @property {() => void} [toggleRichEditor] A callback to toggle the rich editor on and off if in such a context
 */
/**
 * @typedef ProsemirrorEditorSignature
 * @property {ProsemirrorEditorArgs} Args
 */
/** @typedef {import("../lib/glimmer-node-view").default} GlimmerNodeView */
/**
 * @extends {Component<ProsemirrorEditorSignature>}
 */
export default class ProsemirrorEditor extends Component<ProsemirrorEditorSignature> {
    constructor(owner: import("@ember/owner").default, args: ProsemirrorEditorArgs);
    session: any;
    dialog: any;
    menu: any;
    capabilities: any;
    modal: any;
    toasts: any;
    site: any;
    siteSettings: any;
    appEvents: any;
    currentUser: any;
    schema: ProsemirrorModel.Schema<any, any>;
    view: any;
    /** @type {TrackedArray<GlimmerNodeView>} */
    glimmerNodeViews: TrackedArray<GlimmerNodeView>;
    /** @type {import("discourse/lib/composer/rich-editor-extensions").PluginParams} */
    get pluginParams(): import("discourse/lib/composer/rich-editor-extensions").PluginParams;
    get extensions(): import("discourse/lib/composer/rich-editor-extensions").RichEditorExtension[];
    get keymapFromArgs(): {};
    handleAsyncPlugin(plugin: any): void;
    setup(container: any): void;
    parser: Parser;
    serializer: Serializer;
    textManipulation: TextManipulation;
    convertFromMarkdown(markdown: any): ProsemirrorModel.Node;
    convertFromValue(): void;
    convertToMarkdown(doc: any): any;
    teardown(): void;
    updateContext(element: any, [key, value]: [any, any]): void;
    #private;
}
export type ProsemirrorEditorArgs = {
    /**
     * The markdown content to be rendered in the editor
     */
    value?: string;
    /**
     * The placeholder text to be displayed when the editor is empty
     */
    placeholder?: string;
    /**
     * Whether the editor should be disabled
     */
    disabled?: boolean;
    /**
     * A mapping of keybindings to commands
     */
    keymap?: Record<string, () => void>;
    /**
     * A callback called when the editor content changes
     */
    change?: (value: {
        target: {
            value: string;
        };
    }) => void;
    /**
     * A callback called when the editor gains focus
     */
    focusIn?: () => void;
    /**
     * A callback called when the editor loses focus
     */
    focusOut?: () => void;
    /**
     * A callback called when the editor is set up, may return a destructor
     */
    onSetup?: (textManipulation: TextManipulation) => undefined | (() => void);
    /**
     * The ID of the topic being edited, if any
     */
    topicId?: number;
    /**
     * The ID of the category of the topic being edited, if any
     */
    categoryId?: number;
    /**
     * The class to be added to the ProseMirror contentEditable editor
     */
    class?: string;
    /**
     * If default node and mark spec/parse/serialize/inputRules definitions from ProseMirror should be included
     */
    includeDefault?: boolean;
    /**
     * A list of extensions to be used with the editor INSTEAD of the ones registered through the API
     */
    extensions?: import("discourse/lib/composer/rich-editor-extensions").RichEditorExtension[];
    /**
     * A function that replaces the default toolbar in a container with a custom/temporary one
     */
    replaceToolbar?: (toolbar: import("discourse/lib/composer/toolbar").ToolbarBase) => void;
    /**
     * A callback to toggle the rich editor on and off if in such a context
     */
    toggleRichEditor?: () => void;
};
export type ProsemirrorEditorSignature = {
    Args: ProsemirrorEditorArgs;
};
export type GlimmerNodeView = import("../lib/glimmer-node-view").default;
import Component from "@glimmer/component";
import * as ProsemirrorModel from "prosemirror-model";
import { TrackedArray } from "@ember-compat/tracked-built-ins";
import Parser from "../core/parser";
import Serializer from "../core/serializer";
import TextManipulation from "../lib/text-manipulation";
//# sourceMappingURL=prosemirror-editor.d.ts.map