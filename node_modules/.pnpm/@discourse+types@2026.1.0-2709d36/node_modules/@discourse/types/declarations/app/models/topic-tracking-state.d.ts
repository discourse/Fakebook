export function startTracking(tracking: any): void;
export default class TopicTrackingState extends EmberObject {
    currentUser: any;
    messageBus: any;
    siteSettings: any;
    messageCount: number;
    incomingCount: number;
    newIncoming: any;
    filterCategory: any;
    filterTag: any;
    filter: any;
    states: TrackedMap<unknown, unknown>;
    stateChangeCallbacks: {};
    _trackedTopicLimit: number;
    willDestroy(...args: any[]): void;
    /**
     * Subscribe to MessageBus channels which are used for publishing changes
     * to the tracking state. Each message received will modify state for
     * a particular topic.
     *
     * See app/models/topic_tracking_state.rb for the data payloads published
     * to each of the channels.
     *
     * @method establishChannels
     */
    establishChannels(meta: any): void;
    onDeleteMessage(msg: any): void;
    onRecoverMessage(msg: any): void;
    onDestroyMessage(msg: any): void;
    get mutedTopics(): any;
    get unmutedTopics(): any;
    trackMutedOrUnmutedTopic(data: any): void;
    pruneOldMutedAndUnmutedTopics(): void;
    isMutedTopic(topicId: any): boolean;
    isUnmutedTopic(topicId: any): boolean;
    /**
     * Updates the topic's last_read_post_number to the highestSeen post
     * number, as long as the topic is being tracked.
     *
     * Calls onStateChange callbacks.
     *
     * @params {Number|String} topicId - The ID of the topic to set last_read_post_number for.
     * @params {Number} highestSeen - The post number of the topic that should be
     *                                used for last_read_post_number.
     * @method updateSeen
     */
    updateSeen(topicId: any, highestSeen: any): void;
    /**
     * Used to count incoming topics which will be displayed in a message
     * at the top of the topic list, if hasIncoming is true (which is if
     * incomingCount > 0).
     *
     * This will do nothing unless resetTracking or trackIncoming has been
     * called; newIncoming will be null instead of an array. trackIncoming
     * is called by various topic routes, as is resetTracking.
     *
     * @method notifyIncoming
     * @param {Object} data - The data sent by TopicTrackingState to MessageBus
     *                        which includes the message_type, payload of the topic,
     *                        and the topic_id.
     */
    notifyIncoming(data: any): void;
    /**
     * Resets the number of incoming topics to 0 and flushes the new topics
     * from the array. Without calling this or trackIncoming the notifyIncoming
     * method will do nothing.
     *
     * @method resetTracking
     */
    resetTracking(): void;
    /**
     * Removes the given topic IDs from the list of incoming topics.
     *
     * @method clearIncoming
     */
    clearIncoming(topicIds: any): void;
    /**
     * Track how many new topics came for the specified filter.
     *
     * Related/intertwined with notifyIncoming; the filter and filterCategory
     * set here is used to determine whether or not to add incoming counts
     * based on message types of incoming MessageBus messages (via establishChannels)
     *
     * @method trackIncoming
     * @param {String} filter - Valid values are all, categories, and any topic list
     *                          filters e.g. latest, unread, new. As well as this
     *                          specific category and tag URLs like tag/test/l/latest,
     *                          c/cat/sub-cat/6/l/latest or tags/c/cat/sub-cat/6/test/l/latest.
     */
    trackIncoming(filter: string): void;
    /**
     * Used to determine whether to show the message at the top of the topic list
     * e.g. "see 1 new or updated topic"
     *
     * @method hasIncoming
     */
    get hasIncoming(): boolean;
    /**
     * Removes the topic ID provided from the tracker state.
     *
     * Calls onStateChange callbacks.
     *
     * @param {Number|String} topicId - The ID of the topic to remove from state.
     * @method removeTopic
     */
    removeTopic(topicId: number | string): void;
    /**
     * Removes multiple topics from the state at once, and increments
     * the message count.
     *
     * Calls onStateChange callbacks.
     *
     * @param {Array} topicIds - The IDs of the topic to removes from state.
     * @method removeTopics
     */
    removeTopics(topicIds: any[]): void;
    /**
     * If we have a cached topic list, we can update it from our tracking information
     * if the last_read_post_number or is_seen property does not match what the
     * cached topic has.
     *
     * @method updateTopics
     * @param {Array} topics - An array of Topic models.
     */
    updateTopics(topics: any[]): void;
    /**
     * Uses the provided topic list to apply changes to the in-memory topic
     * tracking state, remove state as required, and also compensate for missing
     * in-memory state.
     *
     * Any state changes will make a callback to all state change callbacks defined
     * via onStateChange.
     *
     * @method sync
     * @param {TopicList} list
     * @param {String} filter - The filter used for the list e.g. new/unread
     * @param {Object} queryParams - The query parameters for the list e.g. page
     */
    sync(list: TopicList, filter: string, queryParams: any): void;
    _generateCallbackId(): string;
    onStateChange(cb: any): string;
    offStateChange(callbackId: any): void;
    getSubCategoryIds(categoryId: any): any[] | Set<any>;
    countCategoryByState({ type, categoryId, tagId, noSubcategories, customFilterFn, }: {
        type: any;
        categoryId: any;
        tagId: any;
        noSubcategories: any;
        customFilterFn: any;
    }): number;
    countNew({ categoryId, tagId, noSubcategories, customFilterFn }?: {}): number;
    countUnread({ categoryId, tagId, noSubcategories, customFilterFn }?: {}): number;
    countNewAndUnread({ categoryId, tagId, noSubcategories, customFilterFn, }?: {}): number;
    /**
     * Calls the provided callback for each of the currently tracked topics
     * we have in state.
     *
     * @method forEachTracked
     * @param {Function} fn - The callback function to call with the topic,
     *                        newTopic which is a boolean result of isNew,
     *                        and unreadTopic which is a boolean result of
     *                        isUnread.
     */
    forEachTracked(fn: Function, opts?: {}): void;
    countCategory(category_id: any, tagId: any): number;
    lookupCount({ type, category, tagId, noSubcategories, customFilterFn }?: {}): any;
    loadStates(data: any): void;
    _setState({ topic, data, skipAfterStateChange }: {
        topic: any;
        data: any;
        skipAfterStateChange: any;
    }): boolean;
    modifyState(topic: any, data: any): void;
    modifyStateProp(topic: any, prop: any, data: any): void;
    findState(topicOrId: any): unknown;
    _fixDelayedServerState(list: any, filter: any): void;
    _newStateFromListTopic(topic: any): any;
    _shouldCompensateState(list: any, filter: any, queryParams: any): boolean;
    _correctMissingState(list: any, filter: any): void;
    _processChannelPayload(data: any): void;
    _dismissNewTopics(topicIds: any): void;
    _dismissNewPosts(topicIds: any): void;
    _addIncoming(topicId: any): void;
    _trackedTopics(opts?: {}): {
        topic: unknown;
        newTopic: boolean;
        unreadTopic: boolean;
    }[];
    _stateKey(topicOrId: any): string;
    _afterStateChange(): void;
    _maxStateSizeReached(): boolean;
}
import EmberObject from "@ember/object";
import { TrackedMap } from "@ember-compat/tracked-built-ins";
//# sourceMappingURL=topic-tracking-state.d.ts.map