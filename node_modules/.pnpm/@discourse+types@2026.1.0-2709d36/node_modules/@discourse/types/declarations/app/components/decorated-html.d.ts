/**
 * Registers a new HTML decorator function for a specific type of decoration.
 *
 * @param {Function} decorator - The decorator function to register. It receives two parameters:
 *                              1. element: HTMLElement to be decorated
 *                              2. options: Object containing decoration options
 *                              The decorator can optionally return a cleanup function.
 * @param {Symbol|string} [type=NON_STREAM_HTML_DECORATOR] - The type of decorator to register.
 *                                                       When not provided, defaults to NON_STREAM_HTML_DECORATOR (non-stream).
 * @returns {void}
 * @example
 * registerHtmlDecorator((element, options) => {
 *   element.classList.add('decorated');
 *   return () => element.classList.remove('decorated'); // Cleanup function
 * });
 */
export function registerHtmlDecorator(decorator: Function, type?: Symbol | string): void;
/**
 * Applies registered HTML decorators to a DOM element and returns their cleanup functions.
 *
 * @param {HTMLElement} element - The DOM element to apply decorators to
 * @param {Object} helper - Helper object passed to each decorator. Use NULL_HELPER for contexts without a model.
 * @param {Symbol|string} [type=NON_STREAM_HTML_DECORATOR] - The type of decorators to apply.
 * @returns {Function[]} Array of cleanup functions from decorators that returned them.
 */
export function applyHtmlDecorators(element: HTMLElement, helper: any, type?: Symbol | string): Function[];
/**
 * Clears all registered HTML decorators
 *
 * USE ONLY FOR TESTING PURPOSES
 *
 * @returns {void}
 */
export function resetHtmlDecorators(): void;
/** @type {Symbol} Default decorator type used when no specific type is provided */
export const NON_STREAM_HTML_DECORATOR: Symbol;
/** Helper object for contexts without a post/model. Use with `applyHtmlDecorators`. */
export const NULL_HELPER: Readonly<{
    getModel: () => any;
    readonly model: any;
    readonly context: any;
}>;
/**
 * Reactively renders cooked HTML with decorations applied.
 *
 * When no custom `@decorate` function is provided, registered HTML decorators
 * (via `api.decorateCookedElement`) are automatically applied. This handles
 * common cases like hashtag icons, mentions, and other cooked content decorations.
 *
 * @component DecoratedHtml
 * @param {SafeString} html - The HTML content to render (must be wrapped with htmlSafe)
 * @param {Function} [decorate] - Custom decorator function receiving (element, helper, decorateArgs).
 *                                When provided, you're responsible for calling applyHtmlDecorators if needed.
 * @param {Object} [decorateArgs] - Additional arguments passed to the decorate function
 * @param {Object} [model] - Model object (e.g., post) passed to decorators via helper.model
 * @param {Object} [context] - Context object passed to decorators via helper.context
 * @param {string} [className] - CSS class name for the wrapper div
 * @param {string} [id] - ID attribute for the wrapper div
 */
export default class DecoratedHtml extends Component<any> {
    constructor(owner: import("@ember/-internals/owner").default, args: any);
    renderGlimmerInfos: TrackedArray<unknown>;
    decoratedContent: typeof import("@ember/component/helper").default;
    get elementToDecorate(): HTMLDivElement;
    /**
     * Checks if a given HTML element belongs to the current document.
     * In development mode, it warns if the element is not in the document.
     *
     * This is used to ensure components added using `renderGlimmer` are only rendered in the same document, preventing
     * rendering errors that otherwise would crash the application.
     *
     * @param {Object} info - Object containing element information
     * @param {Element} info.element - The DOM element to check
     * @returns {boolean} True if element belongs to current document, false otherwise
     */
    isElementInDocument(info: {
        element: Element;
    }): boolean;
}
import Component from "@glimmer/component";
import { TrackedArray } from "@ember-compat/tracked-built-ins";
//# sourceMappingURL=decorated-html.d.ts.map