/**
 * Registers an extension for the rich editor
 *
 * EXPERIMENTAL: This API will change without warning
 *
 * @param {RichEditorExtension} extension
 */
export function registerRichEditorExtension(extension: RichEditorExtension): void;
export function clearRichEditorExtensions(): void;
export function resetRichEditorExtensions(): Promise<void>;
/**
 * Get all extensions registered for the rich editor
 *
 * @returns {RichEditorExtension[]}
 */
export function getExtensions(): RichEditorExtension[];
export type PluginContext = {
    placeholder: string;
    topicId: number;
    categoryId: number;
    session: import("discourse/models/session").default;
    menu: import("discourse/float-kit/services/menu").default;
    capabilities: import("discourse/services/capabilities").default;
    modal: import("discourse/services/modal").default;
    toasts: import("discourse/float-kit/services/toasts").default;
    site: import("discourse/models/site").default;
    replaceToolbar: (toolbar: import("discourse/lib/composer/toolbar").ToolbarBase) => void;
    addGlimmerNodeView: (nodeView: import("discourse/static/prosemirror/lib/glimmer-node-view").default) => void;
    removeGlimmerNodeView: (nodeView: import("discourse/static/prosemirror/lib/glimmer-node-view").default) => void;
};
export type EditorInstanceUtils = {
    convertFromMarkdown: (markdown: string) => import("prosemirror-model").Node;
    convertToMarkdown: (doc: import("prosemirror-model").Node) => string;
    toggleRichEditor: () => void;
};
export type PluginParams = {
    utils: typeof import("discourse/static/prosemirror/lib/plugin-utils") & EditorInstanceUtils;
    pmModel: typeof import("prosemirror-model");
    pmView: typeof import("prosemirror-view");
    pmState: typeof import("prosemirror-state");
    pmHistory: typeof import("prosemirror-history");
    pmTransform: typeof import("prosemirror-transform");
    pmCommands: typeof import("prosemirror-commands");
    schema: import("prosemirror-model").Schema;
    getContext: () => PluginContext;
};
export type PluginSpec = import("prosemirror-state").PluginSpec<any>;
export type RichPluginFn = ((params: PluginParams) => PluginSpec);
export type RichPlugin = PluginSpec | RichPluginFn;
export type InputRuleObject = {
    match: RegExp;
    handler: ((state: import("prosemirror-state").EditorState, match: RegExpMatchArray, start: number, end: number) => import("prosemirror-state").Transaction | null);
    options?: {
        undoable?: boolean;
        inCode?: boolean | "only";
    };
};
export type InputRuleParams = {
    schema: import("prosemirror-model").Schema;
    markInputRule: Function;
};
export type RichInputRule = ((params: InputRuleParams) => InputRuleObject) | InputRuleObject;
export type StateFunction = (params: PluginParams, state: import("prosemirror-state").EditorState) => Record<string, unknown>;
export type PluginsFunction = (params: PluginParams) => import("prosemirror-state").PluginSpec<any> | import("prosemirror-state").PluginSpec<any>;
export type PluginsProperty = PluginsFunction | import("prosemirror-state").PluginSpec<any>;
export type MarkdownItToken = any;
export type ParseFunction = (state: unknown, token: MarkdownItToken, tokenStream: MarkdownItToken[], index: number) => boolean | void;
export type RichParseSpec = import("prosemirror-markdown").ParseSpec | ParseFunction;
/**
 * NodeView constructor signature - can be a class or constructor function
 */
export type NodeViewConstructor = new (node: import("prosemirror-model").Node, view: import("prosemirror-view").EditorView, getPos: (() => number) | boolean) => any;
/**
 * Extended MarkdownSerializerState with additional properties used by Discourse
 */
export type ExtendedMarkdownSerializerState = {
    /**
     * - The output string being built
     */
    out: string;
    /**
     * - Current delimiter for block formatting
     */
    delim: string;
    /**
     * - Whether currently serializing inside a table (Discourse-specific)
     */
    inTable?: boolean;
    /**
     * - Flush closed blocks with optional size
     */
    flushClose: (size?: number) => void;
    /**
     * - Check if output is currently at a blank line
     */
    atBlank: () => boolean;
};
export type DiscourseMarkdownSerializerState = import("prosemirror-markdown").MarkdownSerializerState & ExtendedMarkdownSerializerState;
export type SerializeNodeFn = (state: DiscourseMarkdownSerializerState, node: import("prosemirror-model").Node, parent: import("prosemirror-model").Node, index: number) => void;
export type KeymapSpec = Record<string, import("prosemirror-state").Command>;
export type RichKeymapFn = ((params: PluginParams) => KeymapSpec);
export type RichKeymap = KeymapSpec | RichKeymapFn;
export type MarkSerializerSpec = import("prosemirror-markdown").MarkSerializerSpec;
export type RichEditorExtension = {
    /**
     * Map containing Prosemirror node spec definitions, each key being the node name
     * See https://prosemirror.net/docs/ref/#model.NodeSpec
     */
    nodeSpec?: Record<string, import("prosemirror-model").NodeSpec>;
    /**
     * Map containing Prosemirror mark spec definitions, each key being the mark name
     * See https://prosemirror.net/docs/ref/#model.MarkSpec
     */
    markSpec?: Record<string, import("prosemirror-model").MarkSpec>;
    /**
     * ProseMirror input rules. See https://prosemirror.net/docs/ref/#inputrules.InputRule
     * can be a single rule, array of rules, or function returning rule(s)
     */
    inputRules?: InputRuleObject | InputRuleObject[] | ((params: PluginParams) => InputRuleObject | InputRuleObject[] | import("prosemirror-inputrules").InputRule | import("prosemirror-inputrules").InputRule[]);
    /**
     * Node serialization definition - can be a function returning an object with node serializers, or a direct object
     */
    serializeNode?: ((params: PluginParams) => Record<string, SerializeNodeFn>) | Record<string, SerializeNodeFn>;
    /**
     * Mark serialization definition - can be a function returning an object with mark serializers, or a direct object
     */
    serializeMark?: ((params: PluginParams) => Record<string, MarkSerializerSpec>) | Record<string, MarkSerializerSpec>;
    /**
     * Markdown-it token parse definition
     */
    parse?: Record<string, RichParseSpec>;
    /**
     * ProseMirror plugins - can be a function returning plugin spec or plugin spec object
     */
    plugins?: PluginsProperty;
    /**
     * ProseMirror node views. Can be a NodeViewConstructor or an object with { component, name } for automatic Glimmer component wrapping
     */
    nodeViews?: Record<string, NodeViewConstructor | ((params: PluginParams) => NodeViewConstructor) | {
        component: any;
        name?: string;
    }>;
    /**
     * Additional keymap definitions
     */
    keymap?: RichKeymap;
    /**
     * Command definitions that will be available on view.state.commands
     */
    commands?: (params: PluginParams) => Record<string, import("prosemirror-state").Command>;
    /**
     * State function that computes editor state data
     */
    state?: StateFunction;
};
//# sourceMappingURL=rich-editor-extensions.d.ts.map