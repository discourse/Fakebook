export function Placeholder(viewName: any): void;
export class Placeholder {
    constructor(viewName: any);
    viewName: any;
}
export function setLastEditNotificationClick(topicId: any, postNumber: any, revisionNumber: any): void;
export function resetLastEditNotificationClick(): void;
export default class PostStream extends RestModel {
    static PLACEHOLDER: Placeholder;
    currentUser: any;
    store: any;
    appendingPlaceholders: number;
    filter: any;
    filterRepliesToPostNumber: number | boolean;
    filterUpwardsPostID: boolean;
    gaps: any;
    isMegaTopic: any;
    lastId: any;
    lastAppended: any;
    loaded: boolean;
    loadingAbove: boolean;
    loadingBelow: boolean;
    loadingFilter: boolean;
    loadingLastPost: boolean;
    loadingNearPost: any;
    stagingPost: boolean;
    timelineLookup: any[];
    posts: any[];
    stream: any[];
    userFilters: any[];
    _identityMap: {};
    get loading(): boolean;
    get notLoading(): boolean;
    get firstPostNotLoaded(): boolean;
    get lastPostNotLoaded(): boolean;
    get canAppendMore(): boolean;
    get canPrependMore(): boolean;
    get summary(): boolean;
    get postsWithPlaceholders(): any[];
    get filteredPostsCount(): any;
    get hasPosts(): boolean;
    get hasLoadedData(): boolean;
    get firstPostPresent(): boolean;
    get firstPostId(): any;
    get lastPostId(): any;
    get loadedAllPosts(): boolean;
    /**
      Returns a JS Object of current stream filter options. It should match the query
      params for the stream.
    **/
    get streamFilters(): Record<PropertyKey, unknown>;
    get hasNoFilters(): boolean;
    /**
      Returns the window of posts above the current set in the stream, bound to the top of the stream.
      This is the collection we'll ask for when scrolling upwards.
    **/
    get previousWindow(): any[];
    /**
      Returns the window of posts below the current set in the stream, bound by the bottom of the
      stream. This is the collection we use when scrolling downwards.
    **/
    get nextWindow(): any[];
    cancelFilter(): void;
    refreshAndJumpToSecondVisible(): import("rsvp").default.Promise<void>;
    showTopReplies(): import("rsvp").default.Promise<void>;
    filterParticipant(username: any): import("rsvp").default.Promise<void>;
    filterReplies(postNumber: any, postId: any): import("rsvp").default.Promise<void>;
    filterUpwards(postId: any): import("rsvp").default.Promise<void>;
    /**
      Loads a new set of posts into the stream. If you provide a `nearPost` option and the post
      is already loaded, it will simply scroll there and load nothing.
    **/
    refresh(opts: any): import("rsvp").default.Promise<void>;
    fillGapBefore(post: any, gap: any): globalThis.Promise<void>;
    fillGapAfter(post: any, gap: any): globalThis.Promise<void>;
    gapExpanded(): void;
    appendMore(): globalThis.Promise<any>;
    prependMore(): globalThis.Promise<void>;
    /**
      Stage a post for insertion in the stream. It should be rendered right away under the
      assumption that the post will succeed. We can then `commitPost` when it succeeds or
      `undoPost` when it fails.
    **/
    stagePost(post: any, user: any): "alreadyStaging" | "staged" | "offScreen";
    commitPost(post: any): void;
    /**
      Undo a post we've staged in the stream. Remove it from being rendered and revert the
      state we changed.
    **/
    undoPost(post: any): void;
    prependPost(post: any): any;
    appendPost(post: any): any;
    removePosts(posts: any): void;
    removeAllPosts(): void;
    findLoadedPost(id: any): any;
    loadPostByPostNumber(postNumber: any): globalThis.Promise<any>;
    loadNearestPostToDate(date: any): globalThis.Promise<any>;
    loadPost(postId: any): globalThis.Promise<any>;
    triggerNewPostInStream(postId: any, opts: any): globalThis.Promise<void>;
    /**
      Finds and adds posts to the stream by id. Typically this would happen if we receive a message
      from the message bus indicating there's a new post. We'll only insert it if we currently
      have no filters.
    **/
    triggerNewPostsInStream(postIds: any, opts: any): globalThis.Promise<void>;
    _loadingPostIds: any;
    triggerRecoveredPost(postId: any): globalThis.Promise<any>;
    triggerDeletedPost(postId: any): import("rsvp").default.Promise<any> | globalThis.Promise<void>;
    triggerDestroyedPost(postId: any): import("rsvp").default.Promise<any>;
    /**
     * Updates a post in the stream when it has been changed on the server.
     *
     * @param {number} postId - The ID of the post to update
     * @param {string} updatedAt - The timestamp when the post was last updated
     * @param {Object} opts - Additional options for updating the post
     * @param {boolean} [opts.preserveCooked] - Whether to preserve the cooked HTML content
     * @returns {Promise} A promise that resolves when the post has been updated
     */
    triggerChangedPost(postId: number, updatedAt: string, opts?: {
        preserveCooked?: boolean;
    }): Promise<any>;
    triggerLikedPost(postId: any, likesCount: any, userID: any, eventType: any): import("rsvp").default.Promise<any>;
    triggerReadPost(postId: any, readersCount: any): import("rsvp").default.Promise<any>;
    triggerChangedTopicStats(): import("rsvp").default.Promise<any>;
    postForPostNumber(postNumber: any): any;
    /**
      Returns the closest post given a postNumber that may not exist in the stream.
      For example, if the user asks for a post that's deleted or otherwise outside the range.
      This allows us to set the progress bar with the correct number.
    **/
    closestPostForPostNumber(postNumber: any): any;
    progressIndexOfPost(post: any): any;
    progressIndexOfPostId(post: any): any;
    /**
      Returns the closest post number given a postNumber that may not exist in the stream.
      For example, if the user asks for a post that's deleted or otherwise outside the range.
      This allows us to set the progress bar with the correct number.
    **/
    closestPostNumberFor(postNumber: any): any;
    closestDaysAgoFor(postNumber: any): any;
    findPostIdForPostNumber(postNumber: any): any;
    updateFromJson(postStreamData: any): void;
    /**
      Stores a post in our identity map, and sets up the references it needs to
      find associated objects like the topic. It might return a different reference
      than you supplied if the post has already been loaded.
    **/
    storePost(post: any): any;
    fetchNextWindow(postNumber: any, asc: any, callback: any): globalThis.Promise<void>;
    findPostsByIds(postIds: any, opts: any): globalThis.Promise<any>;
    loadIntoIdentityMap(postIds: any, opts: any): globalThis.Promise<any[]>;
    backfillExcerpts(streamPosition: any): any;
    excerpt(streamPosition: any): import("rsvp").default.Promise<any>;
    indexOf(post: any): number;
    errorLoading(error: any): void;
    _initUserModels(post: any): void;
    _checkIfShouldShowRevisions(): void;
    _setSuggestedTopics(result: any): void;
}
import RestModel from "discourse/models/rest";
import { Promise } from "rsvp";
//# sourceMappingURL=post-stream.d.ts.map