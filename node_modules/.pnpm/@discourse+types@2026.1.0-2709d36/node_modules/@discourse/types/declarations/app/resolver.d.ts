export function setResolverOption(name: any, value: any): void;
export function getResolverOption(name: any): any;
export function clearResolverOptions(): void;
export function expireModuleTrieCache(): void;
export function buildResolver(baseName: any): {
    new (): {
        resolveRouter(): any;
        _normalize(fullName: any): any;
        findModuleName(parsedName: any): any;
        resolveHelper(parsedName: any): any;
        resolveRoute(parsedName: any): any;
        resolveTemplate(parsedName: any): any;
        findLoadingTemplate(parsedName: any): any;
        findConnectorTemplate(parsedName: any): any;
        /**
         * Given a template path, this function will return a template, taking into account
         * priority rules for theme and plugin overrides. See `lib/discourse-template-map.js`
         */
        discourseTemplateModule(name: any): any;
        findTemplate(parsedName: any, prefix: any): any;
        findAdminTemplate(parsedName: any): any;
        /**
         * Builds a list of template path candidates based on various naming conventions.
         * Supports legacy naming patterns (underscored, dasherized, etc.) for backwards compatibility.
         *
         * @param {Object} parsedName - The parsed template name object
         * @param {string} [prefix=""] - Optional prefix to prepend to all candidate paths
         * @return {Object} Object with 'original' path and array of 'candidates' to try
         */
        "__#private@#buildTemplateCandidates"(parsedName: any, prefix?: string): any;
        /**
         * Identifies the source (core, plugin, or theme) of a template by its parsed name.
         *
         * @param {Object} parsedName - The parsed template name object
         * @param {string} [prefix] - Optional prefix to prepend to the template path
         * @return {Object|undefined} Source information containing type and name, or undefined if not found
         */
        "__#private@#findTemplateSource"(parsedName: any, prefix?: string): any | undefined;
        pluralizedTypes: Record<string, string>;
        addModules(modules: Record<string, unknown>): void;
        resolve: (name: string) => import("@ember/-internals/owner").Factory<object> | object | undefined;
        knownForType: <Type extends string>(type: Type) => import("@ember/-internals/owner").KnownForTypeResult<Type>;
        lookupDescription: (fullName: import("@ember/-internals/owner").FullName) => string;
        makeToString: (factory: import("@ember/-internals/owner").Factory<object>, fullName: import("@ember/-internals/owner").FullName) => string;
        normalize: (fullName: import("@ember/-internals/owner").FullName) => import("@ember/-internals/owner").FullName;
    };
    create<T extends typeof Resolver>(this: T, props: Record<string, unknown>): InstanceType<T>;
    withModules<T extends typeof Resolver>(this: T, modules: Record<string, unknown>): T;
};
import Resolver from "ember-resolver";
//# sourceMappingURL=resolver.d.ts.map