/** @implements {TextManipulation} */
export default class TextareaTextManipulation implements TextManipulation {
    constructor(owner: any, { markdownOptions, textarea, eventPrefix }: {
        markdownOptions: any;
        textarea: any;
        eventPrefix?: string;
    });
    appEvents: any;
    siteSettings: any;
    capabilities: any;
    allowPreview: boolean;
    eventPrefix: string;
    textarea: any;
    $textarea: JQuery<any>;
    autocompleteHandler: TextareaAutocompleteHandler;
    placeholder: TextareaPlaceholderHandler;
    /** @type {import("discourse/lib/composer/text-manipulation").ToolbarState} */
    state: import("discourse/lib/composer/text-manipulation").ToolbarState;
    _cachedLinkify: any;
    get value(): any;
    blurAndFocus(): void;
    focus(): void;
    insertBlock(text: any): void;
    insertText(text: any, options: any): void;
    getSelected(trimLeading: any, opts: any): {
        start: any;
        end: any;
        value: any;
        pre: any;
        post: any;
        lineVal: any;
    } | {
        start: any;
        end: any;
        value: any;
        pre: any;
        post: any;
        lineVal?: undefined;
    };
    selectText(from: any, length: any, opts?: {
        scroll: boolean;
    }): void;
    replaceText(oldVal: any, newVal: any, opts?: {}): void;
    applySurroundSelection(head: any, tail: any, exampleKey: any, opts: any): void;
    applySurround(sel: any, head: any, tail: any, exampleKey: any, opts: any): void;
    _getMultilineContents(lines: any, head: any, hval: any, hlen: any, tail: any, tlen: any, opts: any): any;
    _addBlock(sel: any, text: any): void;
    addText(sel: any, text: any, options: any): void;
    _insertAt(start: any, end: any, text: any): void;
    extractTable(text: any): string;
    isInside(text: any, regex: any): number;
    paste(e: any): void;
    /**
     * Removes the provided char from the provided str up
     * until the limit, or until a character that is _not_
     * the provided one is encountered.
     */
    _deindentLine(str: any, char: any, limit: any): any;
    _updateListNumbers(text: any, currentNumber: any): any;
    maybeContinueList(): void;
    indentSelection(direction: any): boolean;
    emojiSelected(code: any): void;
    inCodeBlock(): Promise<boolean>;
    toggleDirection(): void;
    applyList(sel: any, head: any, exampleKey: any, opts: any): void;
    applyHeading(sel: any, level: any): void;
    formatCode(): void;
    putCursorAtEnd(): void;
    /**
     * Wraps consecutive upload placeholders in grid tags.
     * @param {string[]} consecutiveImages - Array of consecutive image filenames to wrap
     */
    autoGridImages(consecutiveImages: string[]): void;
    autocomplete(options: any): DAutocompleteModifier;
    #private;
}
/** @implements {AutocompleteHandler} */
export class TextareaAutocompleteHandler implements AutocompleteHandler {
    constructor(textarea: any);
    textarea: any;
    $textarea: JQuery<any>;
    getValue(): any;
    replaceTerm(start: any, end: any, term: any): void;
    getCaretPosition(): any;
    getCaretCoords(start: any): any;
    inCodeBlock(): Promise<boolean>;
}
export type TextManipulation = any;
export type AutocompleteHandler = any;
export type PlaceholderHandler = any;
/** @implements {PlaceholderHandler} */
declare class TextareaPlaceholderHandler implements PlaceholderHandler {
    constructor(owner: any, textManipulation: any);
    composer: any;
    /** @type {TextareaTextManipulation} */
    textManipulation: TextareaTextManipulation;
    insert(file: any): void;
    progress(file: any): void;
    progressComplete(file: any): void;
    cancelAll(): void;
    cancel(file: any): void;
    success(file: any, markdown: any): void;
    #private;
}
import DAutocompleteModifier from "discourse/modifiers/d-autocomplete";
export {};
//# sourceMappingURL=textarea-text-manipulation.d.ts.map