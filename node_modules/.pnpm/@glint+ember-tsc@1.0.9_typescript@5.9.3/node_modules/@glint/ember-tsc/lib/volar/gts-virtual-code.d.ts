import { CodeMapping, VirtualCode } from '@volar/language-core';
import type ts from 'typescript';
import { IScriptSnapshot } from 'typescript';
import { GlintConfig } from '../index.js';
import { Directive, rewriteModule } from '../transform/index.js';
export type TS = typeof ts;
interface EmbeddedCodeWithDirectives extends VirtualCode {
    directives: readonly Directive[];
}
/**
 * A Volar VirtualCode representing .gts/.gjs files, which includes 0+ embedded
 * Handlebars templates within <template> tags.
 *
 * ## Virtual Code Overview (and how we use it)
 *
 * VirtualCodes are one of the most core/central primitives provided by Volar.
 * They are:
 *
 * - Used both in (classic) Language Server mode and in newer TS Plugin mode
 * - Responsible for parsing and transforming source code of a particular language (e.g. GTS)
 *   into embedded codes (e.g. a valid type-checkable TS file wherein all `<template>` tags
 *   have been replaced with valid TS code)
 *
 * ## Embedded Codes
 *
 * The VirtualCode interface has an `embeddedCodes` array that (typically) contains
 * generated code based on the root virtual code file type (in our case, GTS). The generated
 * embedded codes will typically have a different file type ID (e.g. `typescript`); Volar
 * in turn can perform language processing on these specific files (e.g. generate diagnostics),
 * and then propagate these diagnostics upwards to the root virtual code file. In order to do this,
 * we need to provide source code mapping information so that Volar can correctly map the diagnostics
 * back to the original source code.
 *
 * Note that "embedded code" can be somewhat of a confusing concept based on how familiar
 * languages like HTML allow other languages (JS in script tags, CSS in style tags, etc.)
 * to be embedded within a parent file (e.g. HTML). If you were building a VirtualCode for HTML,
 * you would have an `embeddedCodes` array that contains VirtualCodes for the embedded languages,
 * where each VirtualCode had the extracted HTML, CSS, JS, etc contents.
 *
 * But for GTS, the embedded code that we generate does not actually exist in the same form in
 * the parent document (the .gts file); rather, the embedded code is a valid TS file that has
 * been generated from the .gts by replacing all of the embedded `<template>`s with TS. Whereas
 * for HTML, embedded codes are simple extracted strings of HTML, CSS, JS, etc, for GTS, the
 * embedded code is a transformed file that's most likely much larger than the original .gts file.
 *
 * Additionally:
 *
 * - We always generate an embedded code of TypeScript even when the .gts file has no embedded templates
 *   (meaning it is already valid TS). This keeps both our code and the structure of our VirtualCode
 *   simple and consistent. In cases where there are no embedded templates, the embedded code contains
 *   the same contents as the root virtual code file.
 *
 * - Even when there are multiple <template> tags, we only generate 1 embedded TS code representing
 *   the TS code for all of the entire .gts file.
 *
 * - The Root VirtualCode we provide is simple the untransformed .gts file itself. This is a Volar
 *   convention and also allows for the possible of writing language service plugins that operate
 *   directly on .gts (i.e. `glimmer-ts`) files directly (rather than on an embedded code).
 *
 * In summary, `embeddedCodes` is a more general/abstract concept of ANY kind of language that
 * is embedded or generated from the root virtual code file for the purposes of performing
 * language service processing for the particular file type of the embedded code.
 */
export declare class VirtualGtsCode implements VirtualCode {
    private glintConfig;
    snapshot: IScriptSnapshot;
    languageId: 'glimmer-ts' | 'glimmer-js' | 'typescript.glimmer' | 'javascript.glimmer';
    clientId?: string | undefined;
    /**
     * The virtual files embedded in the GTS file. (such as <template>)
     */
    embeddedCodes: EmbeddedCodeWithDirectives[];
    /**
     * The id is a unique (within the VirtualCode and its embedded files) id for Volar to identify it. It could be any string.
     */
    id: string;
    mappings: CodeMapping[];
    transformedModule: ReturnType<typeof rewriteModule> | null;
    constructor(glintConfig: GlintConfig, snapshot: IScriptSnapshot, languageId: 'glimmer-ts' | 'glimmer-js' | 'typescript.glimmer' | 'javascript.glimmer', clientId?: string | undefined);
    update(snapshot: IScriptSnapshot): void;
}
export {};
//# sourceMappingURL=gts-virtual-code.d.ts.map