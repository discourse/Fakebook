import * as fs from 'node:fs';
import { createRequire } from 'node:module';
import * as path from 'node:path';
import SilentError from 'silent-error';
import { GlintConfig } from './config.js';
/**
 * @private
 *
 * Only exported for testing purposes. Do not import.
 */
export const require = createRequire(import.meta.url);
/**
 * `ConfigLoader` provides an interface for finding the Glint config that
 * applies to a given file or directory, ensuring that only a single instance
 * of `GlintConfig` is ever created for a given `tsconfig.json` or
 * `jsconfig.json` source file.
 */
export class ConfigLoader {
    constructor() {
        this.configs = new Map();
    }
    configForFile(filePath) {
        return this.configForDirectory(path.dirname(filePath));
    }
    configForDirectory(directory) {
        let ts = findTypeScript(directory);
        if (!ts)
            return null;
        let configPath = findNearestConfigFile(ts, directory);
        if (!configPath)
            return null;
        let existing = this.configs.get(configPath);
        if (existing !== undefined)
            return existing;
        let configInput = loadConfigInput(ts, configPath);
        let config = new GlintConfig(ts, configPath, configInput || { environment: [] });
        this.configs.set(configPath, config);
        return config;
    }
}
export function findTypeScript(fromDir) {
    let requireFrom = path.resolve(fromDir, 'package.json');
    return (tryResolve(() => createRequire(requireFrom)('typescript')) ??
        tryResolve(() => require('typescript')));
}
function tryResolve(load) {
    try {
        return load();
    }
    catch (error) {
        if (error?.code === 'MODULE_NOT_FOUND') {
            return null;
        }
        throw error;
    }
}
function parseConfigInput(ts, entryPath, currentPath, fullGlintConfig) {
    let currentContents = ts.readConfigFile(currentPath, ts.sys.readFile).config;
    let currentGlintConfig = currentContents.glint ?? {};
    assert(currentPath === entryPath || !currentGlintConfig.transform, 'Glint `transform` options may not be specified in extended config.');
    if (currentContents.extends) {
        let paths = Array.isArray(currentContents.extends)
            ? currentContents.extends
            : [currentContents.extends];
        for (let extendPath of paths) {
            let currentExtendPath = path.resolve(path.dirname(currentPath), extendPath);
            if (!fs.existsSync(currentExtendPath)) {
                try {
                    currentExtendPath = require.resolve(currentContents.extends);
                }
                catch {
                    // suppress the exception thrown by require.resolve for those scenarios where the file does not exist
                }
            }
            fullGlintConfig = parseConfigInput(ts, entryPath, currentExtendPath, fullGlintConfig);
        }
    }
    return { ...fullGlintConfig, ...currentGlintConfig };
}
export function loadConfigInput(ts, entryPath) {
    return validateConfigInput(parseConfigInput(ts, entryPath, entryPath, {}));
}
function findNearestConfigFile(ts, searchFrom) {
    // Assume that the longest path is the most relevant one in the case that
    // multiple config files exist at or above our current directory.
    let configCandidates = [
        ts.findConfigFile(searchFrom, ts.sys.fileExists, 'tsconfig.json'),
        ts.findConfigFile(searchFrom, ts.sys.fileExists, 'jsconfig.json'),
    ]
        .filter((path) => typeof path === 'string')
        .sort((a, b) => b.length - a.length);
    return configCandidates[0];
}
function validateConfigInput(input) {
    if (!input['environment']) {
        input['environment'] = [];
    }
    assert(Array.isArray(input['environment'])
        ? input['environment'].every((env) => typeof env === 'string')
        : typeof input['environment'] === 'string' ||
            (typeof input['environment'] === 'object' && input['environment']), 'Glint config must specify an `environment` that is a string, array of strings, or an object ' +
        'mapping environment names to their config.');
    return input;
}
function assert(test, message) {
    if (!test) {
        throw new SilentError(`Glint config: ${message}`);
    }
}
//# sourceMappingURL=loader.js.map