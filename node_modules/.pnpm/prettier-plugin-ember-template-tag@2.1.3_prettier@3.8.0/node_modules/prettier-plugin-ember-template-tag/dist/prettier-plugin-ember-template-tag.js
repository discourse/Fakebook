"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const contentTag = require("content-tag");
const prettier = require("prettier");
const PARSER_NAME = "ember-template-tag";
const PRINTER_NAME = "ember-template-tag-estree";
const TEMPLATE_TAG_OPEN = "<template>";
const TEMPLATE_TAG_CLOSE = "</template>";
const languages = [
  {
    aliases: ["gjs", "glimmer-js"],
    extensions: [".gjs"],
    group: "JavaScript",
    name: "Ember Template Tag (gjs)",
    parsers: [PARSER_NAME],
    vscodeLanguageIds: ["glimmer-js"]
  },
  {
    aliases: ["gts", "glimmer-ts"],
    extensions: [".gts"],
    group: "TypeScript",
    name: "Ember Template Tag (gts)",
    parsers: [PARSER_NAME],
    vscodeLanguageIds: ["glimmer-ts"]
  }
];
const templateExportDefault = {
  category: "Format",
  default: false,
  description: 'Prepend default export template tags with "export default". Since 0.1.0.',
  type: "boolean"
};
const templateSingleQuote = {
  category: "Format",
  description: "Use single quotes instead of double quotes within template tags. Since 0.0.3.",
  type: "boolean"
};
const options$1 = {
  templateExportDefault,
  templateSingleQuote
};
var $s$1 = Object.defineProperty;
var Fe$1 = (a2, t) => {
  for (var e in t) $s$1(a2, e, { get: t[e], enumerable: true });
};
var qs$1 = {};
Fe$1(qs$1, { parsers: () => ta$1 });
var Nt$1 = {};
Fe$1(Nt$1, { __babel_estree: () => Jr$1, __js_expression: () => Kr$1, __ts_expression: () => Wr$1, __vue_event_binding: () => $r$1, __vue_expression: () => Kr$1, __vue_ts_event_binding: () => Hr$1, __vue_ts_expression: () => Wr$1, babel: () => $r$1, "babel-flow": () => Vs, "babel-ts": () => Hr$1 });
function Hs(a2, t) {
  if (a2 == null) return {};
  var e = {};
  for (var s in a2) if ({}.hasOwnProperty.call(a2, s)) {
    if (t.indexOf(s) !== -1) continue;
    e[s] = a2[s];
  }
  return e;
}
var B = class {
  line;
  column;
  index;
  constructor(t, e, s) {
    this.line = t, this.column = e, this.index = s;
  }
}, Y$1 = class Y {
  start;
  end;
  filename;
  identifierName;
  constructor(t, e) {
    this.start = t, this.end = e;
  }
};
function L(a2, t) {
  let { line: e, column: s, index: i } = a2;
  return new B(e, s + t, i + t);
}
var Lt$1 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Ks$1 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Lt$1 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Lt$1 } }, Dt$1 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Te$1 = (a2) => a2.type === "UpdateExpression" ? Dt$1.UpdateExpression[`${a2.prefix}`] : Dt$1[a2.type], Ws$1 = { AccessorIsGenerator: ({ kind: a2 }) => `A ${a2}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: a2 }) => `Missing initializer in ${a2} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: a2 }) => `\`${a2}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: a2, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a2}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: a2 }) => `'${a2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: a2 }) => `Unsyntactic ${a2 === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.", ImportBindingIsString: ({ importName: a2 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a2}" as foo }\`?`, ImportCallArity: "`import()` requires exactly one or two arguments.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: a2 }) => `Expected number in radix ${a2}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: a2 }) => `Escape sequence in keyword ${a2}.`, InvalidIdentifier: ({ identifierName: a2 }) => `Invalid identifier ${a2}.`, InvalidLhs: ({ ancestor: a2 }) => `Invalid left-hand side in ${Te$1(a2)}.`, InvalidLhsBinding: ({ ancestor: a2 }) => `Binding invalid left-hand side in ${Te$1(a2)}.`, InvalidLhsOptionalChaining: ({ ancestor: a2 }) => `Invalid optional chaining in the left-hand side of ${Te$1(a2)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: a2 }) => `Unexpected character '${a2}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: a2 }) => `Private name #${a2} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: a2 }) => `Label '${a2}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling the parser plugin: ${a2.map((t) => JSON.stringify(t)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a2.map((t) => JSON.stringify(t)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: a2 }) => `Duplicate key "${a2}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a2 }) => `An export name cannot include a lone surrogate, found '\\u${a2.toString(16)}'.`, ModuleExportUndefined: ({ localName: a2 }) => `Export '${a2}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: a2 }) => `Private names are only allowed in property accesses (\`obj.#${a2}\`) or in \`in\` expressions (\`#${a2} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: a2 }) => `Duplicate private name #${a2}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: a2 }) => `Unexpected keyword '${a2}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: a2 }) => `Unexpected reserved word '${a2}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: a2, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ""}${a2 ? `, expected "${a2}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.", UnexpectedVoidPattern: "Unexpected void binding.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: a2, onlyValidPropertyName: t }) => `The only valid meta property for ${a2} is ${a2}.${t}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: a2 }) => `Identifier '${a2}' has already been declared.`, VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.", VoidPatternInitializer: "A void binding may not have an initializer.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Js$1 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: a2 }) => `Assigning to '${a2}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: a2 }) => `Binding '${a2}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Gs$1 = { ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.", ParseExpressionExpectsEOF: ({ unexpected: a2 }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(a2)}\`.` }, Xs = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Ys$1 = Object.assign({ PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic references are only supported when using the `"proposal": "hack"` version of the pipeline proposal.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: a2 }) => `Invalid topic token ${a2}. In order to use ${a2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a2}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: a2 }) => `Hack-style pipe body cannot be an unparenthesized ${Te$1({ type: a2 })}; please wrap it in parentheses.` }, {}), Qs$1 = ["message"];
function Mt$1(a2, t, e) {
  Object.defineProperty(a2, t, { enumerable: false, configurable: true, value: e });
}
function Zs$1({ toMessage: a2, code: t, reasonCode: e, syntaxPlugin: s }) {
  let i = e === "MissingPlugin" || e === "MissingOneOfPlugins";
  return function r(n, o) {
    let h = new SyntaxError();
    return h.code = t, h.reasonCode = e, h.loc = n, h.pos = n.index, h.syntaxPlugin = s, i && (h.missingPlugin = o.missingPlugin), Mt$1(h, "clone", function(p = {}) {
      let { line: u, column: f2, index: y2 } = p.loc ?? n;
      return r(new B(u, f2, y2), Object.assign({}, o, p.details));
    }), Mt$1(h, "details", o), Object.defineProperty(h, "message", { configurable: true, get() {
      let c2 = `${a2(o)} (${n.line}:${n.column})`;
      return this.message = c2, c2;
    }, set(c2) {
      Object.defineProperty(this, "message", { value: c2, writable: true });
    } }), h;
  };
}
function O$1(a2, t) {
  if (Array.isArray(a2)) return (s) => O$1(s, a2[0]);
  let e = {};
  for (let s of Object.keys(a2)) {
    let i = a2[s], r = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = r, o = Hs(r, Qs$1), h = typeof n == "string" ? () => n : n;
    e[s] = Zs$1(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s, toMessage: h }, t ? { syntaxPlugin: t } : {}, o));
  }
  return e;
}
var l = Object.assign({}, O$1(Ks$1), O$1(Ws$1), O$1(Js$1), O$1(Gs$1), O$1`pipelineOperator`(Ys$1));
function ei$1() {
  return { sourceType: "script", sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, allowYieldOutsideFunction: false, plugins: [], strictMode: void 0, ranges: false, tokens: false, createImportExpressions: true, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
}
function ti$1(a2) {
  let t = ei$1();
  if (a2 == null) return t;
  if (a2.annexB != null && a2.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
  for (let e of Object.keys(t)) a2[e] != null && (t[e] = a2[e]);
  if (t.startLine === 1) a2.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : a2.startColumn == null && t.startIndex > 0 && (t.startColumn = t.startIndex);
  else if (a2.startColumn == null || a2.startIndex == null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
  if (t.sourceType === "commonjs") {
    if (a2.allowAwaitOutsideFunction != null) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
    if (a2.allowReturnOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
    if (a2.allowNewTargetOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
  }
  return t;
}
var { defineProperty: si$1 } = Object, Ot$1 = (a2, t) => {
  a2 && si$1(a2, t, { enumerable: false, value: a2[t] });
};
function ae(a2) {
  return Ot$1(a2.loc.start, "index"), Ot$1(a2.loc.end, "index"), a2;
}
var ii$1 = (a2) => class extends a2 {
  parse() {
    let e = ae(super.parse());
    return this.optionFlags & 256 && (e.tokens = e.tokens.map(ae)), e;
  }
  parseRegExpLiteral({ pattern: e, flags: s }) {
    let i = null;
    try {
      i = new RegExp(e, s);
    } catch {
    }
    let r = this.estreeParseLiteral(i);
    return r.regex = { pattern: e, flags: s }, r;
  }
  parseBigIntLiteral(e) {
    let s;
    try {
      s = BigInt(e);
    } catch {
      s = null;
    }
    let i = this.estreeParseLiteral(s);
    return i.bigint = String(i.value || e), i;
  }
  parseDecimalLiteral(e) {
    let i = this.estreeParseLiteral(null);
    return i.decimal = String(i.value || e), i;
  }
  estreeParseLiteral(e) {
    return this.parseLiteral(e, "Literal");
  }
  parseStringLiteral(e) {
    return this.estreeParseLiteral(e);
  }
  parseNumericLiteral(e) {
    return this.estreeParseLiteral(e);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(e) {
    return this.estreeParseLiteral(e);
  }
  estreeParseChainExpression(e, s) {
    let i = this.startNodeAtNode(e);
    return i.expression = e, this.finishNodeAt(i, "ChainExpression", s);
  }
  directiveToStmt(e) {
    let s = e.value;
    delete e.value, this.castNodeTo(s, "Literal"), s.raw = s.extra.raw, s.value = s.extra.expressionValue;
    let i = this.castNodeTo(e, "ExpressionStatement");
    return i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
  }
  fillOptionalPropertiesForTSESLint(e) {
  }
  cloneEstreeStringLiteral(e) {
    let { start: s, end: i, loc: r, range: n, raw: o, value: h } = e, c2 = Object.create(e.constructor.prototype);
    return c2.type = "Literal", c2.start = s, c2.end = i, c2.loc = r, c2.range = n, c2.raw = o, c2.value = h, c2;
  }
  initFunction(e, s) {
    super.initFunction(e, s), e.expression = false;
  }
  checkDeclaration(e) {
    e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
  }
  getObjectOrClassMethodParams(e) {
    return e.value.params;
  }
  isValidDirective(e) {
    return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !e.expression.extra?.parenthesized;
  }
  parseBlockBody(e, s, i, r, n) {
    super.parseBlockBody(e, s, i, r, n);
    let o = e.directives.map((h) => this.directiveToStmt(h));
    e.body = o.concat(e.body), delete e.directives;
  }
  parsePrivateName() {
    let e = super.parsePrivateName();
    return this.convertPrivateNameToPrivateIdentifier(e);
  }
  convertPrivateNameToPrivateIdentifier(e) {
    let s = super.getPrivateNameSV(e);
    return delete e.id, e.name = s, this.castNodeTo(e, "PrivateIdentifier");
  }
  isPrivateName(e) {
    return e.type === "PrivateIdentifier";
  }
  getPrivateNameSV(e) {
    return e.name;
  }
  parseLiteral(e, s) {
    let i = super.parseLiteral(e, s);
    return i.raw = i.extra.raw, delete i.extra, i;
  }
  parseFunctionBody(e, s, i = false) {
    super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
  }
  parseMethod(e, s, i, r, n, o, h = false) {
    let c2 = this.startNode();
    c2.kind = e.kind, c2 = super.parseMethod(c2, s, i, r, n, o, h), delete c2.kind;
    let { typeParameters: p } = e;
    p && (delete e.typeParameters, c2.typeParameters = p, this.resetStartLocationFromNode(c2, p));
    let u = this.castNodeTo(c2, this.hasPlugin("typescript") && !c2.body ? "TSEmptyBodyFunctionExpression" : "FunctionExpression");
    return e.value = u, o === "ClassPrivateMethod" && (e.computed = false), this.hasPlugin("typescript") && e.abstract ? (delete e.abstract, this.finishNode(e, "TSAbstractMethodDefinition")) : o === "ObjectMethod" ? (e.kind === "method" && (e.kind = "init"), e.shorthand = false, this.finishNode(e, "Property")) : this.finishNode(e, "MethodDefinition");
  }
  nameIsConstructor(e) {
    return e.type === "Literal" ? e.value === "constructor" : super.nameIsConstructor(e);
  }
  parseClassProperty(...e) {
    let s = super.parseClassProperty(...e);
    return s.abstract && this.hasPlugin("typescript") ? (delete s.abstract, this.castNodeTo(s, "TSAbstractPropertyDefinition")) : this.castNodeTo(s, "PropertyDefinition"), s;
  }
  parseClassPrivateProperty(...e) {
    let s = super.parseClassPrivateProperty(...e);
    return s.abstract && this.hasPlugin("typescript") ? this.castNodeTo(s, "TSAbstractPropertyDefinition") : this.castNodeTo(s, "PropertyDefinition"), s.computed = false, s;
  }
  parseClassAccessorProperty(e) {
    let s = super.parseClassAccessorProperty(e);
    return s.abstract && this.hasPlugin("typescript") ? (delete s.abstract, this.castNodeTo(s, "TSAbstractAccessorProperty")) : this.castNodeTo(s, "AccessorProperty"), s;
  }
  parseObjectProperty(e, s, i, r) {
    let n = super.parseObjectProperty(e, s, i, r);
    return n && (n.kind = "init", this.castNodeTo(n, "Property")), n;
  }
  finishObjectProperty(e) {
    return e.kind = "init", this.finishNode(e, "Property");
  }
  isValidLVal(e, s, i, r) {
    return e === "Property" ? "value" : super.isValidLVal(e, s, i, r);
  }
  isAssignable(e, s) {
    return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
  }
  toAssignable(e, s = false) {
    if (e != null && this.isObjectProperty(e)) {
      let { key: i, value: r } = e;
      this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, s);
    } else super.toAssignable(e, s);
  }
  toAssignableObjectExpressionProp(e, s, i) {
    e.type === "Property" && (e.kind === "get" || e.kind === "set") ? this.raise(l.PatternHasAccessor, e.key) : e.type === "Property" && e.method ? this.raise(l.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, s, i);
  }
  finishCallExpression(e, s) {
    let i = super.finishCallExpression(e, s);
    return i.callee.type === "Import" ? (this.castNodeTo(i, "ImportExpression"), i.source = i.arguments[0], i.options = i.arguments[1] ?? null, delete i.arguments, delete i.callee) : i.type === "OptionalCallExpression" ? this.castNodeTo(i, "CallExpression") : i.optional = false, i;
  }
  toReferencedArguments(e) {
    e.type !== "ImportExpression" && super.toReferencedArguments(e);
  }
  parseExport(e, s) {
    let i = this.state.lastTokStartLoc, r = super.parseExport(e, s);
    switch (r.type) {
      case "ExportAllDeclaration":
        r.exported = null;
        break;
      case "ExportNamedDeclaration":
        r.specifiers.length === 1 && r.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(r, "ExportAllDeclaration"), r.exported = r.specifiers[0].exported, delete r.specifiers);
      case "ExportDefaultDeclaration":
        {
          let { declaration: n } = r;
          n?.type === "ClassDeclaration" && n.decorators?.length > 0 && n.start === r.start && this.resetStartLocation(r, i);
        }
        break;
    }
    return r;
  }
  stopParseSubscript(e, s) {
    let i = super.stopParseSubscript(e, s);
    return s.optionalChainMember ? this.estreeParseChainExpression(i, e.loc.end) : i;
  }
  parseMember(e, s, i, r, n) {
    let o = super.parseMember(e, s, i, r, n);
    return o.type === "OptionalMemberExpression" ? this.castNodeTo(o, "MemberExpression") : o.optional = false, o;
  }
  isOptionalMemberExpression(e) {
    return e.type === "ChainExpression" ? e.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e);
  }
  hasPropertyAsPrivateName(e) {
    return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
  }
  isObjectProperty(e) {
    return e.type === "Property" && e.kind === "init" && !e.method;
  }
  isObjectMethod(e) {
    return e.type === "Property" && (e.method || e.kind === "get" || e.kind === "set");
  }
  castNodeTo(e, s) {
    let i = super.castNodeTo(e, s);
    return this.fillOptionalPropertiesForTSESLint(i), i;
  }
  cloneIdentifier(e) {
    let s = super.cloneIdentifier(e);
    return this.fillOptionalPropertiesForTSESLint(s), s;
  }
  cloneStringLiteral(e) {
    return e.type === "Literal" ? this.cloneEstreeStringLiteral(e) : super.cloneStringLiteral(e);
  }
  finishNodeAt(e, s, i) {
    return ae(super.finishNodeAt(e, s, i));
  }
  finishNode(e, s) {
    let i = super.finishNode(e, s);
    return this.fillOptionalPropertiesForTSESLint(i), i;
  }
  resetStartLocation(e, s) {
    super.resetStartLocation(e, s), ae(e);
  }
  resetEndLocation(e, s = this.state.lastTokEndLoc) {
    super.resetEndLocation(e, s), ae(e);
  }
}, K = class {
  constructor(t, e) {
    this.token = t, this.preserveSpace = !!e;
  }
  token;
  preserveSpace;
}, C$1 = { brace: new K("{"), j_oTag: new K("<tag"), j_cTag: new K("</tag"), j_expr: new K("<tag>...</tag>", true) }, g = true, d = true, Be$1 = true, ne$1 = true, _$1 = true, ri$1 = true, Se$1 = class Se {
  label;
  keyword;
  beforeExpr;
  startsExpr;
  rightAssociative;
  isLoop;
  isAssign;
  prefix;
  postfix;
  binop;
  constructor(t, e = {}) {
    this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null;
  }
}, pt$1 = /* @__PURE__ */ new Map();
function A$1(a2, t = {}) {
  t.keyword = a2;
  let e = x(a2, t);
  return pt$1.set(a2, e), e;
}
function k$1(a2, t) {
  return x(a2, { beforeExpr: g, binop: t });
}
var le$1 = -1, ut$1 = [], ft$1 = [], dt$1 = [], mt$1 = [], yt$1 = [], xt$1 = [];
function x(a2, t = {}) {
  return ++le$1, ft$1.push(a2), dt$1.push(t.binop ?? -1), mt$1.push(t.beforeExpr ?? false), yt$1.push(t.startsExpr ?? false), xt$1.push(t.prefix ?? false), ut$1.push(new Se$1(a2, t)), le$1;
}
function T$1(a2, t = {}) {
  return ++le$1, pt$1.set(a2, le$1), ft$1.push(a2), dt$1.push(t.binop ?? -1), mt$1.push(t.beforeExpr ?? false), yt$1.push(t.startsExpr ?? false), xt$1.push(t.prefix ?? false), ut$1.push(new Se$1("name", t)), le$1;
}
var ai$1 = { bracketL: x("[", { beforeExpr: g, startsExpr: d }), bracketHashL: x("#[", { beforeExpr: g, startsExpr: d }), bracketBarL: x("[|", { beforeExpr: g, startsExpr: d }), bracketR: x("]"), bracketBarR: x("|]"), braceL: x("{", { beforeExpr: g, startsExpr: d }), braceBarL: x("{|", { beforeExpr: g, startsExpr: d }), braceHashL: x("#{", { beforeExpr: g, startsExpr: d }), braceR: x("}"), braceBarR: x("|}"), parenL: x("(", { beforeExpr: g, startsExpr: d }), parenR: x(")"), comma: x(",", { beforeExpr: g }), semi: x(";", { beforeExpr: g }), colon: x(":", { beforeExpr: g }), doubleColon: x("::", { beforeExpr: g }), dot: x("."), question: x("?", { beforeExpr: g }), questionDot: x("?."), arrow: x("=>", { beforeExpr: g }), template: x("template"), ellipsis: x("...", { beforeExpr: g }), backQuote: x("`", { startsExpr: d }), dollarBraceL: x("${", { beforeExpr: g, startsExpr: d }), templateTail: x("...`", { startsExpr: d }), templateNonTail: x("...${", { beforeExpr: g, startsExpr: d }), at: x("@"), hash: x("#", { startsExpr: d }), interpreterDirective: x("#!..."), eq: x("=", { beforeExpr: g, isAssign: ne$1 }), assign: x("_=", { beforeExpr: g, isAssign: ne$1 }), slashAssign: x("_=", { beforeExpr: g, isAssign: ne$1 }), xorAssign: x("_=", { beforeExpr: g, isAssign: ne$1 }), moduloAssign: x("_=", { beforeExpr: g, isAssign: ne$1 }), incDec: x("++/--", { prefix: _$1, postfix: ri$1, startsExpr: d }), bang: x("!", { beforeExpr: g, prefix: _$1, startsExpr: d }), tilde: x("~", { beforeExpr: g, prefix: _$1, startsExpr: d }), doubleCaret: x("^^", { startsExpr: d }), doubleAt: x("@@", { startsExpr: d }), pipeline: k$1("|>", 0), nullishCoalescing: k$1("??", 1), logicalOR: k$1("||", 1), logicalAND: k$1("&&", 2), bitwiseOR: k$1("|", 3), bitwiseXOR: k$1("^", 4), bitwiseAND: k$1("&", 5), equality: k$1("==/!=/===/!==", 6), lt: k$1("</>/<=/>=", 7), gt: k$1("</>/<=/>=", 7), relational: k$1("</>/<=/>=", 7), bitShift: k$1("<</>>/>>>", 8), bitShiftL: k$1("<</>>/>>>", 8), bitShiftR: k$1("<</>>/>>>", 8), plusMin: x("+/-", { beforeExpr: g, binop: 9, prefix: _$1, startsExpr: d }), modulo: x("%", { binop: 10, startsExpr: d }), star: x("*", { binop: 10 }), slash: k$1("/", 10), exponent: x("**", { beforeExpr: g, binop: 11, rightAssociative: true }), _in: A$1("in", { beforeExpr: g, binop: 7 }), _instanceof: A$1("instanceof", { beforeExpr: g, binop: 7 }), _break: A$1("break"), _case: A$1("case", { beforeExpr: g }), _catch: A$1("catch"), _continue: A$1("continue"), _debugger: A$1("debugger"), _default: A$1("default", { beforeExpr: g }), _else: A$1("else", { beforeExpr: g }), _finally: A$1("finally"), _function: A$1("function", { startsExpr: d }), _if: A$1("if"), _return: A$1("return", { beforeExpr: g }), _switch: A$1("switch"), _throw: A$1("throw", { beforeExpr: g, prefix: _$1, startsExpr: d }), _try: A$1("try"), _var: A$1("var"), _const: A$1("const"), _with: A$1("with"), _new: A$1("new", { beforeExpr: g, startsExpr: d }), _this: A$1("this", { startsExpr: d }), _super: A$1("super", { startsExpr: d }), _class: A$1("class", { startsExpr: d }), _extends: A$1("extends", { beforeExpr: g }), _export: A$1("export"), _import: A$1("import", { startsExpr: d }), _null: A$1("null", { startsExpr: d }), _true: A$1("true", { startsExpr: d }), _false: A$1("false", { startsExpr: d }), _typeof: A$1("typeof", { beforeExpr: g, prefix: _$1, startsExpr: d }), _void: A$1("void", { beforeExpr: g, prefix: _$1, startsExpr: d }), _delete: A$1("delete", { beforeExpr: g, prefix: _$1, startsExpr: d }), _do: A$1("do", { isLoop: Be$1, beforeExpr: g }), _for: A$1("for", { isLoop: Be$1 }), _while: A$1("while", { isLoop: Be$1 }), _as: T$1("as", { startsExpr: d }), _assert: T$1("assert", { startsExpr: d }), _async: T$1("async", { startsExpr: d }), _await: T$1("await", { startsExpr: d }), _defer: T$1("defer", { startsExpr: d }), _from: T$1("from", { startsExpr: d }), _get: T$1("get", { startsExpr: d }), _let: T$1("let", { startsExpr: d }), _meta: T$1("meta", { startsExpr: d }), _of: T$1("of", { startsExpr: d }), _sent: T$1("sent", { startsExpr: d }), _set: T$1("set", { startsExpr: d }), _source: T$1("source", { startsExpr: d }), _static: T$1("static", { startsExpr: d }), _using: T$1("using", { startsExpr: d }), _yield: T$1("yield", { startsExpr: d }), _asserts: T$1("asserts", { startsExpr: d }), _checks: T$1("checks", { startsExpr: d }), _exports: T$1("exports", { startsExpr: d }), _global: T$1("global", { startsExpr: d }), _implements: T$1("implements", { startsExpr: d }), _intrinsic: T$1("intrinsic", { startsExpr: d }), _infer: T$1("infer", { startsExpr: d }), _is: T$1("is", { startsExpr: d }), _mixins: T$1("mixins", { startsExpr: d }), _proto: T$1("proto", { startsExpr: d }), _require: T$1("require", { startsExpr: d }), _satisfies: T$1("satisfies", { startsExpr: d }), _keyof: T$1("keyof", { startsExpr: d }), _readonly: T$1("readonly", { startsExpr: d }), _unique: T$1("unique", { startsExpr: d }), _abstract: T$1("abstract", { startsExpr: d }), _declare: T$1("declare", { startsExpr: d }), _enum: T$1("enum", { startsExpr: d }), _module: T$1("module", { startsExpr: d }), _namespace: T$1("namespace", { startsExpr: d }), _interface: T$1("interface", { startsExpr: d }), _type: T$1("type", { startsExpr: d }), _opaque: T$1("opaque", { startsExpr: d }), name: x("name", { startsExpr: d }), placeholder: x("%%", { startsExpr: d }), string: x("string", { startsExpr: d }), num: x("num", { startsExpr: d }), bigint: x("bigint", { startsExpr: d }), decimal: x("decimal", { startsExpr: d }), regexp: x("regexp", { startsExpr: d }), privateName: x("#name", { startsExpr: d }), eof: x("eof"), jsxName: x("jsxName"), jsxText: x("jsxText", { beforeExpr: g }), jsxTagStart: x("jsxTagStart", { startsExpr: d }), jsxTagEnd: x("jsxTagEnd") };
function S(a2) {
  return a2 >= 93 && a2 <= 133;
}
function ni$1(a2) {
  return a2 <= 92;
}
function M$1(a2) {
  return a2 >= 58 && a2 <= 133;
}
function Wt$1(a2) {
  return a2 >= 58 && a2 <= 137;
}
function oi$1(a2) {
  return mt$1[a2];
}
function he$1(a2) {
  return yt$1[a2];
}
function hi$1(a2) {
  return a2 >= 29 && a2 <= 33;
}
function Ft$1(a2) {
  return a2 >= 129 && a2 <= 131;
}
function ci$1(a2) {
  return a2 >= 90 && a2 <= 92;
}
function Pt$1(a2) {
  return a2 >= 58 && a2 <= 92;
}
function li$1(a2) {
  return a2 >= 39 && a2 <= 59;
}
function pi$1(a2) {
  return a2 === 34;
}
function ui$1(a2) {
  return xt$1[a2];
}
function fi$1(a2) {
  return a2 >= 121 && a2 <= 123;
}
function di$1(a2) {
  return a2 >= 124 && a2 <= 130;
}
function V$1(a2) {
  return ft$1[a2];
}
function be(a2) {
  return dt$1[a2];
}
function mi$1(a2) {
  return a2 === 57;
}
function ze$1(a2) {
  return a2 >= 24 && a2 <= 25;
}
function Jt$1(a2) {
  return ut$1[a2];
}
var gt$1 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-࢏ࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚ౜ౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ೜-ೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-Ƛ꟱-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Gt$1 = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-᫝᫠-᫫ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", yi$1 = new RegExp("[" + gt$1 + "]"), xi$1 = new RegExp("[" + gt$1 + Gt$1 + "]");
gt$1 = Gt$1 = null;
var Xt$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], Pi$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function qe$1(a2, t) {
  let e = 65536;
  for (let s = 0, i = t.length; s < i; s += 2) {
    if (e += t[s], e > a2) return false;
    if (e += t[s + 1], e >= a2) return true;
  }
  return false;
}
function F(a2) {
  return a2 < 65 ? a2 === 36 : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && yi$1.test(String.fromCharCode(a2)) : qe$1(a2, Xt$1);
}
function $$1(a2) {
  return a2 < 48 ? a2 === 36 : a2 < 58 ? true : a2 < 65 ? false : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && xi$1.test(String.fromCharCode(a2)) : qe$1(a2, Xt$1) || qe$1(a2, Pi$1);
}
var Tt$1 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, gi$1 = new Set(Tt$1.keyword), Ti$1 = new Set(Tt$1.strict), bi$1 = new Set(Tt$1.strictBind);
function Yt$1(a2, t) {
  return t && a2 === "await" || a2 === "enum";
}
function Qt$1(a2, t) {
  return Yt$1(a2, t) || Ti$1.has(a2);
}
function Zt$1(a2) {
  return bi$1.has(a2);
}
function es$1(a2, t) {
  return Qt$1(a2, t) || Zt$1(a2);
}
function Ai$1(a2) {
  return gi$1.has(a2);
}
function Si$1(a2, t, e) {
  return a2 === 64 && t === 64 && F(e);
}
var wi$1 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function Ci$1(a2) {
  return wi$1.has(a2);
}
var pe$1 = class pe {
  flags = 0;
  names = /* @__PURE__ */ new Map();
  firstLexicalName = "";
  constructor(t) {
    this.flags = t;
  }
}, ue$1 = class ue {
  parser;
  scopeStack = [];
  inModule;
  undefinedExports = /* @__PURE__ */ new Map();
  constructor(t, e) {
    this.parser = t, this.inModule = e;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get allowNewTarget() {
    return (this.currentThisScopeFlags() & 512) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    let t = this.currentThisScopeFlags();
    return (t & 64) > 0 && (t & 2) === 0;
  }
  get inStaticBlock() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      let { flags: e } = this.scopeStack[t];
      if (e & 128) return true;
      if (e & 1731) return false;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get inBareCaseStatement() {
    return (this.currentScope().flags & 256) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(t) {
    return new pe$1(t);
  }
  enter(t) {
    this.scopeStack.push(this.createScope(t));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(t) {
    return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
  }
  declareName(t, e, s) {
    let i = this.currentScope();
    if (e & 8 || e & 16) {
      this.checkRedeclarationInScope(i, t, e, s);
      let r = i.names.get(t) || 0;
      e & 16 ? r = r | 4 : (i.firstLexicalName || (i.firstLexicalName = t), r = r | 2), i.names.set(t, r), e & 8 && this.maybeExportDefined(i, t);
    } else if (e & 4) for (let r = this.scopeStack.length - 1; r >= 0 && (i = this.scopeStack[r], this.checkRedeclarationInScope(i, t, e, s), i.names.set(t, (i.names.get(t) || 0) | 1), this.maybeExportDefined(i, t), !(i.flags & 1667)); --r) ;
    this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(t);
  }
  maybeExportDefined(t, e) {
    this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(e);
  }
  checkRedeclarationInScope(t, e, s, i) {
    this.isRedeclaredInScope(t, e, s) && this.parser.raise(l.VarRedeclaration, i, { identifierName: e });
  }
  isRedeclaredInScope(t, e, s) {
    if (!(s & 1)) return false;
    if (s & 8) return t.names.has(e);
    let i = t.names.get(e) || 0;
    return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (i & 1) > 0 : (i & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === e) || !this.treatFunctionsAsVarInScope(t) && (i & 4) > 0;
  }
  checkLocalExport(t) {
    let { name: e } = t;
    this.scopeStack[0].names.has(e) || this.undefinedExports.set(e, t.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      let { flags: e } = this.scopeStack[t];
      if (e & 1667) return e;
    }
  }
  currentThisScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      let { flags: e } = this.scopeStack[t];
      if (e & 1731 && !(e & 4)) return e;
    }
  }
}, $e$1 = class $e extends pe$1 {
  declareFunctions = /* @__PURE__ */ new Set();
}, He$1 = class He extends ue$1 {
  createScope(t) {
    return new $e$1(t);
  }
  declareName(t, e, s) {
    let i = this.currentScope();
    if (e & 2048) {
      this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t), i.declareFunctions.add(t);
      return;
    }
    super.declareName(t, e, s);
  }
  isRedeclaredInScope(t, e, s) {
    if (super.isRedeclaredInScope(t, e, s)) return true;
    if (s & 2048 && !t.declareFunctions.has(e)) {
      let i = t.names.get(e);
      return (i & 4) > 0 || (i & 2) > 0;
    }
    return false;
  }
  checkLocalExport(t) {
    this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
  }
}, Ei$1 = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), P$1 = O$1`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: a2 }) => `Cannot overwrite reserved type ${a2}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: a2, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${a2} = true,\` or \`${a2} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: a2, enumName: t }) => `Enum member names need to be unique, but the name \`${a2}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: a2 }) => `Enum \`${a2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: a2, enumName: t }) => `Enum type \`${a2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a2 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: a2, memberName: t, explicitType: e }) => `Enum \`${a2}\` has type \`${e}\`, so the initializer of \`${t}\` needs to be a ${e} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: a2, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: a2, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${a2}\`.`, EnumInvalidMemberName: ({ enumName: a2, memberName: t, suggestion: e }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${e}\`, in enum \`${a2}\`.`, EnumNumberMemberNotInitialized: ({ enumName: a2, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${a2}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: a2 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a2}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, {}), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: a2 }) => `Unexpected reserved type ${a2}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: a2, suggestion: t }) => `\`declare export ${a2}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
function Ii(a2) {
  return a2.type === "DeclareExportAllDeclaration" || a2.type === "DeclareExportDeclaration" && (!a2.declaration || a2.declaration.type !== "TypeAlias" && a2.declaration.type !== "InterfaceDeclaration");
}
function Bt$1(a2) {
  return a2.importKind === "type" || a2.importKind === "typeof";
}
var Ni$1 = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
function ki$1(a2, t) {
  let e = [], s = [];
  for (let i = 0; i < a2.length; i++) (t(a2[i], i, a2) ? e : s).push(a2[i]);
  return [e, s];
}
var vi$1 = /\*?\s*@((?:no)?flow)\b/, Li = (a2) => class extends a2 {
  flowPragma = void 0;
  getScopeHandler() {
    return He$1;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  finishToken(e, s) {
    e !== 134 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
  }
  addComment(e) {
    if (this.flowPragma === void 0) {
      let s = vi$1.exec(e.value);
      if (s) if (s[1] === "flow") this.flowPragma = "flow";
      else if (s[1] === "noflow") this.flowPragma = "noflow";
      else throw new Error("Unexpected flow pragma");
    }
    super.addComment(e);
  }
  flowParseTypeInitialiser(e) {
    let s = this.state.inType;
    this.state.inType = true, this.expect(e || 14);
    let i = this.flowParseType();
    return this.state.inType = s, i;
  }
  flowParsePredicate() {
    let e = this.startNode(), s = this.state.startLoc;
    return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(P$1.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    let e = this.state.inType;
    this.state.inType = true, this.expect(14);
    let s = null, i = null;
    return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
  }
  flowParseDeclareClass(e) {
    return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
  }
  flowParseDeclareFunction(e) {
    this.next();
    let s = e.id = this.parseIdentifier(), i = this.startNode(), r = this.startNode();
    this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
    let n = this.flowParseFunctionTypeParams();
    return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(r, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
  }
  flowParseDeclare(e, s) {
    if (this.match(80)) return this.flowParseDeclareClass(e);
    if (this.match(68)) return this.flowParseDeclareFunction(e);
    if (this.match(74)) return this.flowParseDeclareVariable(e);
    if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(P$1.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
    if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(e);
    if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(e);
    if (this.isContextual(129)) return this.flowParseDeclareInterface(e);
    if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, s);
    throw this.unexpected();
  }
  flowParseDeclareVariable(e) {
    return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
  }
  flowParseDeclareModule(e) {
    this.scope.enter(0), this.match(134) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
    let s = e.body = this.startNode(), i = s.body = [];
    for (this.expect(5); !this.match(8); ) {
      let o = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(P$1.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), i.push(super.parseImport(o))) : (this.expectContextual(125, P$1.UnsupportedStatementInDeclareModule), i.push(this.flowParseDeclare(o, true)));
    }
    this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
    let r = null, n = false;
    return i.forEach((o) => {
      Ii(o) ? (r === "CommonJS" && this.raise(P$1.AmbiguousDeclareModuleKind, o), r = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(P$1.DuplicateDeclareModuleExports, o), r === "ES" && this.raise(P$1.AmbiguousDeclareModuleKind, o), r = "CommonJS", n = true);
    }), e.kind = r || "CommonJS", this.finishNode(e, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(e, s) {
    if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
      let i = this.state.value;
      throw this.raise(P$1.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: i, suggestion: Ni$1[i] });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" ? (e.default = false, delete e.exportKind, this.castNodeTo(e, "DeclareExportDeclaration")) : this.castNodeTo(e, "DeclareExportAllDeclaration");
    throw this.unexpected();
  }
  flowParseDeclareModuleExports(e) {
    return this.next(), this.expectContextual(111), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(e) {
    this.next();
    let s = this.flowParseTypeAlias(e);
    return this.castNodeTo(s, "DeclareTypeAlias"), s;
  }
  flowParseDeclareOpaqueType(e) {
    this.next();
    let s = this.flowParseOpaqueType(e, true);
    return this.castNodeTo(s, "DeclareOpaqueType"), s;
  }
  flowParseDeclareInterface(e) {
    return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
  }
  flowParseInterfaceish(e, s) {
    if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? 17 : 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], this.eat(81)) do
      e.extends.push(this.flowParseInterfaceExtends());
    while (!s && this.eat(12));
    if (s) {
      if (e.implements = [], e.mixins = [], this.eatContextual(117)) do
        e.mixins.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
      if (this.eatContextual(113)) do
        e.implements.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    }
    e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
  }
  flowParseInterfaceExtends() {
    let e = this.startNode();
    return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
  }
  flowParseInterface(e) {
    return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
  }
  checkNotUnderscore(e) {
    e === "_" && this.raise(P$1.UnexpectedReservedUnderscore, this.state.startLoc);
  }
  checkReservedType(e, s, i) {
    Ei$1.has(e) && this.raise(i ? P$1.AssignReservedType : P$1.UnexpectedReservedType, s, { reservedType: e });
  }
  flowParseRestrictedIdentifier(e, s) {
    return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
  }
  flowParseTypeAlias(e) {
    return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
  }
  flowParseOpaqueType(e, s) {
    return this.expectContextual(130), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
  }
  flowParseTypeParameter(e = false) {
    let s = this.state.startLoc, i = this.startNode(), r = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
    return i.name = n.name, i.variance = r, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(P$1.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    let e = this.state.inType, s = this.startNode();
    s.params = [], this.state.inType = true, this.match(47) || this.match(143) ? this.next() : this.unexpected();
    let i = false;
    do {
      let r = this.flowParseTypeParameter(i);
      s.params.push(r), r.default && (i = true), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
  }
  flowInTopLevelContext(e) {
    if (this.curContext() !== C$1.brace) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return e();
      } finally {
        this.state.context = s;
      }
    } else return e();
  }
  flowParseTypeParameterInstantiationInExpression() {
    if (this.reScan_lt() === 47) return this.flowParseTypeParameterInstantiation();
  }
  flowParseTypeParameterInstantiation() {
    let e = this.startNode(), s = this.state.inType;
    return this.state.inType = true, e.params = [], this.flowInTopLevelContext(() => {
      this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      this.state.noAnonFunctionType = i;
    }), this.state.inType = s, !this.state.inType && this.curContext() === C$1.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    if (this.reScan_lt() !== 47) return null;
    let e = this.startNode(), s = this.state.inType;
    for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    let e = this.startNode();
    if (this.expectContextual(129), e.extends = [], this.eat(81)) do
      e.extends.push(this.flowParseInterfaceExtends());
    while (this.eat(12));
    return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
  }
  flowParseObjectTypeIndexer(e, s, i) {
    return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(e, s) {
    return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(e) {
    for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
    return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(e, s) {
    let i = this.startNode();
    return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
  }
  flowParseObjectType({ allowStatic: e, allowExact: s, allowSpread: i, allowProto: r, allowInexact: n }) {
    let o = this.state.inType;
    this.state.inType = true;
    let h = this.startNode();
    h.callProperties = [], h.properties = [], h.indexers = [], h.internalSlots = [];
    let c2, p, u = false;
    for (s && this.match(6) ? (this.expect(6), c2 = 9, p = true) : (this.expect(5), c2 = 8, p = false), h.exact = p; !this.match(c2); ) {
      let y2 = false, b2 = null, N = null, I2 = this.startNode();
      if (r && this.isContextual(118)) {
        let E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), b2 = this.state.startLoc, e = false);
      }
      if (e && this.isContextual(106)) {
        let E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), y2 = true);
      }
      let w = this.flowParseVariance();
      if (this.eat(0)) b2 != null && this.unexpected(b2), this.eat(0) ? (w && this.unexpected(w.loc.start), h.internalSlots.push(this.flowParseObjectTypeInternalSlot(I2, y2))) : h.indexers.push(this.flowParseObjectTypeIndexer(I2, y2, w));
      else if (this.match(10) || this.match(47)) b2 != null && this.unexpected(b2), w && this.unexpected(w.loc.start), h.callProperties.push(this.flowParseObjectTypeCallProperty(I2, y2));
      else {
        let E = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          let re2 = this.lookahead();
          Wt$1(re2.type) && (E = this.state.value, this.next());
        }
        let xe2 = this.flowParseObjectTypeProperty(I2, y2, b2, w, E, i, n ?? !p);
        xe2 === null ? (u = true, N = this.state.lastTokStartLoc) : h.properties.push(xe2);
      }
      this.flowObjectTypeSemicolon(), N && !this.match(8) && !this.match(9) && this.raise(P$1.UnexpectedExplicitInexactInObject, N);
    }
    this.expect(c2), i && (h.inexact = u);
    let f2 = this.finishNode(h, "ObjectTypeAnnotation");
    return this.state.inType = o, f2;
  }
  flowParseObjectTypeProperty(e, s, i, r, n, o, h) {
    if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? h || this.raise(P$1.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(P$1.InexactInsideNonObject, this.state.lastTokStartLoc), r && this.raise(P$1.InexactVariance, r), null) : (o || this.raise(P$1.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), r && this.raise(P$1.SpreadVariance, r), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
    {
      e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
      let c2 = false;
      return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), r && this.unexpected(r.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(P$1.ThisParamBannedInConstructor, e.value.this)) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c2 = true), e.value = this.flowParseTypeInitialiser(), e.variance = r), e.optional = c2, this.finishNode(e, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(e) {
    let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
    e.value.this && this.raise(e.kind === "get" ? P$1.GetterMayNotHaveThisParam : P$1.SetterMayNotHaveThisParam, e.value.this), i !== s && this.raise(e.kind === "get" ? l.BadGetterArity : l.BadSetterArity, e), e.kind === "set" && e.value.rest && this.raise(l.BadSetterRestParameter, e);
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(e, s) {
    e ?? (e = this.state.startLoc);
    let i = s || this.flowParseRestrictedIdentifier(true);
    for (; this.eat(16); ) {
      let r = this.startNodeAt(e);
      r.qualification = i, r.id = this.flowParseRestrictedIdentifier(true), i = this.finishNode(r, "QualifiedTypeIdentifier");
    }
    return i;
  }
  flowParseGenericType(e, s) {
    let i = this.startNodeAt(e);
    return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    let e = this.startNode();
    return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    let e = this.startNode();
    for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
    return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(e) {
    let s = null, i = false, r = null, n = this.startNode(), o = this.lookahead(), h = this.state.type === 78;
    return o.type === 14 || o.type === 17 ? (h && !e && this.raise(P$1.ThisParamMustBeFirst, n), s = this.parseIdentifier(h), this.eat(17) && (i = true, h && this.raise(P$1.ThisParamMayNotBeOptional, n)), r = this.flowParseTypeInitialiser()) : r = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(e) {
    let s = this.startNodeAt(e.loc.start);
    return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(e = []) {
    let s = null, i = null;
    for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
    return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
  }
  flowIdentToTypeAnnotation(e, s, i) {
    switch (i.name) {
      case "any":
        return this.finishNode(s, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(s, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(s, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(s, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(s, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(s, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(s, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
    }
  }
  flowParsePrimaryType() {
    let e = this.state.startLoc, s = this.startNode(), i, r, n = false, o = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
      case 6:
        return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
      case 0:
        return this.state.noAnonFunctionType = false, r = this.flowParseTupleType(), this.state.noAnonFunctionType = o, r;
      case 47: {
        let h = this.startNode();
        return h.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), this.finishNode(h, "FunctionTypeAnnotation");
      }
      case 10: {
        let h = this.startNode();
        if (this.next(), !this.match(11) && !this.match(21)) if (S(this.state.type) || this.match(78)) {
          let c2 = this.lookahead().type;
          n = c2 !== 17 && c2 !== 14;
        } else n = true;
        if (n) {
          if (this.state.noAnonFunctionType = false, r = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), r;
          this.eat(12);
        }
        return r ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]) : i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), h.typeParameters = null, this.finishNode(h, "FunctionTypeAnnotation");
      }
      case 134:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
          if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
          throw this.raise(P$1.UnexpectedSubtractionOperand, this.state.startLoc);
        }
        throw this.unexpected();
      case 135:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 136:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(s, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(s, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (Pt$1(this.state.type)) {
          let h = V$1(this.state.type);
          return this.next(), super.createIdentifier(s, h);
        } else if (S(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
    }
    throw this.unexpected();
  }
  flowParsePostfixType() {
    let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      let r = this.startNodeAt(e), n = this.eat(18);
      i = i || n, this.expect(0), !n && this.match(3) ? (r.elementType = s, this.next(), s = this.finishNode(r, "ArrayTypeAnnotation")) : (r.objectType = s, r.indexType = this.flowParseType(), this.expect(3), i ? (r.optional = n, s = this.finishNode(r, "OptionalIndexedAccessType")) : s = this.finishNode(r, "IndexedAccessType"));
    }
    return s;
  }
  flowParsePrefixType() {
    let e = this.startNode();
    return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    let e = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      let s = this.startNodeAt(e.loc.start);
      return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
    }
    return e;
  }
  flowParseIntersectionType() {
    let e = this.startNode();
    this.eat(45);
    let s = this.flowParseAnonFunctionWithoutParens();
    for (e.types = [s]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
    return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    let e = this.startNode();
    this.eat(43);
    let s = this.flowParseIntersectionType();
    for (e.types = [s]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
    return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
  }
  flowParseType() {
    let e = this.state.inType;
    this.state.inType = true;
    let s = this.flowParseUnionType();
    return this.state.inType = e, s;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      let e = this.state.startLoc, s = this.parseIdentifier();
      return this.flowParseGenericType(e, s);
    } else return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    let e = this.startNode();
    return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(e) {
    let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
  }
  typeCastToParameter(e) {
    return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
  }
  flowParseVariance() {
    let e = null;
    return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
  }
  parseFunctionBody(e, s, i = false) {
    if (s) {
      this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
      return;
    }
    super.parseFunctionBody(e, false, i);
  }
  parseFunctionBodyAndFinish(e, s, i = false) {
    if (this.match(14)) {
      let r = this.startNode();
      [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = r.typeAnnotation ? this.finishNode(r, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(e, s, i);
  }
  parseStatementLike(e) {
    if (this.state.strict && this.isContextual(129)) {
      let i = this.lookahead();
      if (M$1(i.type)) {
        let r = this.startNode();
        return this.next(), this.flowParseInterface(r);
      }
    } else if (this.isContextual(126)) {
      let i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    }
    let s = super.parseStatementLike(e);
    return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
  }
  parseExpressionStatement(e, s, i) {
    if (s.type === "Identifier") {
      if (s.name === "declare") {
        if (this.match(80) || S(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
      } else if (S(this.state.type)) {
        if (s.name === "interface") return this.flowParseInterface(e);
        if (s.name === "type") return this.flowParseTypeAlias(e);
        if (s.name === "opaque") return this.flowParseOpaqueType(e, false);
      }
    }
    return super.parseExpressionStatement(e, s, i);
  }
  shouldParseExportDeclaration() {
    let { type: e } = this.state;
    return e === 126 || Ft$1(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    let { type: e } = this.state;
    return e === 126 || Ft$1(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.isContextual(126)) {
      let e = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(e);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(e, s, i) {
    if (!this.match(17)) return e;
    if (this.state.maybeInArrowParameters) {
      let f2 = this.lookaheadCharCode();
      if (f2 === 44 || f2 === 61 || f2 === 58 || f2 === 41) return this.setOptionalParametersError(i), e;
    }
    this.expect(17);
    let r = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: h, failed: c2 } = this.tryParseConditionalConsequent(), [p, u] = this.getArrowLikeExpressions(h);
    if (c2 || u.length > 0) {
      let f2 = [...n];
      if (u.length > 0) {
        this.state = r, this.state.noArrowAt = f2;
        for (let y2 = 0; y2 < u.length; y2++) f2.push(u[y2].start);
        ({ consequent: h, failed: c2 } = this.tryParseConditionalConsequent()), [p, u] = this.getArrowLikeExpressions(h);
      }
      c2 && p.length > 1 && this.raise(P$1.AmbiguousConditionalArrow, r.startLoc), c2 && p.length === 1 && (this.state = r, f2.push(p[0].start), this.state.noArrowAt = f2, { consequent: h, failed: c2 } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(h, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = h, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
  }
  getArrowLikeExpressions(e, s) {
    let i = [e], r = [];
    for (; i.length !== 0; ) {
      let n = i.pop();
      n.type === "ArrowFunctionExpression" && n.body.type !== "BlockStatement" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : r.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
    }
    return s ? (r.forEach((n) => this.finishArrowValidation(n)), [r, []]) : ki$1(r, (n) => n.params.every((o) => this.isAssignable(o, true)));
  }
  finishArrowValidation(e) {
    this.toAssignableList(e.params, e.extra?.trailingCommaLoc, false), this.scope.enter(518), super.checkParams(e, false, true), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(e, s) {
    let i;
    return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
  }
  parseParenItem(e, s) {
    let i = super.parseParenItem(e, s);
    if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
      let r = this.startNodeAt(s);
      return r.expression = i, r.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r, "TypeCastExpression");
    }
    return i;
  }
  assertModuleNodeAllowed(e) {
    e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
  }
  parseExportDeclaration(e) {
    if (this.isContextual(130)) {
      e.exportKind = "type";
      let s = this.startNode();
      return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
    } else if (this.isContextual(131)) {
      e.exportKind = "type";
      let s = this.startNode();
      return this.next(), this.flowParseOpaqueType(s, false);
    } else if (this.isContextual(129)) {
      e.exportKind = "type";
      let s = this.startNode();
      return this.next(), this.flowParseInterface(s);
    } else if (this.isContextual(126)) {
      e.exportKind = "value";
      let s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    } else return super.parseExportDeclaration(e);
  }
  eatExportStar(e) {
    return super.eatExportStar(e) ? true : this.isContextual(130) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
  }
  maybeParseExportNamespaceSpecifier(e) {
    let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
    return i && e.exportKind === "type" && this.unexpected(s), i;
  }
  parseClassId(e, s, i) {
    super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(e, s, i) {
    let { startLoc: r } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(e, s)) return;
      s.declare = true;
    }
    super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(P$1.DeclareClassElement, r) : s.value && this.raise(P$1.DeclareClassFieldInitializer, s.value));
  }
  isIterator(e) {
    return e === "iterator" || e === "asyncIterator";
  }
  readIterator() {
    let e = super.readWord1(), s = "@@" + e;
    (!this.isIterator(e) || !this.state.inType) && this.raise(l.InvalidIdentifier, this.state.curPosition(), { identifierName: s }), this.finishToken(132, s);
  }
  getTokenFromCode(e) {
    let s = this.input.charCodeAt(this.state.pos + 1);
    e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Si$1(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
  }
  isAssignable(e, s) {
    return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
  }
  toAssignable(e, s = false) {
    !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
  }
  toAssignableList(e, s, i) {
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      n?.type === "TypeCastExpression" && (e[r] = this.typeCastToParameter(n));
    }
    super.toAssignableList(e, s, i);
  }
  toReferencedList(e, s) {
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r && r.type === "TypeCastExpression" && !r.extra?.parenthesized && (e.length > 1 || !s) && this.raise(P$1.TypeCastInPattern, r.typeAnnotation);
    }
    return e;
  }
  parseArrayLike(e, s, i) {
    let r = super.parseArrayLike(e, s, i);
    return i != null && !this.state.maybeInArrowParameters && this.toReferencedList(r.elements), r;
  }
  isValidLVal(e, s, i, r) {
    return e === "TypeCastExpression" || super.isValidLVal(e, s, i, r);
  }
  parseClassProperty(e) {
    return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
  }
  parseClassPrivateProperty(e) {
    return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(e) {
    return !this.match(14) && super.isNonstaticConstructor(e);
  }
  pushClassMethod(e, s, i, r, n, o) {
    if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, r, n, o), s.params && n) {
      let h = s.params;
      h.length > 0 && this.isThisParam(h[0]) && this.raise(P$1.ThisParamBannedInConstructor, s);
    } else if (s.type === "MethodDefinition" && n && s.value.params) {
      let h = s.value.params;
      h.length > 0 && this.isThisParam(h[0]) && this.raise(P$1.ThisParamBannedInConstructor, s);
    }
  }
  pushClassPrivateMethod(e, s, i, r) {
    s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, r);
  }
  parseClassSuper(e) {
    if (super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
      this.next();
      let s = e.implements = [];
      do {
        let i = this.startNode();
        i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(e) {
    super.checkGetterSetterParams(e);
    let s = this.getObjectOrClassMethodParams(e);
    if (s.length > 0) {
      let i = s[0];
      this.isThisParam(i) && e.kind === "get" ? this.raise(P$1.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(P$1.SetterMayNotHaveThisParam, i);
    }
  }
  parsePropertyNamePrefixOperator(e) {
    e.variance = this.flowParseVariance();
  }
  parseObjPropValue(e, s, i, r, n, o, h) {
    e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
    let c2;
    this.match(47) && !o && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    let p = super.parseObjPropValue(e, s, i, r, n, o, h);
    return c2 && ((p.value || p).typeParameters = c2), p;
  }
  parseFunctionParamType(e) {
    return this.eat(17) && (e.type !== "Identifier" && this.raise(P$1.PatternIsOptional, e), this.isThisParam(e) && this.raise(P$1.ThisParamMayNotBeOptional, e), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(P$1.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(P$1.ThisParamNoDefault, e), this.resetEndLocation(e), e;
  }
  parseMaybeDefault(e, s) {
    let i = super.parseMaybeDefault(e, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(P$1.TypeBeforeInitializer, i.typeAnnotation), i;
  }
  checkImportReflection(e) {
    super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(P$1.ImportReflectionHasImportType, e.specifiers[0].loc.start);
  }
  parseImportSpecifierLocal(e, s, i) {
    s.local = Bt$1(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
  }
  isPotentialImportPhase(e) {
    if (super.isPotentialImportPhase(e)) return true;
    if (this.isContextual(130)) {
      if (!e) return true;
      let s = this.lookaheadCharCode();
      return s === 123 || s === 42;
    }
    return !e && this.isContextual(87);
  }
  applyImportPhase(e, s, i, r) {
    if (super.applyImportPhase(e, s, i, r), s) {
      if (!i && this.match(65)) return;
      e.exportKind = i === "type" ? i : "value";
    } else i === "type" && this.match(55) && this.unexpected(), e.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImportSpecifier(e, s, i, r, n) {
    let o = e.imported, h = null;
    o.type === "Identifier" && (o.name === "type" ? h = "type" : o.name === "typeof" && (h = "typeof"));
    let c2 = false;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      let u = this.parseIdentifier(true);
      h !== null && !M$1(this.state.type) ? (e.imported = u, e.importKind = h, e.local = this.cloneIdentifier(u)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
    } else {
      if (h !== null && M$1(this.state.type)) e.imported = this.parseIdentifier(true), e.importKind = h;
      else {
        if (s) throw this.raise(l.ImportBindingIsString, e, { importName: o.value });
        e.imported = o, e.importKind = null;
      }
      this.eatContextual(93) ? e.local = this.parseIdentifier() : (c2 = true, e.local = this.cloneIdentifier(e.imported));
    }
    let p = Bt$1(e);
    return i && p && this.raise(P$1.ImportTypeShorthandOnlyInPureImport, e), (i || p) && this.checkReservedType(e.local.name, e.local.loc.start, true), c2 && !i && !p && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(e, s) {
    let i = e.kind;
    i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
  }
  parseVarId(e, s) {
    super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
  }
  parseAsyncArrowFromCallExpression(e, s) {
    if (this.match(14)) {
      let i = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
    }
    return super.parseAsyncArrowFromCallExpression(e, s);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(e, s) {
    let i = null, r;
    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
      if (i = this.state.clone(), r = this.tryParse(() => super.parseMaybeAssign(e, s), i), !r.error) return r.node;
      let { context: n } = this.state, o = n[n.length - 1];
      (o === C$1.j_oTag || o === C$1.j_expr) && n.pop();
    }
    if (r?.error || this.match(47)) {
      i = i || this.state.clone();
      let n, o = this.tryParse((c2) => {
        n = this.flowParseTypeParameterDeclaration();
        let p = this.forwardNoArrowParamsConversionAt(n, () => {
          let f2 = super.parseMaybeAssign(e, s);
          return this.resetStartLocationFromNode(f2, n), f2;
        });
        p.extra?.parenthesized && c2();
        let u = this.maybeUnwrapTypeCastExpression(p);
        return u.type !== "ArrowFunctionExpression" && c2(), u.typeParameters = n, this.resetStartLocationFromNode(u, n), p;
      }, i), h = null;
      if (o.node && this.maybeUnwrapTypeCastExpression(o.node).type === "ArrowFunctionExpression") {
        if (!o.error && !o.aborted) return o.node.async && this.raise(P$1.UnexpectedTypeParameterBeforeAsyncArrowFunction, n), o.node;
        h = o.node;
      }
      if (r?.node) return this.state = r.failState, r.node;
      if (h) return this.state = o.failState, h;
      throw r?.thrown ? r.error : o.thrown ? o.error : this.raise(P$1.UnexpectedTokenAfterTypeParameter, n);
    }
    return super.parseMaybeAssign(e, s);
  }
  parseArrow(e) {
    if (this.match(14)) {
      let s = this.tryParse(() => {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        let r = this.startNode();
        return [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
      });
      if (s.thrown) return null;
      s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(e);
  }
  shouldParseArrow(e) {
    return this.match(14) || super.shouldParseArrow(e);
  }
  setArrowFunctionParameters(e, s) {
    this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? e.params = s : super.setArrowFunctionParameters(e, s);
  }
  checkParams(e, s, i, r = true) {
    if (!(i && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)))) {
      for (let n = 0; n < e.params.length; n++) this.isThisParam(e.params[n]) && n > 0 && this.raise(P$1.ThisParamMustBeFirst, e.params[n]);
      super.checkParams(e, s, i, r);
    }
  }
  parseParenAndDistinguishExpression(e) {
    return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
  }
  parseSubscripts(e, s, i) {
    if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.includes(s.index)) {
      this.next();
      let r = this.startNodeAt(s);
      r.callee = e, r.arguments = super.parseCallExpressionArguments(), e = this.finishNode(r, "CallExpression");
    } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
      let r = this.state.clone(), n = this.tryParse((h) => this.parseAsyncArrowWithTypeParameters(s) || h(), r);
      if (!n.error && !n.aborted) return n.node;
      let o = this.tryParse(() => super.parseSubscripts(e, s, i), r);
      if (o.node && !o.error) return o.node;
      if (n.node) return this.state = n.failState, n.node;
      if (o.node) return this.state = o.failState, o.node;
      throw n.error || o.error;
    }
    return super.parseSubscripts(e, s, i);
  }
  parseSubscript(e, s, i, r) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (r.optionalChainMember = true, i) return r.stop = true, e;
      this.next();
      let n = this.startNodeAt(s);
      return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), n.arguments = this.parseCallExpressionArguments(), n.optional = true, this.finishCallExpression(n, true);
    } else if (!i && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
      let n = this.startNodeAt(s);
      n.callee = e;
      let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(), r.optionalChainMember && (n.optional = false), this.finishCallExpression(n, r.optionalChainMember)));
      if (o.node) return o.error && (this.state = o.failState), o.node;
    }
    return super.parseSubscript(e, s, i, r);
  }
  parseNewCallee(e) {
    super.parseNewCallee(e);
    let s = null;
    this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
  }
  parseAsyncArrowWithTypeParameters(e) {
    let s = this.startNodeAt(e);
    if (this.parseFunctionParams(s, false), !!this.parseArrow(s)) return super.parseArrowExpression(s, void 0, true);
  }
  readToken_mult_modulo(e) {
    let s = this.input.charCodeAt(this.state.pos + 1);
    if (e === 42 && s === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(e);
  }
  readToken_pipe_amp(e) {
    let s = this.input.charCodeAt(this.state.pos + 1);
    if (e === 124 && s === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(e);
  }
  parseTopLevel(e, s) {
    let i = super.parseTopLevel(e, s);
    return this.state.hasFlowComment && this.raise(P$1.UnterminatedFlowComment, this.state.curPosition()), i;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment) throw this.raise(P$1.NestedFlowComment, this.state.startLoc);
      this.hasFlowCommentCompletion();
      let e = this.skipFlowComment();
      e && (this.state.pos += e, this.state.hasFlowComment = true);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    let { pos: e } = this.state, s = 2;
    for (; [32, 9].includes(this.input.charCodeAt(e + s)); ) s++;
    let i = this.input.charCodeAt(s + e), r = this.input.charCodeAt(s + e + 1);
    return i === 58 && r === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && r !== 58 ? s : false;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(l.UnterminatedComment, this.state.curPosition());
  }
  flowEnumErrorBooleanMemberNotInitialized(e, { enumName: s, memberName: i }) {
    this.raise(P$1.EnumBooleanMemberNotInitialized, e, { memberName: i, enumName: s });
  }
  flowEnumErrorInvalidMemberInitializer(e, s) {
    return this.raise(s.explicitType ? s.explicitType === "symbol" ? P$1.EnumInvalidMemberInitializerSymbolType : P$1.EnumInvalidMemberInitializerPrimaryType : P$1.EnumInvalidMemberInitializerUnknownType, e, s);
  }
  flowEnumErrorNumberMemberNotInitialized(e, s) {
    this.raise(P$1.EnumNumberMemberNotInitialized, e, s);
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(e, s) {
    this.raise(P$1.EnumStringMemberInconsistentlyInitialized, e, s);
  }
  flowEnumMemberInit() {
    let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 135: {
        let i = this.parseNumericLiteral(this.state.value);
        return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
      }
      case 134: {
        let i = this.parseStringLiteral(this.state.value);
        return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
      }
      case 85:
      case 86: {
        let i = this.parseBooleanLiteral(this.match(85));
        return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
      }
      default:
        return { type: "invalid", loc: e };
    }
  }
  flowEnumMemberRaw() {
    let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
    return { id: s, init: i };
  }
  flowEnumCheckExplicitTypeMismatch(e, s, i) {
    let { explicitType: r } = s;
    r !== null && r !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
  }
  flowEnumMembers({ enumName: e, explicitType: s }) {
    let i = /* @__PURE__ */ new Set(), r = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n = false;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        n = true;
        break;
      }
      let o = this.startNode(), { id: h, init: c2 } = this.flowEnumMemberRaw(), p = h.name;
      if (p === "") continue;
      /^[a-z]/.test(p) && this.raise(P$1.EnumInvalidMemberName, h, { memberName: p, suggestion: p[0].toUpperCase() + p.slice(1), enumName: e }), i.has(p) && this.raise(P$1.EnumDuplicateMemberName, h, { memberName: p, enumName: e }), i.add(p);
      let u = { enumName: e, explicitType: s, memberName: p };
      switch (o.id = h, c2.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "boolean"), o.init = c2.value, r.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "number"), o.init = c2.value, r.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "string"), o.init = c2.value, r.stringMembers.push(this.finishNode(o, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(c2.loc, u);
        case "none":
          switch (s) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(c2.loc, u);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(c2.loc, u);
              break;
            default:
              r.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return { members: r, hasUnknownMembers: n };
  }
  flowEnumStringMembers(e, s, { enumName: i }) {
    if (e.length === 0) return s;
    if (s.length === 0) return e;
    if (s.length > e.length) {
      for (let r of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
      return s;
    } else {
      for (let r of s) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
      return e;
    }
  }
  flowEnumParseExplicitType({ enumName: e }) {
    if (!this.eatContextual(102)) return null;
    if (!S(this.state.type)) throw this.raise(P$1.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
    let { value: s } = this.state;
    return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(P$1.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: s }), s;
  }
  flowEnumBody(e, s) {
    let i = s.name, r = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
    this.expect(5);
    let { members: o, hasUnknownMembers: h } = this.flowEnumMembers({ enumName: i, explicitType: n });
    switch (e.hasUnknownMembers = h, n) {
      case "boolean":
        return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
      case "number":
        return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
      case "string":
        return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
      case "symbol":
        return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
      default: {
        let c2 = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
        e.explicitType = false;
        let p = o.booleanMembers.length, u = o.numberMembers.length, f2 = o.stringMembers.length, y2 = o.defaultedMembers.length;
        if (!p && !u && !f2 && !y2) return c2();
        if (!p && !u) return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
        if (!u && !f2 && p >= y2) {
          for (let b2 of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(b2.loc.start, { enumName: i, memberName: b2.id.name });
          return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        } else if (!p && !f2 && u >= y2) {
          for (let b2 of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(b2.loc.start, { enumName: i, memberName: b2.id.name });
          return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        } else return this.raise(P$1.EnumInconsistentMemberValues, r, { enumName: i }), c2();
      }
    }
  }
  flowParseEnumDeclaration(e) {
    let s = this.parseIdentifier();
    return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
  }
  jsxParseOpeningElementAfterName(e) {
    return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e);
  }
  isLookaheadToken_lt() {
    let e = this.nextTokenStart();
    if (this.input.charCodeAt(e) === 60) {
      let s = this.input.charCodeAt(e + 1);
      return s !== 60 && s !== 61;
    }
    return false;
  }
  reScan_lt_gt() {
    let { type: e } = this.state;
    e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    let { type: e } = this.state;
    return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
  }
  maybeUnwrapTypeCastExpression(e) {
    return e.type === "TypeCastExpression" ? e.expression : e;
  }
};
var Di$1 = /\r\n|[\r\n\u2028\u2029]/, Pe$1 = new RegExp(Di$1.source, "g");
function J$1(a2) {
  switch (a2) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;
    default:
      return false;
  }
}
function Rt$1(a2, t, e) {
  for (let s = t; s < e; s++) if (J$1(a2.charCodeAt(s))) return true;
  return false;
}
var Re$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ue$1 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
function Mi$1(a2) {
  switch (a2) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true;
    default:
      return false;
  }
}
var R$1 = O$1`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: a2 }) => `Expected corresponding JSX closing tag for <${a2}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: a2, HTMLEntity: t }) => `Unexpected token \`${a2}\`. Did you mean \`${t}\` or \`{'${a2}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
function j$1(a2) {
  return a2 ? a2.type === "JSXOpeningFragment" || a2.type === "JSXClosingFragment" : false;
}
function W(a2) {
  if (a2.type === "JSXIdentifier") return a2.name;
  if (a2.type === "JSXNamespacedName") return a2.namespace.name + ":" + a2.name.name;
  if (a2.type === "JSXMemberExpression") return W(a2.object) + "." + W(a2.property);
  throw new Error("Node had unexpected type: " + a2.type);
}
var Oi$1 = (a2) => class extends a2 {
  jsxReadToken() {
    let e = "", s = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length) throw this.raise(R$1.UnterminatedJsxContent, this.state.startLoc);
      let i = this.input.charCodeAt(this.state.pos);
      switch (i) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(i);
            return;
          }
          e += this.input.slice(s, this.state.pos), this.finishToken(142, e);
          return;
        case 38:
          e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
          break;
        case 62:
        case 125:
          this.raise(R$1.UnexpectedToken, this.state.curPosition(), { unexpected: this.input[this.state.pos], HTMLEntity: i === 125 ? "&rbrace;" : "&gt;" });
        default:
          J$1(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(e) {
    let s = this.input.charCodeAt(this.state.pos), i;
    return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
  }
  jsxReadString(e) {
    let s = "", i = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length) throw this.raise(l.UnterminatedString, this.state.startLoc);
      let r = this.input.charCodeAt(this.state.pos);
      if (r === e) break;
      r === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : J$1(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
    }
    s += this.input.slice(i, this.state.pos++), this.finishToken(134, s);
  }
  jsxReadEntity() {
    let e = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let s = 10;
      this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
      let i = this.readInt(s, void 0, false, "bail");
      if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i);
    } else {
      let s = 0, i = false;
      for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
      if (i) {
        this.input.slice(e, this.state.pos);
        let n = void 0;
        if (++this.state.pos, n) ;
      }
    }
    return this.state.pos = e, "&";
  }
  jsxReadWord() {
    let e, s = this.state.pos;
    do
      e = this.input.charCodeAt(++this.state.pos);
    while ($$1(e) || e === 45);
    this.finishToken(141, this.input.slice(s, this.state.pos));
  }
  jsxParseIdentifier() {
    let e = this.startNode();
    return this.match(141) ? e.name = this.state.value : Pt$1(this.state.type) ? e.name = V$1(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    let e = this.state.startLoc, s = this.jsxParseIdentifier();
    if (!this.eat(14)) return s;
    let i = this.startNodeAt(e);
    return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
  }
  jsxParseElementName() {
    let e = this.state.startLoc, s = this.jsxParseNamespacedName();
    if (s.type === "JSXNamespacedName") return s;
    for (; this.eat(16); ) {
      let i = this.startNodeAt(e);
      i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
    }
    return s;
  }
  jsxParseAttributeValue() {
    let e;
    switch (this.state.type) {
      case 5:
        return e = this.startNode(), this.setContext(C$1.brace), this.next(), e = this.jsxParseExpressionContainer(e, C$1.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(R$1.AttributeIsEmpty, e), e;
      case 143:
      case 134:
        return this.parseExprAtom();
      default:
        throw this.raise(R$1.UnsupportedJsxValue, this.state.startLoc);
    }
  }
  jsxParseEmptyExpression() {
    let e = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(e) {
    return this.next(), e.expression = this.parseExpression(), this.setContext(C$1.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(e, s) {
    if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
    else {
      let i = this.parseExpression();
      i.type === "SequenceExpression" && !i.extra?.parenthesized && this.raise(R$1.UnexpectedSequenceExpression, i.expressions[1]), e.expression = i;
    }
    return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    let e = this.startNode();
    return this.match(5) ? (this.setContext(C$1.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(C$1.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(e) {
    let s = this.startNodeAt(e);
    return this.eat(144) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
  }
  jsxParseOpeningElementAfterName(e) {
    let s = [];
    for (; !this.match(56) && !this.match(144); ) s.push(this.jsxParseAttribute());
    return e.attributes = s, e.selfClosing = this.eat(56), this.expect(144), this.finishNode(e, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(e) {
    let s = this.startNodeAt(e);
    return this.eat(144) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(144), this.finishNode(s, "JSXClosingElement"));
  }
  jsxParseElementAt(e) {
    let s = this.startNodeAt(e), i = [], r = this.jsxParseOpeningElementAt(e), n = null;
    if (!r.selfClosing) {
      e: for (; ; ) switch (this.state.type) {
        case 143:
          if (e = this.state.startLoc, this.next(), this.eat(56)) {
            n = this.jsxParseClosingElementAt(e);
            break e;
          }
          i.push(this.jsxParseElementAt(e));
          break;
        case 142:
          i.push(this.parseLiteral(this.state.value, "JSXText"));
          break;
        case 5: {
          let o = this.startNode();
          this.setContext(C$1.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, C$1.j_expr));
          break;
        }
        default:
          this.unexpected();
      }
      j$1(r) && !j$1(n) && n !== null ? this.raise(R$1.MissingClosingTagFragment, n) : !j$1(r) && j$1(n) ? this.raise(R$1.MissingClosingTagElement, n, { openingTagName: W(r.name) }) : !j$1(r) && !j$1(n) && W(n.name) !== W(r.name) && this.raise(R$1.MissingClosingTagElement, n, { openingTagName: W(r.name) });
    }
    if (j$1(r) ? (s.openingFragment = r, s.closingFragment = n) : (s.openingElement = r, s.closingElement = n), s.children = i, this.match(47)) throw this.raise(R$1.UnwrappedAdjacentJSXElements, this.state.startLoc);
    return j$1(r) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
  }
  jsxParseElement() {
    let e = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(e);
  }
  setContext(e) {
    let { context: s } = this.state;
    s[s.length - 1] = e;
  }
  parseExprAtom(e) {
    return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(e) {
    let s = this.curContext();
    if (s === C$1.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (s === C$1.j_oTag || s === C$1.j_cTag) {
      if (F(e)) {
        this.jsxReadWord();
        return;
      }
      if (e === 62) {
        ++this.state.pos, this.finishToken(144);
        return;
      }
      if ((e === 34 || e === 39) && s === C$1.j_oTag) {
        this.jsxReadString(e);
        return;
      }
    }
    if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(143);
      return;
    }
    super.getTokenFromCode(e);
  }
  updateContext(e) {
    let { context: s, type: i } = this.state;
    if (i === 56 && e === 143) s.splice(-2, 2, C$1.j_cTag), this.state.canStartJSXElement = false;
    else if (i === 143) s.push(C$1.j_oTag);
    else if (i === 144) {
      let r = s[s.length - 1];
      r === C$1.j_oTag && e === 56 || r === C$1.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === C$1.j_expr) : (this.setContext(C$1.j_expr), this.state.canStartJSXElement = true);
    } else this.state.canStartJSXElement = oi$1(i);
  }
}, Ke$1 = class Ke extends pe$1 {
  tsNames = /* @__PURE__ */ new Map();
}, We$1 = class We extends ue$1 {
  importsStack = [];
  createScope(t) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new Ke$1(t);
  }
  enter(t) {
    t === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
  }
  exit() {
    let t = super.exit();
    return t === 1024 && this.importsStack.pop(), t;
  }
  hasImport(t, e) {
    let s = this.importsStack.length;
    if (this.importsStack[s - 1].has(t)) return true;
    if (!e && s > 1) {
      for (let i = 0; i < s - 1; i++) if (this.importsStack[i].has(t)) return true;
    }
    return false;
  }
  declareName(t, e, s) {
    if (e & 4096) {
      this.hasImport(t, true) && this.parser.raise(l.VarRedeclaration, s, { identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
      return;
    }
    let i = this.currentScope(), r = i.tsNames.get(t) || 0;
    if (e & 1024) {
      this.maybeExportDefined(i, t), i.tsNames.set(t, r | 16);
      return;
    }
    super.declareName(t, e, s), e & 2 && (e & 1 || (this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t)), r = r | 1), e & 256 && (r = r | 2), e & 512 && (r = r | 4), e & 128 && (r = r | 8), r && i.tsNames.set(t, r);
  }
  isRedeclaredInScope(t, e, s) {
    let i = t.tsNames.get(e);
    if ((i & 2) > 0) {
      if (s & 256) {
        let r = !!(s & 512), n = (i & 4) > 0;
        return r !== n;
      }
      return true;
    }
    return s & 128 && (i & 8) > 0 ? t.names.get(e) & 2 ? !!(s & 1) : false : s & 2 && (i & 1) > 0 ? true : super.isRedeclaredInScope(t, e, s);
  }
  checkLocalExport(t) {
    let { name: e } = t;
    if (this.hasImport(e)) return;
    let s = this.scopeStack.length;
    for (let i = s - 1; i >= 0; i--) {
      let n = this.scopeStack[i].tsNames.get(e);
      if ((n & 1) > 0 || (n & 16) > 0) return;
    }
    super.checkLocalExport(t);
  }
}, Je$1 = class Je {
  stacks = [];
  enter(t) {
    this.stacks.push(t);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & 2) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & 1) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & 4) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & 8) > 0;
  }
};
function Ae$1(a2, t) {
  return (a2 ? 2 : 0) | (t ? 1 : 0);
}
var Ge$1 = class Ge {
  sawUnambiguousESM = false;
  ambiguousScriptDifferentAst = false;
  sourceToOffsetPos(t) {
    return t + this.startIndex;
  }
  offsetToSourcePos(t) {
    return t - this.startIndex;
  }
  hasPlugin(t) {
    if (typeof t == "string") return this.plugins.has(t);
    {
      let [e, s] = t;
      if (!this.hasPlugin(e)) return false;
      let i = this.plugins.get(e);
      for (let r of Object.keys(s)) if (i?.[r] !== s[r]) return false;
      return true;
    }
  }
  getPluginOption(t, e) {
    return this.plugins.get(t)?.[e];
  }
};
function ts$1(a2, t) {
  a2.trailingComments === void 0 ? a2.trailingComments = t : a2.trailingComments.unshift(...t);
}
function Fi$1(a2, t) {
  a2.leadingComments === void 0 ? a2.leadingComments = t : a2.leadingComments.unshift(...t);
}
function G$1(a2, t) {
  a2.innerComments === void 0 ? a2.innerComments = t : a2.innerComments.unshift(...t);
}
function q(a2, t, e) {
  let s = null, i = t.length;
  for (; s === null && i > 0; ) s = t[--i];
  s === null || s.start > e.start ? G$1(a2, e.comments) : ts$1(s, e.comments);
}
var Xe$1 = class Xe extends Ge$1 {
  addComment(t) {
    this.filename && (t.loc.filename = this.filename);
    let { commentsLen: e } = this.state;
    this.comments.length !== e && (this.comments.length = e), this.comments.push(t), this.state.commentsLen++;
  }
  processComment(t) {
    let { commentStack: e } = this.state, s = e.length;
    if (s === 0) return;
    let i = s - 1, r = e[i];
    r.start === t.end && (r.leadingNode = t, i--);
    let { start: n } = t;
    for (; i >= 0; i--) {
      let o = e[i], h = o.end;
      if (h > n) o.containingNode = t, this.finalizeComment(o), e.splice(i, 1);
      else {
        h === n && (o.trailingNode = t);
        break;
      }
    }
  }
  finalizeComment(t) {
    let { comments: e } = t;
    if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && ts$1(t.leadingNode, e), t.trailingNode !== null && Fi$1(t.trailingNode, e);
    else {
      let s = t.containingNode, i = t.start;
      if (this.input.charCodeAt(this.offsetToSourcePos(i) - 1) === 44) switch (s.type) {
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          q(s, s.properties, t);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
          q(s, s.arguments, t);
          break;
        case "ImportExpression":
          q(s, [s.source, s.options ?? null], t);
          break;
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          q(s, s.params, t);
          break;
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          q(s, s.elements, t);
          break;
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          q(s, s.specifiers, t);
          break;
        case "TSEnumDeclaration":
          G$1(s, e);
          break;
        case "TSEnumBody":
          q(s, s.members, t);
          break;
        default:
          G$1(s, e);
      }
      else G$1(s, e);
    }
  }
  finalizeRemainingComments() {
    let { commentStack: t } = this.state;
    for (let e = t.length - 1; e >= 0; e--) this.finalizeComment(t[e]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(t) {
    let { commentStack: e } = this.state, { length: s } = e;
    if (s === 0) return;
    let i = e[s - 1];
    i.leadingNode === t && (i.leadingNode = null);
  }
  takeSurroundingComments(t, e, s) {
    let { commentStack: i } = this.state, r = i.length;
    if (r === 0) return;
    let n = r - 1;
    for (; n >= 0; n--) {
      let o = i[n], h = o.end;
      if (o.start === s) o.leadingNode = t;
      else if (h === e) o.trailingNode = t;
      else if (h < e) break;
    }
  }
}, Ye$1 = class a {
  flags = 1024;
  get strict() {
    return (this.flags & 1) > 0;
  }
  set strict(t) {
    t ? this.flags |= 1 : this.flags &= -2;
  }
  startIndex;
  curLine;
  lineStart;
  startLoc;
  endLoc;
  init({ strictMode: t, sourceType: e, startIndex: s, startLine: i, startColumn: r }) {
    this.strict = t === false ? false : t === true ? true : e === "module", this.startIndex = s, this.curLine = i, this.lineStart = -r, this.startLoc = this.endLoc = new B(i, r, s);
  }
  errors = [];
  potentialArrowAt = -1;
  noArrowAt = [];
  noArrowParamsConversionAt = [];
  get maybeInArrowParameters() {
    return (this.flags & 2) > 0;
  }
  set maybeInArrowParameters(t) {
    t ? this.flags |= 2 : this.flags &= -3;
  }
  get inType() {
    return (this.flags & 4) > 0;
  }
  set inType(t) {
    t ? this.flags |= 4 : this.flags &= -5;
  }
  get noAnonFunctionType() {
    return (this.flags & 8) > 0;
  }
  set noAnonFunctionType(t) {
    t ? this.flags |= 8 : this.flags &= -9;
  }
  get hasFlowComment() {
    return (this.flags & 16) > 0;
  }
  set hasFlowComment(t) {
    t ? this.flags |= 16 : this.flags &= -17;
  }
  get isAmbientContext() {
    return (this.flags & 32) > 0;
  }
  set isAmbientContext(t) {
    t ? this.flags |= 32 : this.flags &= -33;
  }
  get inAbstractClass() {
    return (this.flags & 64) > 0;
  }
  set inAbstractClass(t) {
    t ? this.flags |= 64 : this.flags &= -65;
  }
  get inDisallowConditionalTypesContext() {
    return (this.flags & 128) > 0;
  }
  set inDisallowConditionalTypesContext(t) {
    t ? this.flags |= 128 : this.flags &= -129;
  }
  topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
  get soloAwait() {
    return (this.flags & 256) > 0;
  }
  set soloAwait(t) {
    t ? this.flags |= 256 : this.flags &= -257;
  }
  get inFSharpPipelineDirectBody() {
    return (this.flags & 512) > 0;
  }
  set inFSharpPipelineDirectBody(t) {
    t ? this.flags |= 512 : this.flags &= -513;
  }
  labels = [];
  commentsLen = 0;
  commentStack = [];
  pos = 0;
  type = 140;
  value = null;
  start = 0;
  end = 0;
  lastTokEndLoc = null;
  lastTokStartLoc = null;
  context = [C$1.brace];
  get canStartJSXElement() {
    return (this.flags & 1024) > 0;
  }
  set canStartJSXElement(t) {
    t ? this.flags |= 1024 : this.flags &= -1025;
  }
  get containsEsc() {
    return (this.flags & 2048) > 0;
  }
  set containsEsc(t) {
    t ? this.flags |= 2048 : this.flags &= -2049;
  }
  firstInvalidTemplateEscapePos = null;
  get hasTopLevelAwait() {
    return (this.flags & 4096) > 0;
  }
  set hasTopLevelAwait(t) {
    t ? this.flags |= 4096 : this.flags &= -4097;
  }
  strictErrors = /* @__PURE__ */ new Map();
  tokensLength = 0;
  curPosition() {
    return new B(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
  }
  clone() {
    let t = new a();
    return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
  }
}, Bi$1 = function(t) {
  return t >= 48 && t <= 57;
}, Ut$1 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, ge$1 = { bin: (a2) => a2 === 48 || a2 === 49, oct: (a2) => a2 >= 48 && a2 <= 55, dec: (a2) => a2 >= 48 && a2 <= 57, hex: (a2) => a2 >= 48 && a2 <= 57 || a2 >= 65 && a2 <= 70 || a2 >= 97 && a2 <= 102 };
function _t$1(a2, t, e, s, i, r) {
  let n = e, o = s, h = i, c2 = "", p = null, u = e, { length: f2 } = t;
  for (; ; ) {
    if (e >= f2) {
      r.unterminated(n, o, h), c2 += t.slice(u, e);
      break;
    }
    let y2 = t.charCodeAt(e);
    if (Ri$1(a2, y2, t, e)) {
      c2 += t.slice(u, e);
      break;
    }
    if (y2 === 92) {
      c2 += t.slice(u, e);
      let b2 = Ui$1(t, e, s, i, a2 === "template", r);
      b2.ch === null && !p ? p = { pos: e, lineStart: s, curLine: i } : c2 += b2.ch, { pos: e, lineStart: s, curLine: i } = b2, u = e;
    } else y2 === 8232 || y2 === 8233 ? (++e, ++i, s = e) : y2 === 10 || y2 === 13 ? a2 === "template" ? (c2 += t.slice(u, e) + `
`, ++e, y2 === 13 && t.charCodeAt(e) === 10 && ++e, ++i, u = s = e) : r.unterminated(n, o, h) : ++e;
  }
  return { pos: e, str: c2, firstInvalidLoc: p, lineStart: s, curLine: i };
}
function Ri$1(a2, t, e, s) {
  return a2 === "template" ? t === 96 || t === 36 && e.charCodeAt(s + 1) === 123 : t === (a2 === "double" ? 34 : 39);
}
function Ui$1(a2, t, e, s, i, r) {
  let n = !i;
  t++;
  let o = (c2) => ({ pos: t, ch: c2, lineStart: e, curLine: s }), h = a2.charCodeAt(t++);
  switch (h) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let c2;
      return { code: c2, pos: t } = Qe$1(a2, t, e, s, 2, false, n, r), o(c2 === null ? null : String.fromCharCode(c2));
    }
    case 117: {
      let c2;
      return { code: c2, pos: t } = is$2(a2, t, e, s, n, r), o(c2 === null ? null : String.fromCodePoint(c2));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      a2.charCodeAt(t) === 10 && ++t;
    case 10:
      e = t, ++s;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (i) return o(null);
      r.strictNumericEscape(t - 1, e, s);
    default:
      if (h >= 48 && h <= 55) {
        let c2 = t - 1, u = /^[0-7]+/.exec(a2.slice(c2, t + 2))[0], f2 = parseInt(u, 8);
        f2 > 255 && (u = u.slice(0, -1), f2 = parseInt(u, 8)), t += u.length - 1;
        let y2 = a2.charCodeAt(t);
        if (u !== "0" || y2 === 56 || y2 === 57) {
          if (i) return o(null);
          r.strictNumericEscape(c2, e, s);
        }
        return o(String.fromCharCode(f2));
      }
      return o(String.fromCharCode(h));
  }
}
function Qe$1(a2, t, e, s, i, r, n, o) {
  let h = t, c2;
  return { n: c2, pos: t } = ss$1(a2, t, e, s, 16, i, r, false, o, !n), c2 === null && (n ? o.invalidEscapeSequence(h, e, s) : t = h - 1), { code: c2, pos: t };
}
function ss$1(a2, t, e, s, i, r, n, o, h, c2) {
  let p = t, u = i === 16 ? Ut$1.hex : Ut$1.decBinOct, f2 = i === 16 ? ge$1.hex : i === 10 ? ge$1.dec : i === 8 ? ge$1.oct : ge$1.bin, y2 = false, b2 = 0;
  for (let N = 0, I2 = r ?? 1 / 0; N < I2; ++N) {
    let w = a2.charCodeAt(t), E;
    if (w === 95 && o !== "bail") {
      let xe2 = a2.charCodeAt(t - 1), re2 = a2.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(re2) || !f2(re2) || u.has(xe2) || u.has(re2)) {
          if (c2) return { n: null, pos: t };
          h.unexpectedNumericSeparator(t, e, s);
        }
      } else {
        if (c2) return { n: null, pos: t };
        h.numericSeparatorInEscapeSequence(t, e, s);
      }
      ++t;
      continue;
    }
    if (w >= 97 ? E = w - 97 + 10 : w >= 65 ? E = w - 65 + 10 : Bi$1(w) ? E = w - 48 : E = 1 / 0, E >= i) {
      if (E <= 9 && c2) return { n: null, pos: t };
      if (E <= 9 && h.invalidDigit(t, e, s, i)) E = 0;
      else if (n) E = 0, y2 = true;
      else break;
    }
    ++t, b2 = b2 * i + E;
  }
  return t === p || r != null && t - p !== r || y2 ? { n: null, pos: t } : { n: b2, pos: t };
}
function is$2(a2, t, e, s, i, r) {
  let n = a2.charCodeAt(t), o;
  if (n === 123) {
    if (++t, { code: o, pos: t } = Qe$1(a2, t, e, s, a2.indexOf("}", t) - t, true, i, r), ++t, o !== null && o > 1114111) if (i) r.invalidCodePoint(t, e, s);
    else return { code: null, pos: t };
  } else ({ code: o, pos: t } = Qe$1(a2, t, e, s, 4, false, i, r));
  return { code: o, pos: t };
}
function oe$1(a2, t, e) {
  return new B(e, a2 - t, a2);
}
var _i$1 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Ze$1 = class Ze {
  constructor(t) {
    let e = t.startIndex || 0;
    this.type = t.type, this.value = t.value, this.start = e + t.start, this.end = e + t.end, this.loc = new Y$1(t.startLoc, t.endLoc);
  }
}, et$1 = class et extends Xe$1 {
  isLookahead;
  tokens = [];
  constructor(t, e) {
    super(), this.state = new Ye$1(), this.state.init(t), this.input = e, this.length = e.length, this.comments = [], this.isLookahead = false;
  }
  pushToken(t) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new Ze$1(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(t) {
    return this.match(t) ? (this.next(), true) : false;
  }
  match(t) {
    return this.state.type === t;
  }
  createLookaheadState(t) {
    return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
  }
  lookahead() {
    let t = this.state;
    this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
    let e = this.state;
    return this.state = t, e;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(t) {
    return Re$1.lastIndex = t, Re$1.test(this.input) ? Re$1.lastIndex : t;
  }
  lookaheadCharCode() {
    return this.lookaheadCharCodeSince(this.state.pos);
  }
  lookaheadCharCodeSince(t) {
    return this.input.charCodeAt(this.nextTokenStartSince(t));
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(t) {
    return Ue$1.lastIndex = t, Ue$1.test(this.input) ? Ue$1.lastIndex : t;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(t) {
    let e = this.input.charCodeAt(t);
    if ((e & 64512) === 55296 && ++t < this.input.length) {
      let s = this.input.charCodeAt(t);
      (s & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s & 1023));
    }
    return e;
  }
  setStrict(t) {
    this.state.strict = t, t && (this.state.strictErrors.forEach(([e, s]) => this.raise(e, s)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(140);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(t) {
    let e;
    this.isLookahead || (e = this.state.curPosition());
    let s = this.state.pos, i = this.input.indexOf(t, s + 2);
    if (i === -1) throw this.raise(l.UnterminatedComment, this.state.curPosition());
    for (this.state.pos = i + t.length, Pe$1.lastIndex = s + 2; Pe$1.test(this.input) && Pe$1.lastIndex <= i; ) ++this.state.curLine, this.state.lineStart = Pe$1.lastIndex;
    if (this.isLookahead) return;
    let r = { type: "CommentBlock", value: this.input.slice(s + 2, i), start: this.sourceToOffsetPos(s), end: this.sourceToOffsetPos(i + t.length), loc: new Y$1(e, this.state.curPosition()) };
    return this.optionFlags & 256 && this.pushToken(r), r;
  }
  skipLineComment(t) {
    let e = this.state.pos, s;
    this.isLookahead || (s = this.state.curPosition());
    let i = this.input.charCodeAt(this.state.pos += t);
    if (this.state.pos < this.length) for (; !J$1(i) && ++this.state.pos < this.length; ) i = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead) return;
    let r = this.state.pos, o = { type: "CommentLine", value: this.input.slice(e + t, r), start: this.sourceToOffsetPos(e), end: this.sourceToOffsetPos(r), loc: new Y$1(s, this.state.curPosition()) };
    return this.optionFlags & 256 && this.pushToken(o), o;
  }
  skipSpace() {
    let t = this.state.pos, e = this.optionFlags & 4096 ? [] : null;
    e: for (; this.state.pos < this.length; ) {
      let s = this.input.charCodeAt(this.state.pos);
      switch (s) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;
        case 13:
          this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
          break;
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              let i = this.skipBlockComment("*/");
              i !== void 0 && (this.addComment(i), e?.push(i));
              break;
            }
            case 47: {
              let i = this.skipLineComment(2);
              i !== void 0 && (this.addComment(i), e?.push(i));
              break;
            }
            default:
              break e;
          }
          break;
        default:
          if (Mi$1(s)) ++this.state.pos;
          else if (s === 45 && !this.inModule && this.optionFlags & 8192) {
            let i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
              let r = this.skipLineComment(3);
              r !== void 0 && (this.addComment(r), e?.push(r));
            } else break e;
          } else if (s === 60 && !this.inModule && this.optionFlags & 8192) {
            let i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
              let r = this.skipLineComment(4);
              r !== void 0 && (this.addComment(r), e?.push(r));
            } else break e;
          } else break e;
      }
    }
    if (e?.length > 0) {
      let s = this.state.pos, i = { start: this.sourceToOffsetPos(t), end: this.sourceToOffsetPos(s), comments: e, leadingNode: null, trailingNode: null, containingNode: null };
      this.state.commentStack.push(i);
    }
  }
  finishToken(t, e) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    let s = this.state.type;
    this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);
  }
  replaceToken(t) {
    this.state.type = t, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) return;
    let t = this.state.pos + 1, e = this.codePointAtPos(t);
    if (e >= 48 && e <= 57) throw this.raise(l.UnexpectedDigitAfterHash, this.state.curPosition());
    F(e) ? (++this.state.pos, this.finishToken(139, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    let t = this.input.charCodeAt(this.state.pos + 1);
    if (t >= 48 && t <= 57) {
      this.readNumber(true);
      return;
    }
    t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return false;
    let t = this.input.charCodeAt(this.state.pos + 1);
    if (t !== 33) return false;
    let e = this.state.pos;
    for (this.state.pos += 1; !J$1(t) && ++this.state.pos < this.length; ) t = this.input.charCodeAt(this.state.pos);
    let s = this.input.slice(e + 2, this.state.pos);
    return this.finishToken(28, s), true;
  }
  readToken_mult_modulo(t) {
    let e = t === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
    t === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = 57), i === 61 && !this.state.inType && (s++, e = t === 37 ? 33 : 30), this.finishOp(e, s);
  }
  readToken_pipe_amp(t) {
    let e = this.input.charCodeAt(this.state.pos + 1);
    if (e === t) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
      return;
    }
    if (t === 124 && e === 62) {
      this.finishOp(39, 2);
      return;
    }
    if (e === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(t === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    let t = this.input.charCodeAt(this.state.pos + 1);
    t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(t) {
    let e = this.input.charCodeAt(this.state.pos + 1);
    if (e === t) {
      this.finishOp(34, 2);
      return;
    }
    e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
    if (e === 60) {
      if (this.input.charCodeAt(t + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (e === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
    if (e === 62) {
      let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(t + s) === 61) {
        this.finishOp(30, s + 1);
        return;
      }
      this.finishOp(52, s);
      return;
    }
    if (e === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(t) {
    let e = this.input.charCodeAt(this.state.pos + 1);
    if (e === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (t === 61 && e === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(t === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
    t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(t) {
    switch (t) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        let e = this.input.charCodeAt(this.state.pos + 1);
        if (e === 120 || e === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (e === 111 || e === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (e === 98 || e === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false);
        return;
      case 34:
      case 39:
        this.readString(t);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(t);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(t);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(t);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(t);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (F(t)) {
          this.readWord(t);
          return;
        }
    }
    throw this.raise(l.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t) });
  }
  finishOp(t, e) {
    let s = this.input.slice(this.state.pos, this.state.pos + e);
    this.state.pos += e, this.finishToken(t, s);
  }
  readRegexp() {
    let t = this.state.startLoc, e = this.state.start + 1, s, i, { pos: r } = this.state;
    for (; ; ++r) {
      if (r >= this.length) throw this.raise(l.UnterminatedRegExp, L(t, 1));
      let c2 = this.input.charCodeAt(r);
      if (J$1(c2)) throw this.raise(l.UnterminatedRegExp, L(t, 1));
      if (s) s = false;
      else {
        if (c2 === 91) i = true;
        else if (c2 === 93 && i) i = false;
        else if (c2 === 47 && !i) break;
        s = c2 === 92;
      }
    }
    let n = this.input.slice(e, r);
    ++r;
    let o = "", h = () => L(t, r + 2 - e);
    for (; r < this.length; ) {
      let c2 = this.codePointAtPos(r), p = String.fromCharCode(c2);
      if (_i$1.has(c2)) c2 === 118 ? o.includes("u") && this.raise(l.IncompatibleRegExpUVFlags, h()) : c2 === 117 && o.includes("v") && this.raise(l.IncompatibleRegExpUVFlags, h()), o.includes(p) && this.raise(l.DuplicateRegExpFlags, h());
      else if ($$1(c2) || c2 === 92) this.raise(l.MalformedRegExpFlags, h());
      else break;
      ++r, o += p;
    }
    this.state.pos = r, this.finishToken(138, { pattern: n, flags: o });
  }
  readInt(t, e, s = false, i = true) {
    let { n: r, pos: n } = ss$1(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, e, s, i, this.errorHandlers_readInt, false);
    return this.state.pos = n, r;
  }
  readRadixNumber(t) {
    let e = this.state.pos, s = this.state.curPosition(), i = false;
    this.state.pos += 2;
    let r = this.readInt(t);
    r == null && this.raise(l.InvalidDigit, L(s, 2), { radix: t });
    let n = this.input.charCodeAt(this.state.pos);
    if (n === 110) ++this.state.pos, i = true;
    else if (n === 109) throw this.raise(l.InvalidDecimal, s);
    if (F(this.codePointAtPos(this.state.pos))) throw this.raise(l.NumberIdentifier, this.state.curPosition());
    if (i) {
      let o = this.input.slice(e, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(136, o);
      return;
    }
    this.finishToken(135, r);
  }
  readNumber(t) {
    let e = this.state.pos, s = this.state.curPosition(), i = false, r = false, n = false;
    !t && this.readInt(10) === null && this.raise(l.InvalidNumber, this.state.curPosition());
    let o = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
    if (o) {
      let u = this.input.slice(e, this.state.pos);
      if (this.recordStrictModeErrors(l.StrictOctalLiteral, s), !this.state.strict) {
        let f2 = u.indexOf("_");
        f2 > 0 && this.raise(l.ZeroDigitNumericSeparator, L(s, f2));
      }
      n = o && !/[89]/.test(u);
    }
    let h = this.input.charCodeAt(this.state.pos);
    if (h === 46 && !n && (++this.state.pos, this.readInt(10), i = true, h = this.input.charCodeAt(this.state.pos)), (h === 69 || h === 101) && !n && (h = this.input.charCodeAt(++this.state.pos), (h === 43 || h === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(l.InvalidOrMissingExponent, s), i = true, h = this.input.charCodeAt(this.state.pos)), h === 110 && ((i || o) && this.raise(l.InvalidBigIntLiteral, s), ++this.state.pos, r = true), F(this.codePointAtPos(this.state.pos))) throw this.raise(l.NumberIdentifier, this.state.curPosition());
    let c2 = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
    if (r) {
      this.finishToken(136, c2);
      return;
    }
    let p = n ? parseInt(c2, 8) : parseFloat(c2);
    this.finishToken(135, p);
  }
  readCodePoint(t) {
    let { code: e, pos: s } = is$2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
    return this.state.pos = s, e;
  }
  readString(t) {
    let { str: e, pos: s, curLine: i, lineStart: r } = _t$1(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = s + 1, this.state.lineStart = r, this.state.curLine = i, this.finishToken(134, e);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    let t = this.input[this.state.pos], { str: e, firstInvalidLoc: s, pos: i, curLine: r, lineStart: n } = _t$1("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = r, s && (this.state.firstInvalidTemplateEscapePos = new B(s.curLine, s.pos - s.lineStart, this.sourceToOffsetPos(s.pos))), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : t + e + "`") : (this.state.pos++, this.finishToken(25, s ? null : t + e + "${"));
  }
  recordStrictModeErrors(t, e) {
    let s = e.index;
    this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, e) : this.state.strictErrors.set(s, [t, e]);
  }
  readWord1(t) {
    this.state.containsEsc = false;
    let e = "", s = this.state.pos, i = this.state.pos;
    for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      let r = this.codePointAtPos(this.state.pos);
      if ($$1(r)) this.state.pos += r <= 65535 ? 1 : 2;
      else if (r === 92) {
        this.state.containsEsc = true, e += this.input.slice(i, this.state.pos);
        let n = this.state.curPosition(), o = this.state.pos === s ? F : $$1;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(l.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        let h = this.readCodePoint(true);
        h !== null && (o(h) || this.raise(l.EscapedCharNotAnIdentifier, n), e += String.fromCodePoint(h)), i = this.state.pos;
      } else break;
    }
    return e + this.input.slice(i, this.state.pos);
  }
  readWord(t) {
    let e = this.readWord1(t), s = pt$1.get(e);
    s !== void 0 ? this.finishToken(s, V$1(s)) : this.finishToken(132, e);
  }
  checkKeywordEscapes() {
    let { type: t } = this.state;
    Pt$1(t) && this.state.containsEsc && this.raise(l.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: V$1(t) });
  }
  raise(t, e, s = {}) {
    let i = e instanceof B ? e : e.loc.start, r = t(i, s);
    if (!(this.optionFlags & 2048)) throw r;
    return this.isLookahead || this.state.errors.push(r), r;
  }
  raiseOverwrite(t, e, s = {}) {
    let i = e instanceof B ? e : e.loc.start, r = i.index, n = this.state.errors;
    for (let o = n.length - 1; o >= 0; o--) {
      let h = n[o];
      if (h.loc.index === r) return n[o] = t(i, s);
      if (h.loc.index < r) break;
    }
    return this.raise(t, e, s);
  }
  updateContext(t) {
  }
  unexpected(t, e) {
    throw this.raise(l.UnexpectedToken, t ?? this.state.startLoc, { expected: e ? V$1(e) : null });
  }
  expectPlugin(t, e) {
    if (this.hasPlugin(t)) return true;
    throw this.raise(l.MissingPlugin, e ?? this.state.startLoc, { missingPlugin: [t] });
  }
  expectOnePlugin(t) {
    if (!t.some((e) => this.hasPlugin(e))) throw this.raise(l.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t });
  }
  errorBuilder(t) {
    return (e, s, i) => {
      this.raise(t, oe$1(e, s, i));
    };
  }
  errorHandlers_readInt = { invalidDigit: (t, e, s, i) => this.optionFlags & 2048 ? (this.raise(l.InvalidDigit, oe$1(t, e, s), { radix: i }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(l.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(l.UnexpectedNumericSeparator) };
  errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(l.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(l.InvalidCodePoint) });
  errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (t, e, s) => {
    this.recordStrictModeErrors(l.StrictNumericEscape, oe$1(t, e, s));
  }, unterminated: (t, e, s) => {
    throw this.raise(l.UnterminatedString, oe$1(t - 1, e, s));
  } });
  errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(l.StrictNumericEscape), unterminated: (t, e, s) => {
    throw this.raise(l.UnterminatedTemplate, oe$1(t, e, s));
  } });
}, tt$1 = class tt {
  privateNames = /* @__PURE__ */ new Set();
  loneAccessors = /* @__PURE__ */ new Map();
  undefinedPrivateNames = /* @__PURE__ */ new Map();
}, st = class {
  parser;
  stack = [];
  undefinedPrivateNames = /* @__PURE__ */ new Map();
  constructor(t) {
    this.parser = t;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new tt$1());
  }
  exit() {
    let t = this.stack.pop(), e = this.current();
    for (let [s, i] of Array.from(t.undefinedPrivateNames)) e ? e.undefinedPrivateNames.has(s) || e.undefinedPrivateNames.set(s, i) : this.parser.raise(l.InvalidPrivateFieldResolution, i, { identifierName: s });
  }
  declarePrivateName(t, e, s) {
    let { privateNames: i, loneAccessors: r, undefinedPrivateNames: n } = this.current(), o = i.has(t);
    if (e & 3) {
      let h = o && r.get(t);
      if (h) {
        let c2 = h & 4, p = e & 4, u = h & 3, f2 = e & 3;
        o = u === f2 || c2 !== p, o || r.delete(t);
      } else o || r.set(t, e);
    }
    o && this.parser.raise(l.PrivateNameRedeclaration, s, { identifierName: t }), i.add(t), n.delete(t);
  }
  usePrivateName(t, e) {
    let s;
    for (s of this.stack) if (s.privateNames.has(t)) return;
    s ? s.undefinedPrivateNames.set(t, e) : this.parser.raise(l.InvalidPrivateFieldResolution, e, { identifierName: t });
  }
}, Q$1 = class Q {
  constructor(t = 0) {
    this.type = t;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}, we$1 = class we extends Q$1 {
  declarationErrors = /* @__PURE__ */ new Map();
  constructor(t) {
    super(t);
  }
  recordDeclarationError(t, e) {
    let s = e.index;
    this.declarationErrors.set(s, [t, e]);
  }
  clearDeclarationError(t) {
    this.declarationErrors.delete(t);
  }
  iterateErrors(t) {
    this.declarationErrors.forEach(t);
  }
}, it$1 = class it {
  parser;
  stack = [new Q$1()];
  constructor(t) {
    this.parser = t;
  }
  enter(t) {
    this.stack.push(t);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(t, e) {
    let s = e.loc.start, { stack: i } = this, r = i.length - 1, n = i[r];
    for (; !n.isCertainlyParameterDeclaration(); ) {
      if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(t, s);
      else return;
      n = i[--r];
    }
    this.parser.raise(t, s);
  }
  recordArrowParameterBindingError(t, e) {
    let { stack: s } = this, i = s[s.length - 1], r = e.loc.start;
    if (i.isCertainlyParameterDeclaration()) this.parser.raise(t, r);
    else if (i.canBeArrowParameterDeclaration()) i.recordDeclarationError(t, r);
    else return;
  }
  recordAsyncArrowParametersError(t) {
    let { stack: e } = this, s = e.length - 1, i = e[s];
    for (; i.canBeArrowParameterDeclaration(); ) i.type === 2 && i.recordDeclarationError(l.AwaitBindingIdentifier, t), i = e[--s];
  }
  validateAsPattern() {
    let { stack: t } = this, e = t[t.length - 1];
    e.canBeArrowParameterDeclaration() && e.iterateErrors(([s, i]) => {
      this.parser.raise(s, i);
      let r = t.length - 2, n = t[r];
      for (; n.canBeArrowParameterDeclaration(); ) n.clearDeclarationError(i.index), n = t[--r];
    });
  }
};
function ji$1() {
  return new Q$1(3);
}
function Vi$1() {
  return new we$1(1);
}
function zi$1() {
  return new we$1(2);
}
function rs$1() {
  return new Q$1();
}
var rt$1 = class rt extends et$1 {
  addExtra(t, e, s, i = true) {
    if (!t) return;
    let { extra: r } = t;
    r == null && (r = {}, t.extra = r), i ? r[e] = s : Object.defineProperty(r, e, { enumerable: i, value: s });
  }
  isContextual(t) {
    return this.state.type === t && !this.state.containsEsc;
  }
  isUnparsedContextual(t, e) {
    if (this.input.startsWith(e, t)) {
      let s = this.input.charCodeAt(t + e.length);
      return !($$1(s) || (s & 64512) === 55296);
    }
    return false;
  }
  isLookaheadContextual(t) {
    let e = this.nextTokenStart();
    return this.isUnparsedContextual(e, t);
  }
  eatContextual(t) {
    return this.isContextual(t) ? (this.next(), true) : false;
  }
  expectContextual(t, e) {
    if (!this.eatContextual(t)) {
      if (e != null) throw this.raise(e, this.state.startLoc);
      this.unexpected(null, t);
    }
  }
  canInsertSemicolon() {
    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return Rt$1(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
  }
  hasFollowingLineBreak() {
    return Rt$1(this.input, this.state.end, this.nextTokenStart());
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(t = true) {
    (t ? this.isLineTerminator() : this.eat(13)) || this.raise(l.MissingSemicolon, this.state.lastTokEndLoc);
  }
  expect(t, e) {
    this.eat(t) || this.unexpected(e, t);
  }
  tryParse(t, e = this.state.clone()) {
    let s = { node: null };
    try {
      let i = t((r = null) => {
        throw s.node = r, s;
      });
      if (this.state.errors.length > e.errors.length) {
        let r = this.state;
        return this.state = e, this.state.tokensLength = r.tokensLength, { node: i, error: r.errors[e.errors.length], thrown: false, aborted: false, failState: r };
      }
      return { node: i, error: null, thrown: false, aborted: false, failState: null };
    } catch (i) {
      let r = this.state;
      if (this.state = e, i instanceof SyntaxError) return { node: null, error: i, thrown: true, aborted: false, failState: r };
      if (i === s) return { node: s.node, error: null, thrown: false, aborted: true, failState: r };
      throw i;
    }
  }
  checkExpressionErrors(t, e) {
    if (!t) return false;
    let { shorthandAssignLoc: s, doubleProtoLoc: i, privateKeyLoc: r, optionalParametersLoc: n, voidPatternLoc: o } = t, h = !!s || !!i || !!n || !!r || !!o;
    if (!e) return h;
    s != null && this.raise(l.InvalidCoverInitializedName, s), i != null && this.raise(l.DuplicateProto, i), r != null && this.raise(l.UnexpectedPrivateField, r), n != null && this.unexpected(n), o != null && this.raise(l.InvalidCoverDiscardElement, o);
  }
  isLiteralPropertyName() {
    return Wt$1(this.state.type);
  }
  isPrivateName(t) {
    return t.type === "PrivateName";
  }
  getPrivateNameSV(t) {
    return t.id.name;
  }
  hasPropertyAsPrivateName(t) {
    return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
  }
  isObjectProperty(t) {
    return t.type === "ObjectProperty";
  }
  isObjectMethod(t) {
    return t.type === "ObjectMethod";
  }
  initializeScopes(t = this.options.sourceType === "module") {
    let e = this.state.labels;
    this.state.labels = [];
    let s = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    let i = this.inModule;
    this.inModule = t;
    let r = this.scope, n = this.getScopeHandler();
    this.scope = new n(this, t);
    let o = this.prodParam;
    this.prodParam = new Je$1();
    let h = this.classScope;
    this.classScope = new st(this);
    let c2 = this.expressionScope;
    return this.expressionScope = new it$1(this), () => {
      this.state.labels = e, this.exportedIdentifiers = s, this.inModule = i, this.scope = r, this.prodParam = o, this.classScope = h, this.expressionScope = c2;
    };
  }
  enterInitialScopes() {
    let t = 0;
    (this.inModule || this.optionFlags & 1) && (t |= 2), this.optionFlags & 32 && (t |= 1);
    let e = !this.inModule && this.options.sourceType === "commonjs";
    (e || this.optionFlags & 2) && (t |= 4), this.prodParam.enter(t);
    let s = e ? 514 : 1;
    this.optionFlags & 4 && (s |= 512), this.optionFlags & 16 && (s |= 48), this.scope.enter(s);
  }
  checkDestructuringPrivate(t) {
    let { privateKeyLoc: e } = t;
    e !== null && this.expectPlugin("destructuringPrivate", e);
  }
}, X$1 = class X {
  shorthandAssignLoc = null;
  doubleProtoLoc = null;
  privateKeyLoc = null;
  optionalParametersLoc = null;
  voidPatternLoc = null;
}, fe$1 = class fe {
  constructor(t, e, s) {
    this.start = e, this.end = 0, this.loc = new Y$1(s), t?.optionFlags & 128 && (this.range = [e, 0]), t?.filename && (this.loc.filename = t.filename);
  }
  type = "";
}, jt$1 = fe$1.prototype, at$1 = class at extends rt$1 {
  startNode() {
    let t = this.state.startLoc;
    return new fe$1(this, t.index, t);
  }
  startNodeAt(t) {
    return new fe$1(this, t.index, t);
  }
  startNodeAtNode(t) {
    return this.startNodeAt(t.loc.start);
  }
  finishNode(t, e) {
    return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
  }
  finishNodeAt(t, e, s) {
    return t.type = e, t.end = s.index, t.loc.end = s, this.optionFlags & 128 && (t.range[1] = s.index), this.optionFlags & 4096 && this.processComment(t), t;
  }
  resetStartLocation(t, e) {
    t.start = e.index, t.loc.start = e, this.optionFlags & 128 && (t.range[0] = e.index);
  }
  resetEndLocation(t, e = this.state.lastTokEndLoc) {
    t.end = e.index, t.loc.end = e, this.optionFlags & 128 && (t.range[1] = e.index);
  }
  resetStartLocationFromNode(t, e) {
    this.resetStartLocation(t, e.loc.start);
  }
  castNodeTo(t, e) {
    return t.type = e, t;
  }
  cloneIdentifier(t) {
    let { type: e, start: s, end: i, loc: r, range: n, name: o } = t, h = Object.create(jt$1);
    return h.type = e, h.start = s, h.end = i, h.loc = r, h.range = n, h.name = o, t.extra && (h.extra = t.extra), h;
  }
  cloneStringLiteral(t) {
    let { type: e, start: s, end: i, loc: r, range: n, extra: o } = t, h = Object.create(jt$1);
    return h.type = e, h.start = s, h.end = i, h.loc = r, h.range = n, h.extra = o, h.value = t.value, h;
  }
}, nt = (a2) => a2.type === "ParenthesizedExpression" ? nt(a2.expression) : a2, ot$1 = class ot extends at$1 {
  toAssignable(t, e = false) {
    let s;
    switch ((t.type === "ParenthesizedExpression" || t.extra?.parenthesized) && (s = nt(t), e ? s.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(l.InvalidParenthesizedAssignment, t) : s.type !== "CallExpression" && s.type !== "MemberExpression" && !this.isOptionalMemberExpression(s) && this.raise(l.InvalidParenthesizedAssignment, t) : this.raise(l.InvalidParenthesizedAssignment, t)), t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
      case "VoidPattern":
        break;
      case "ObjectExpression":
        this.castNodeTo(t, "ObjectPattern");
        for (let i = 0, r = t.properties.length, n = r - 1; i < r; i++) {
          let o = t.properties[i], h = i === n;
          this.toAssignableObjectExpressionProp(o, h, e), h && o.type === "RestElement" && t.extra?.trailingCommaLoc && this.raise(l.RestTrailingComma, t.extra.trailingCommaLoc);
        }
        break;
      case "ObjectProperty": {
        let { key: i, value: r } = t;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, e);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        this.castNodeTo(t, "ArrayPattern"), this.toAssignableList(t.elements, t.extra?.trailingCommaLoc, e);
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(l.MissingEqInAssignment, t.left.loc.end), this.castNodeTo(t, "AssignmentPattern"), delete t.operator, t.left.type === "VoidPattern" && this.raise(l.VoidPatternInitializer, t.left), this.toAssignable(t.left, e);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(s, e);
        break;
    }
  }
  toAssignableObjectExpressionProp(t, e, s) {
    if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? l.PatternHasAccessor : l.PatternHasMethod, t.key);
    else if (t.type === "SpreadElement") {
      this.castNodeTo(t, "RestElement");
      let i = t.argument;
      this.checkToRestConversion(i, false), this.toAssignable(i, s), e || this.raise(l.RestTrailingComma, t);
    } else this.toAssignable(t, s);
  }
  toAssignableList(t, e, s) {
    let i = t.length - 1;
    for (let r = 0; r <= i; r++) {
      let n = t[r];
      n && (this.toAssignableListItem(t, r, s), n.type === "RestElement" && (r < i ? this.raise(l.RestTrailingComma, n) : e && this.raise(l.RestTrailingComma, e)));
    }
  }
  toAssignableListItem(t, e, s) {
    let i = t[e];
    if (i.type === "SpreadElement") {
      this.castNodeTo(i, "RestElement");
      let r = i.argument;
      this.checkToRestConversion(r, true), this.toAssignable(r, s);
    } else this.toAssignable(i, s);
  }
  isAssignable(t, e) {
    switch (t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
      case "VoidPattern":
        return true;
      case "ObjectExpression": {
        let s = t.properties.length - 1;
        return t.properties.every((i, r) => i.type !== "ObjectMethod" && (r === s || i.type !== "SpreadElement") && this.isAssignable(i));
      }
      case "ObjectProperty":
        return this.isAssignable(t.value);
      case "SpreadElement":
        return this.isAssignable(t.argument);
      case "ArrayExpression":
        return t.elements.every((s) => s === null || this.isAssignable(s));
      case "AssignmentExpression":
        return t.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(t.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !e;
      default:
        return false;
    }
  }
  toReferencedList(t, e) {
    return t;
  }
  toReferencedListDeep(t, e) {
    this.toReferencedList(t, e);
    for (let s of t) s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
  }
  parseSpread(t) {
    let e = this.startNode();
    return this.next(), e.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(e, "SpreadElement");
  }
  parseRestBinding() {
    let t = this.startNode();
    this.next();
    let e = this.parseBindingAtom();
    return e.type === "VoidPattern" && this.raise(l.UnexpectedVoidPattern, e), t.argument = e, this.finishNode(t, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        let t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, true);
      case 88:
        return this.parseVoidPattern(null);
    }
    return this.parseIdentifier();
  }
  parseBindingList(t, e, s) {
    let i = s & 1, r = [], n = true;
    for (; !this.eat(t); ) if (n ? n = false : this.expect(12), i && this.match(12)) r.push(null);
    else {
      if (this.eat(t)) break;
      if (this.match(21)) {
        let o = this.parseRestBinding();
        if (s & 2 && (o = this.parseFunctionParamType(o)), r.push(o), !this.checkCommaAfterRest(e)) {
          this.expect(t);
          break;
        }
      } else {
        let o = [];
        if (s & 2) for (this.match(26) && this.hasPlugin("decorators") && this.raise(l.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) o.push(this.parseDecorator());
        r.push(this.parseBindingElement(s, o));
      }
    }
    return r;
  }
  parseBindingRestProperty(t) {
    return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (t.argument = this.parseVoidPattern(null), this.raise(l.UnexpectedVoidPattern, t.argument)) : t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
  }
  parseBindingProperty() {
    let { type: t, startLoc: e } = this.state;
    if (t === 21) return this.parseBindingRestProperty(this.startNode());
    let s = this.startNode();
    return t === 139 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = false, this.parseObjPropValue(s, e, false, false, true, false);
  }
  parseBindingElement(t, e) {
    let s = this.parseMaybeDefault();
    return t & 2 && this.parseFunctionParamType(s), e.length && (s.decorators = e, this.resetStartLocationFromNode(s, e[0])), this.parseMaybeDefault(s.loc.start, s);
  }
  parseFunctionParamType(t) {
    return t;
  }
  parseMaybeDefault(t, e) {
    if (t ?? (t = this.state.startLoc), e = e ?? this.parseBindingAtom(), !this.eat(29)) return e;
    let s = this.startNodeAt(t);
    return e.type === "VoidPattern" && this.raise(l.VoidPatternInitializer, e), s.left = e, s.right = this.parseMaybeAssignAllowIn(), this.finishNode(s, "AssignmentPattern");
  }
  isValidLVal(t, e, s, i) {
    switch (t) {
      case "AssignmentPattern":
        return "left";
      case "RestElement":
        return "argument";
      case "ObjectProperty":
        return "value";
      case "ParenthesizedExpression":
        return "expression";
      case "ArrayPattern":
        return "elements";
      case "ObjectPattern":
        return "properties";
      case "VoidPattern":
        return true;
      case "CallExpression":
        if (!e && !this.state.strict && this.optionFlags & 8192) return true;
    }
    return false;
  }
  isOptionalMemberExpression(t) {
    return t.type === "OptionalMemberExpression";
  }
  checkLVal(t, e, s = 64, i = false, r = false, n = false, o = false) {
    let h = t.type;
    if (this.isObjectMethod(t)) return;
    let c2 = this.isOptionalMemberExpression(t);
    if (c2 || h === "MemberExpression") {
      c2 && (this.expectPlugin("optionalChainingAssign", t.loc.start), e.type !== "AssignmentExpression" && this.raise(l.InvalidLhsOptionalChaining, t, { ancestor: e })), s !== 64 && this.raise(l.InvalidPropertyBindingPattern, t);
      return;
    }
    if (h === "Identifier") {
      this.checkIdentifier(t, s, r);
      let { name: I2 } = t;
      i && (i.has(I2) ? this.raise(l.ParamDupe, t) : i.add(I2));
      return;
    } else h === "VoidPattern" && e.type === "CatchClause" && this.raise(l.VoidPatternCatchClauseParam, t);
    let p = nt(t);
    o || (o = p.type === "CallExpression" && (p.callee.type === "Import" || p.callee.type === "Super"));
    let u = this.isValidLVal(h, o, !(n || t.extra?.parenthesized) && e.type === "AssignmentExpression", s);
    if (u === true) return;
    if (u === false) {
      let I2 = s === 64 ? l.InvalidLhs : l.InvalidLhsBinding;
      this.raise(I2, t, { ancestor: e });
      return;
    }
    let f2, y2;
    typeof u == "string" ? (f2 = u, y2 = h === "ParenthesizedExpression") : [f2, y2] = u;
    let b2 = h === "ArrayPattern" || h === "ObjectPattern" ? { type: h } : e, N = t[f2];
    if (Array.isArray(N)) for (let I2 of N) I2 && this.checkLVal(I2, b2, s, i, r, y2, true);
    else N && this.checkLVal(N, b2, s, i, r, y2, o);
  }
  checkIdentifier(t, e, s = false) {
    this.state.strict && (s ? es$1(t.name, this.inModule) : Zt$1(t.name)) && (e === 64 ? this.raise(l.StrictEvalArguments, t, { referenceName: t.name }) : this.raise(l.StrictEvalArgumentsBinding, t, { bindingName: t.name })), e & 8192 && t.name === "let" && this.raise(l.LetInLexicalBinding, t), e & 64 || this.declareNameFromIdentifier(t, e);
  }
  declareNameFromIdentifier(t, e) {
    this.scope.declareName(t.name, e, t.loc.start);
  }
  checkToRestConversion(t, e) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(t.expression, e);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (e) break;
      default:
        this.raise(l.InvalidRestAssignmentPattern, t);
    }
  }
  checkCommaAfterRest(t) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? l.RestTrailingComma : l.ElementAfterRest, this.state.startLoc), true) : false;
  }
}, _e$1 = /in(?:stanceof)?|as|satisfies/y;
function qi$1(a2) {
  if (a2 == null) throw new Error(`Unexpected ${a2} value.`);
  return a2;
}
function Vt$1(a2) {
  if (!a2) throw new Error("Assert fail");
}
var m$1 = O$1`typescript`({ AbstractMethodHasImplementation: ({ methodName: a2 }) => `Method '${a2}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: a2 }) => `Property '${a2}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: a2 }) => `'declare' is not allowed in ${a2}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: a2 }) => `Accessibility modifier already seen: '${a2}'.`, DuplicateModifier: ({ modifier: a2 }) => `Duplicate modifier: '${a2}'.`, EmptyHeritageClauseType: ({ token: a2 }) => `'${a2}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: a2 }) => `'${a2[0]}' modifier cannot be used with '${a2[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: a2 }) => `Index signatures cannot have an accessibility modifier ('${a2}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidHeritageClauseType: ({ token: a2 }) => `'${a2}' list can only include identifiers or qualified-names with optional type arguments.`, InvalidModifierOnAwaitUsingDeclaration: (a2) => `'${a2}' modifier cannot appear on an await using declaration.`, InvalidModifierOnTypeMember: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: a2 }) => `'${a2}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifierOnUsingDeclaration: (a2) => `'${a2}' modifier cannot appear on a using declaration.`, InvalidModifiersOrder: ({ orderedModifiers: a2 }) => `'${a2[0]}' modifier must precede '${a2[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: a2 }) => `Private elements cannot have an accessibility modifier ('${a2}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a2 }) => `Single type parameter ${a2} should have a trailing comma. Example usage: <${a2},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: a2 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a2}.`, UsingDeclarationInAmbientContext: (a2) => `'${a2}' declarations are not allowed in ambient contexts.` });
function $i$1(a2) {
  switch (a2) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function zt$1(a2) {
  return a2 === "private" || a2 === "public" || a2 === "protected";
}
function Hi$1(a2) {
  return a2 === "in" || a2 === "out";
}
function ht(a2) {
  if (a2.extra?.parenthesized) return false;
  switch (a2.type) {
    case "Identifier":
      return true;
    case "MemberExpression":
      return !a2.computed && ht(a2.object);
    case "TSInstantiationExpression":
      return ht(a2.expression);
    default:
      return false;
  }
}
var Ki$1 = (a2) => class extends a2 {
  getScopeHandler() {
    return We$1;
  }
  tsIsIdentifier() {
    return S(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
  }
  tsNextTokenOnSameLineAndCanFollowModifier() {
    return this.next(), this.hasPrecedingLineBreak() ? false : this.tsTokenCanFollowModifier();
  }
  tsNextTokenCanFollowModifier() {
    return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
  }
  tsParseModifier(e, s, i) {
    if (!S(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
    let r = this.state.value;
    if (e.includes(r)) {
      if (i && this.match(106) || s && this.tsIsStartOfStaticBlocks()) return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
    }
  }
  tsParseModifiers({ allowedModifiers: e, disallowedModifiers: s, stopOnStartOfClassStaticBlock: i, errorTemplate: r = m$1.InvalidModifierOnTypeMember }, n) {
    let o = (c2, p, u, f2) => {
      p === u && n[f2] && this.raise(m$1.InvalidModifiersOrder, c2, { orderedModifiers: [u, f2] });
    }, h = (c2, p, u, f2) => {
      (n[u] && p === f2 || n[f2] && p === u) && this.raise(m$1.IncompatibleModifiers, c2, { modifiers: [u, f2] });
    };
    for (; ; ) {
      let { startLoc: c2 } = this.state, p = this.tsParseModifier(e.concat(s ?? []), i, n.static);
      if (!p) break;
      zt$1(p) ? n.accessibility ? this.raise(m$1.DuplicateAccessibilityModifier, c2, { modifier: p }) : (o(c2, p, p, "override"), o(c2, p, p, "static"), o(c2, p, p, "readonly"), n.accessibility = p) : Hi$1(p) ? (n[p] && this.raise(m$1.DuplicateModifier, c2, { modifier: p }), n[p] = true, o(c2, p, "in", "out")) : (Object.prototype.hasOwnProperty.call(n, p) ? this.raise(m$1.DuplicateModifier, c2, { modifier: p }) : (o(c2, p, "static", "readonly"), o(c2, p, "static", "override"), o(c2, p, "override", "readonly"), o(c2, p, "abstract", "override"), h(c2, p, "declare", "override"), h(c2, p, "static", "abstract")), n[p] = true), s?.includes(p) && this.raise(r, c2, { modifier: p });
    }
  }
  tsIsListTerminator(e) {
    switch (e) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(e, s) {
    let i = [];
    for (; !this.tsIsListTerminator(e); ) i.push(s());
    return i;
  }
  tsParseDelimitedList(e, s, i) {
    return qi$1(this.tsParseDelimitedListWorker(e, s, true, i));
  }
  tsParseDelimitedListWorker(e, s, i, r) {
    let n = [], o = -1;
    for (; !this.tsIsListTerminator(e); ) {
      o = -1;
      let h = s();
      if (h == null) return;
      if (n.push(h), this.eat(12)) {
        o = this.state.lastTokStartLoc.index;
        continue;
      }
      if (this.tsIsListTerminator(e)) break;
      i && this.expect(12);
      return;
    }
    return r && (r.value = o), n;
  }
  tsParseBracketedList(e, s, i, r, n) {
    r || (i ? this.expect(0) : this.expect(47));
    let o = this.tsParseDelimitedList(e, s, n);
    return i ? this.expect(3) : this.expect(48), o;
  }
  tsParseImportType() {
    let e = this.startNode();
    return this.expect(83), this.expect(10), this.match(134) ? e.argument = this.tsParseLiteralTypeNode() : (this.raise(m$1.UnsupportedImportTypeArgument, this.state.startLoc), e.argument = this.tsParseNonConditionalType()), this.eat(12) ? e.options = this.tsParseImportTypeOptions() : e.options = null, this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
  }
  tsParseImportTypeOptions() {
    let e = this.startNode();
    this.expect(5);
    let s = this.startNode();
    return this.isContextual(76) ? (s.method = false, s.key = this.parseIdentifier(true), s.computed = false, s.shorthand = false) : this.unexpected(null, 76), this.expect(14), s.value = this.tsParseImportTypeWithPropertyValue(), e.properties = [this.finishObjectProperty(s)], this.eat(12), this.expect(8), this.finishNode(e, "ObjectExpression");
  }
  tsParseImportTypeWithPropertyValue() {
    let e = this.startNode(), s = [];
    for (this.expect(5); !this.match(8); ) {
      let i = this.state.type;
      S(i) || i === 134 ? s.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
    }
    return e.properties = s, this.next(), this.finishNode(e, "ObjectExpression");
  }
  tsParseEntityName(e) {
    let s;
    if (e & 1 && this.match(78)) if (e & 2) s = this.parseIdentifier(true);
    else {
      let i = this.startNode();
      this.next(), s = this.finishNode(i, "ThisExpression");
    }
    else s = this.parseIdentifier(!!(e & 1));
    for (; this.eat(16); ) {
      let i = this.startNodeAtNode(s);
      i.left = s, i.right = this.parseIdentifier(!!(e & 1)), s = this.finishNode(i, "TSQualifiedName");
    }
    return s;
  }
  tsParseTypeReference() {
    let e = this.startNode();
    return e.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
  }
  tsParseThisTypePredicate(e) {
    this.next();
    let s = this.startNodeAtNode(e);
    return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    let e = this.startNode();
    return this.next(), this.finishNode(e, "TSThisType");
  }
  tsParseTypeQuery() {
    let e = this.startNode();
    return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
  }
  tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: m$1.InvalidModifierOnTypeParameter });
  tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: m$1.InvalidModifierOnTypeParameterPositions });
  tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: m$1.InvalidModifierOnTypeParameter });
  tsParseTypeParameter(e) {
    let s = this.startNode();
    return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
  }
  tsTryParseTypeParameters(e) {
    if (this.match(47)) return this.tsParseTypeParameters(e);
  }
  tsParseTypeParameters(e) {
    let s = this.startNode();
    this.match(47) || this.match(143) ? this.next() : this.unexpected();
    let i = { value: -1 };
    return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(m$1.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
  }
  tsFillSignature(e, s) {
    let i = e === 19, r = "params", n = "returnType";
    s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[r] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
  }
  tsParseBindingListForSignature() {
    let e = super.parseBindingList(11, 41, 2);
    for (let s of e) {
      let { type: i } = s;
      (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(m$1.UnsupportedSignatureParameterKind, s, { type: i });
    }
    return e;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(e, s) {
    return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), S(this.state.type) ? (this.next(), this.match(14)) : false;
  }
  tsTryParseIndexSignature(e) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
    this.expect(0);
    let s = this.parseIdentifier();
    s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
    let i = this.tsTryParseTypeAnnotation();
    return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(e, s) {
    if (this.eat(17) && (e.optional = true), this.match(10) || this.match(47)) {
      s && this.raise(m$1.ReadonlyForMethodSignature, e);
      let i = e;
      i.kind && this.match(47) && this.raise(m$1.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
      let r = "params", n = "returnType";
      if (i.kind === "get") i[r].length > 0 && (this.raise(l.BadGetterArity, this.state.curPosition()), this.isThisParam(i[r][0]) && this.raise(m$1.AccessorCannotDeclareThisParameter, this.state.curPosition()));
      else if (i.kind === "set") {
        if (i[r].length !== 1) this.raise(l.BadSetterArity, this.state.curPosition());
        else {
          let o = i[r][0];
          this.isThisParam(o) && this.raise(m$1.AccessorCannotDeclareThisParameter, this.state.curPosition()), o.type === "Identifier" && o.optional && this.raise(m$1.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), o.type === "RestElement" && this.raise(m$1.SetAccessorCannotHaveRestParameter, this.state.curPosition());
        }
        i[n] && this.raise(m$1.SetAccessorCannotHaveReturnType, i[n]);
      } else i.kind = "method";
      return this.finishNode(i, "TSMethodSignature");
    } else {
      let i = e;
      s && (i.readonly = true);
      let r = this.tsTryParseTypeAnnotation();
      return r && (i.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    let e = this.startNode();
    if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
    if (this.match(77)) {
      let i = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
    }
    this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
    let s = this.tsTryParseIndexSignature(e);
    return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
  }
  tsParseTypeLiteral() {
    let e = this.startNode();
    return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), e;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
  }
  tsParseMappedType() {
    let e = this.startNode();
    return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = true), this.expect(0), e.key = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
  }
  tsParseTupleType() {
    let e = this.startNode();
    e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let s = false;
    return e.elementTypes.forEach((i) => {
      let { type: r } = i;
      s && r !== "TSRestType" && r !== "TSOptionalType" && !(r === "TSNamedTupleMember" && i.optional) && this.raise(m$1.OptionalTypeBeforeRequired, i), s || (s = r === "TSNamedTupleMember" && i.optional || r === "TSOptionalType");
    }), this.finishNode(e, "TSTupleType");
  }
  tsParseTupleElementType() {
    let e = this.state.startLoc, s = this.eat(21), { startLoc: i } = this.state, r, n, o, h, p = M$1(this.state.type) ? this.lookaheadCharCode() : null;
    if (p === 58) r = true, o = false, n = this.parseIdentifier(true), this.expect(14), h = this.tsParseType();
    else if (p === 63) {
      o = true;
      let u = this.state.value, f2 = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (r = true, n = this.createIdentifier(this.startNodeAt(i), u), this.expect(17), this.expect(14), h = this.tsParseType()) : (r = false, h = f2, this.expect(17));
    } else h = this.tsParseType(), o = this.eat(17), r = this.eat(14);
    if (r) {
      let u;
      n ? (u = this.startNodeAt(i), u.optional = o, u.label = n, u.elementType = h, this.eat(17) && (u.optional = true, this.raise(m$1.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (u = this.startNodeAt(i), u.optional = o, this.raise(m$1.InvalidTupleMemberLabel, h), u.label = h, u.elementType = this.tsParseType()), h = this.finishNode(u, "TSNamedTupleMember");
    } else if (o) {
      let u = this.startNodeAt(i);
      u.typeAnnotation = h, h = this.finishNode(u, "TSOptionalType");
    }
    if (s) {
      let u = this.startNodeAt(e);
      u.typeAnnotation = h, h = this.finishNode(u, "TSRestType");
    }
    return h;
  }
  tsParseParenthesizedType() {
    let e = this.startNode();
    return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(e, s) {
    let i = this.startNode();
    return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
  }
  tsParseLiteralTypeNode() {
    let e = this.startNode();
    switch (this.state.type) {
      case 135:
      case 136:
      case 134:
      case 85:
      case 86:
        e.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(e, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    {
      let e = this.state.startLoc, s = this.parseTemplateElement(false), i = [s];
      if (s.tail) {
        let r = this.startNodeAt(e), n = this.startNodeAt(e);
        return n.expressions = [], n.quasis = i, r.literal = this.finishNode(n, "TemplateLiteral"), this.finishNode(r, "TSLiteralType");
      } else {
        let r = [];
        for (; !s.tail; ) r.push(this.tsParseType()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(false));
        let n = this.startNodeAt(e);
        return n.types = r, n.quasis = i, this.finishNode(n, "TSTemplateLiteralType");
      }
    }
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    let e = this.tsParseThisTypeNode();
    return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 134:
      case 135:
      case 136:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          let e = this.startNode(), s = this.lookahead();
          return s.type !== 135 && s.type !== 136 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        if (!(this.optionFlags & 1024)) {
          let e = this.state.startLoc;
          this.next();
          let s = this.tsParseType();
          return this.expect(11), this.addExtra(s, "parenthesized", true), this.addExtra(s, "parenStart", e.index), s;
        }
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        let { type: e } = this.state;
        if (S(e) || e === 88 || e === 84) {
          let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : $i$1(this.state.value);
          if (s !== void 0 && this.lookaheadCharCode() !== 46) {
            let i = this.startNode();
            return this.next(), this.finishNode(i, s);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    throw this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let { startLoc: e } = this.state, s = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
      let i = this.startNodeAt(e);
      i.elementType = s, this.expect(3), s = this.finishNode(i, "TSArrayType");
    } else {
      let i = this.startNodeAt(e);
      i.objectType = s, i.indexType = this.tsParseType(), this.expect(3), s = this.finishNode(i, "TSIndexedAccessType");
    }
    return s;
  }
  tsParseTypeOperator() {
    let e = this.startNode(), s = this.state.value;
    return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(e) {
    switch (e.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(m$1.UnexpectedReadonly, e);
    }
  }
  tsParseInferType() {
    let e = this.startNode();
    this.expectContextual(115);
    let s = this.startNode();
    return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return fi$1(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(e, s, i) {
    let r = this.startNode(), n = this.eat(i), o = [];
    do
      o.push(s());
    while (this.eat(i));
    return o.length === 1 && !n ? o[0] : (r.types = o, this.finishNode(r, e));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (S(this.state.type) || this.match(78)) return this.next(), true;
    if (this.match(5)) {
      let { errors: e } = this.state, s = e.length;
      try {
        return this.parseObjectLike(8, true), e.length === s;
      } catch {
        return false;
      }
    }
    if (this.match(0)) {
      this.next();
      let { errors: e } = this.state, s = e.length;
      try {
        return super.parseBindingList(3, 93, 1), e.length === s;
      } catch {
        return false;
      }
    }
    return false;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(e) {
    return this.tsInType(() => {
      let s = this.startNode();
      this.expect(e);
      let i = this.startNode(), r = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (r && this.match(78)) {
        let h = this.tsParseThisTypeOrThisTypePredicate();
        return h.type === "TSThisType" ? (i.parameterName = h, i.asserts = true, i.typeAnnotation = null, h = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(h, i), h.asserts = true), s.typeAnnotation = h, this.finishNode(s, "TSTypeAnnotation");
      }
      let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!n) return r ? (i.parameterName = this.parseIdentifier(), i.asserts = r, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
      let o = this.tsParseTypeAnnotation(false);
      return i.parameterName = n, i.typeAnnotation = o, i.asserts = r, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14)) return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    let e = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109) return false;
    let e = this.state.containsEsc;
    return this.next(), !S(this.state.type) && !this.match(78) ? false : (e && this.raise(l.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
  }
  tsParseTypeAnnotation(e = true, s = this.startNode()) {
    return this.tsInType(() => {
      e && this.expect(14), s.typeAnnotation = this.tsParseType();
    }), this.finishNode(s, "TSTypeAnnotation");
  }
  tsParseType() {
    Vt$1(this.state.inType);
    let e = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
    let s = this.startNodeAtNode(e);
    return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.isLookaheadContextual("new");
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(m$1.ReservedTypeAssertion, this.state.startLoc);
    let e = this.startNode();
    return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
  }
  tsParseHeritageClause(e) {
    let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
      {
        let r = super.parseExprSubscripts();
        ht(r) || this.raise(m$1.InvalidHeritageClauseType, r.loc.start, { token: e });
        let n = e === "extends" ? "TSInterfaceHeritage" : "TSClassImplements";
        if (r.type === "TSInstantiationExpression") return r.type = n, r;
        let o = this.startNodeAtNode(r);
        return o.expression = r, (this.match(47) || this.match(51)) && (o.typeArguments = this.tsParseTypeArgumentsInExpression()), this.finishNode(o, n);
      }
    });
    return i.length || this.raise(m$1.EmptyHeritageClauseType, s, { token: e }), i;
  }
  tsParseInterfaceDeclaration(e, s = {}) {
    if (this.hasFollowingLineBreak()) return null;
    this.expectContextual(129), s.declare && (e.declare = true), S(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 130)) : (e.id = null, this.raise(m$1.MissingInterfaceName, this.state.startLoc)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
    let i = this.startNode();
    return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(e) {
    return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 2), e.typeAnnotation = this.tsInType(() => {
      if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
        let s = this.startNode();
        return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
  }
  tsInTopLevelContext(e) {
    if (this.curContext() !== C$1.brace) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return e();
      } finally {
        this.state.context = s;
      }
    } else return e();
  }
  tsInType(e) {
    let s = this.state.inType;
    this.state.inType = true;
    try {
      return e();
    } finally {
      this.state.inType = s;
    }
  }
  tsInDisallowConditionalTypesContext(e) {
    let s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = true;
    try {
      return e();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsInAllowConditionalTypesContext(e) {
    let s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = false;
    try {
      return e();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsEatThenParseType(e) {
    if (this.match(e)) return this.tsNextThenParseType();
  }
  tsExpectThenParseType(e) {
    return this.tsInType(() => (this.expect(e), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    let e = this.startNode();
    return e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
  }
  tsParseEnumDeclaration(e, s = {}) {
    return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(126), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? 8971 : 8459), e.body = this.tsParseEnumBody(), this.finishNode(e, "TSEnumDeclaration");
  }
  tsParseEnumBody() {
    let e = this.startNode();
    return this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumBody");
  }
  tsParseModuleBlock() {
    let e = this.startNode();
    return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(e, s = false) {
    return e.id = this.tsParseEntityName(1), e.id.type === "Identifier" && this.checkIdentifier(e.id, 1024), this.scope.enter(1024), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit(), this.finishNode(e, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(e) {
    return this.isContextual(112) ? (e.kind = "global", e.id = this.parseIdentifier()) : this.match(134) ? (e.kind = "module", e.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(e, s, i) {
    e.id = s || this.parseIdentifier(), this.checkIdentifier(e.id, 4096), this.expect(29);
    let r = this.tsParseModuleReference();
    return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(m$1.ImportAliasHasImportType, r), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
  }
  tsParseExternalModuleReference() {
    let e = this.startNode();
    return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e, "TSExternalModuleReference");
  }
  tsLookAhead(e) {
    let s = this.state.clone(), i = e();
    return this.state = s, i;
  }
  tsTryParseAndCatch(e) {
    let s = this.tryParse((i) => e() || i());
    if (!(s.aborted || !s.node)) return s.error && (this.state = s.failState), s.node;
  }
  tsTryParse(e) {
    let s = this.state.clone(), i = e();
    if (i !== void 0 && i !== false) return i;
    this.state = s;
  }
  tsTryParseDeclare(e) {
    if (this.isLineTerminator()) return;
    let s = this.state.type;
    return this.tsInAmbientContext(() => {
      switch (s) {
        case 68:
          return e.declare = true, super.parseFunctionStatement(e, false, false);
        case 80:
          return e.declare = true, this.parseClass(e, true, false);
        case 126:
          return this.tsParseEnumDeclaration(e, { declare: true });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(e);
        case 100:
          if (this.state.containsEsc) return;
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
        case 107:
          if (this.isUsing()) return this.raise(m$1.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), e.declare = true, this.parseVarStatement(e, "using", true);
          break;
        case 96:
          if (this.isAwaitUsing()) return this.raise(m$1.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), e.declare = true, this.next(), this.parseVarStatement(e, "await using", true);
          break;
        case 129: {
          let i = this.tsParseInterfaceDeclaration(e, { declare: true });
          if (i) return i;
        }
        default:
          if (S(s)) return this.tsParseDeclaration(e, this.state.type, true, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);
  }
  tsParseDeclaration(e, s, i, r) {
    switch (s) {
      case 124:
        if (this.tsCheckLineTerminator(i) && (this.match(80) || S(this.state.type))) return this.tsParseAbstractDeclaration(e, r);
        break;
      case 127:
        if (this.tsCheckLineTerminator(i)) {
          if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e);
          if (S(this.state.type)) return e.kind = "module", this.tsParseModuleOrNamespaceDeclaration(e);
        }
        break;
      case 128:
        if (this.tsCheckLineTerminator(i) && S(this.state.type)) return e.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(e);
        break;
      case 130:
        if (this.tsCheckLineTerminator(i) && S(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
        break;
    }
  }
  tsCheckLineTerminator(e) {
    return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(e) {
    if (!this.match(47)) return;
    let s = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = true;
    let i = this.tsTryParseAndCatch(() => {
      let r = this.startNodeAt(e);
      return r.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r), r.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r;
    });
    if (this.state.maybeInArrowParameters = s, !!i) return super.parseArrowExpression(i, null, true);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    let e = this.startNode();
    return e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 ? this.raise(m$1.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === C$1.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return di$1(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
  }
  parseBindingElement(e, s) {
    let i = s.length ? s[0].loc.start : this.state.startLoc, r = {};
    this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r);
    let n = r.accessibility, o = r.override, h = r.readonly;
    !(e & 4) && (n || h || o) && this.raise(m$1.UnexpectedParameterModifier, i);
    let c2 = this.parseMaybeDefault();
    e & 2 && this.parseFunctionParamType(c2);
    let p = this.parseMaybeDefault(c2.loc.start, c2);
    if (n || h || o) {
      let u = this.startNodeAt(i);
      return s.length && (u.decorators = s), n && (u.accessibility = n), h && (u.readonly = h), o && (u.override = o), p.type !== "Identifier" && p.type !== "AssignmentPattern" && this.raise(m$1.UnsupportedParameterPropertyKind, u), u.parameter = p, this.finishNode(u, "TSParameterProperty");
    }
    return s.length && (c2.decorators = s), p;
  }
  isSimpleParameter(e) {
    return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
  }
  tsDisallowOptionalPattern(e) {
    for (let s of e.params) s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(m$1.PatternIsOptional, s);
  }
  setArrowFunctionParameters(e, s, i) {
    super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
  }
  parseFunctionBodyAndFinish(e, s, i = false) {
    this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    let r = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return r && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, r) : r === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(m$1.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, r, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
  }
  registerFunctionStatementId(e) {
    !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
  }
  tsCheckForInvalidTypeCasts(e) {
    e.forEach((s) => {
      s?.type === "TSTypeCastExpression" && this.raise(m$1.UnexpectedTypeAnnotation, s.typeAnnotation);
    });
  }
  toReferencedList(e, s) {
    return this.tsCheckForInvalidTypeCasts(e), e;
  }
  parseArrayLike(e, s, i) {
    let r = super.parseArrayLike(e, s, i);
    return r.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(r.elements), r;
  }
  parseSubscript(e, s, i, r) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = false, this.next();
      let o = this.startNodeAt(s);
      return o.expression = e, this.finishNode(o, "TSNonNullExpression");
    }
    let n = false;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (i) return r.stop = true, e;
      r.optionalChainMember = n = true, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let o, h = this.tsTryParseAndCatch(() => {
        if (!i && this.atPossibleAsyncArrow(e)) {
          let f2 = this.tsTryParseGenericAsyncArrowFunction(s);
          if (f2) return r.stop = true, f2;
        }
        let c2 = this.tsParseTypeArgumentsInExpression();
        if (!c2) return;
        if (n && !this.match(10)) {
          o = this.state.curPosition();
          return;
        }
        if (ze$1(this.state.type)) {
          let f2 = super.parseTaggedTemplateExpression(e, s, r);
          return f2.typeArguments = c2, f2;
        }
        if (!i && this.eat(10)) {
          let f2 = this.startNodeAt(s);
          return f2.callee = e, f2.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(f2.arguments), f2.typeArguments = c2, r.optionalChainMember && (f2.optional = n), this.finishCallExpression(f2, r.optionalChainMember);
        }
        let p = this.state.type;
        if (p === 48 || p === 52 || p !== 10 && he$1(p) && !this.hasPrecedingLineBreak()) return;
        let u = this.startNodeAt(s);
        return u.expression = e, u.typeArguments = c2, this.finishNode(u, "TSInstantiationExpression");
      });
      if (o && this.unexpected(o, 10), h) return h.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(m$1.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (h.expression = super.stopParseSubscript(e, r))), h;
    }
    return super.parseSubscript(e, s, i, r);
  }
  parseNewCallee(e) {
    super.parseNewCallee(e);
    let { callee: s } = e;
    s.type === "TSInstantiationExpression" && !s.extra?.parenthesized && (e.typeArguments = s.typeArguments, e.callee = s.expression);
  }
  parseExprOp(e, s, i) {
    let r;
    if (be(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r = this.isContextual(120)))) {
      let n = this.startNodeAt(s);
      return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r && this.raise(l.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, r ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
    }
    return super.parseExprOp(e, s, i);
  }
  checkReservedWord(e, s, i, r) {
    this.state.isAmbientContext || super.checkReservedWord(e, s, i, r);
  }
  checkImportReflection(e) {
    super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(m$1.ImportReflectionHasImportType, e.specifiers[0].loc.start);
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(e) {
    if (super.isPotentialImportPhase(e)) return true;
    if (this.isContextual(130)) {
      let s = this.lookaheadCharCode();
      return e ? s === 123 || s === 42 : s !== 61;
    }
    return !e && this.isContextual(87);
  }
  applyImportPhase(e, s, i, r) {
    super.applyImportPhase(e, s, i, r), s ? e.exportKind = i === "type" ? "type" : "value" : e.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImport(e) {
    if (this.match(134)) return e.importKind = "value", super.parseImport(e);
    let s;
    if (S(this.state.type) && this.lookaheadCharCode() === 61) return e.importKind = "value", this.tsParseImportEqualsDeclaration(e);
    if (this.isContextual(130)) {
      let i = this.parseMaybeImportPhase(e, false);
      if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(e, i);
      s = super.parseImportSpecifiersAndAfter(e, i);
    } else s = super.parseImport(e);
    return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(m$1.TypeImportCannotSpecifyDefaultAndNamed, s), s;
  }
  parseExport(e, s) {
    if (this.match(83)) {
      let i = this.startNode();
      this.next();
      let r = null;
      this.isContextual(130) && this.isPotentialImportPhase(false) ? r = this.parseMaybeImportPhase(i, false) : i.importKind = "value";
      let n = this.tsParseImportEqualsDeclaration(i, r, true);
      return e.attributes = [], e.declaration = n, e.exportKind = "value", e.source = null, e.specifiers = [], this.finishNode(e, "ExportNamedDeclaration");
    } else if (this.eat(29)) {
      let i = e;
      return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(i, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      let i = e;
      return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
    } else return super.parseExport(e, s);
  }
  isAbstractClass() {
    return this.isContextual(124) && this.isLookaheadContextual("class");
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      let e = this.startNode();
      return this.next(), e.abstract = true, this.parseClass(e, true, true);
    }
    if (this.match(129)) {
      let e = this.tsParseInterfaceDeclaration(this.startNode());
      if (e) return e;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(e, s, i = false) {
    let { isAmbientContext: r } = this.state, n = super.parseVarStatement(e, s, i || r);
    if (!r) return n;
    if (!e.declare && (s === "using" || s === "await using")) return this.raiseOverwrite(m$1.UsingDeclarationInAmbientContext, e, s), n;
    for (let { id: o, init: h } of n.declarations) h && (s === "var" || s === "let" || o.typeAnnotation ? this.raise(m$1.InitializerNotAllowedInAmbientContext, h) : Ji$1(h, this.hasPlugin("estree")) || this.raise(m$1.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, h));
    return n;
  }
  parseStatementContent(e, s) {
    if (!this.state.containsEsc) switch (this.state.type) {
      case 75: {
        if (this.isLookaheadContextual("enum")) {
          let i = this.startNode();
          return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
        }
        break;
      }
      case 124:
      case 125: {
        if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
          let i = this.state.type, r = this.startNode();
          this.next();
          let n = i === 125 ? this.tsTryParseDeclare(r) : this.tsParseAbstractDeclaration(r, s);
          return n ? (i === 125 && (n.declare = true), n) : (r.expression = this.createIdentifier(this.startNodeAt(r.loc.start), i === 125 ? "declare" : "abstract"), this.semicolon(false), this.finishNode(r, "ExpressionStatement"));
        }
        break;
      }
      case 126:
        return this.tsParseEnumDeclaration(this.startNode());
      case 112: {
        if (this.lookaheadCharCode() === 123) {
          let r = this.startNode();
          return this.tsParseAmbientExternalModuleDeclaration(r);
        }
        break;
      }
      case 129: {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
        break;
      }
      case 127: {
        if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
          let i = this.startNode();
          return this.next(), this.tsParseDeclaration(i, 127, false, s);
        }
        break;
      }
      case 128: {
        if (this.nextTokenIsIdentifierOnSameLine()) {
          let i = this.startNode();
          return this.next(), this.tsParseDeclaration(i, 128, false, s);
        }
        break;
      }
      case 130: {
        if (this.nextTokenIsIdentifierOnSameLine()) {
          let i = this.startNode();
          return this.next(), this.tsParseTypeAliasDeclaration(i);
        }
        break;
      }
    }
    return super.parseStatementContent(e, s);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(e, s) {
    return s.some((i) => zt$1(i) ? e.accessibility === i : !!e[i]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(e, s, i) {
    let r = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({ allowedModifiers: r, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: m$1.InvalidModifierOnTypeParameterPositions }, s);
    let n = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, r) && this.raise(m$1.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
    };
    s.declare ? this.tsInAmbientContext(n) : n();
  }
  parseClassMemberWithIsStatic(e, s, i, r) {
    let n = this.tsTryParseIndexSignature(s);
    if (n) {
      e.body.push(n), s.abstract && this.raise(m$1.IndexSignatureHasAbstract, s), s.accessibility && this.raise(m$1.IndexSignatureHasAccessibility, s, { modifier: s.accessibility }), s.declare && this.raise(m$1.IndexSignatureHasDeclare, s), s.override && this.raise(m$1.IndexSignatureHasOverride, s);
      return;
    }
    !this.state.inAbstractClass && s.abstract && this.raise(m$1.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(m$1.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(e, s, i, r);
  }
  parsePostMemberNameModifiers(e) {
    this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(m$1.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(m$1.ClassMethodHasDeclare, e);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
  }
  parseConditional(e, s, i) {
    if (!this.match(17)) return e;
    if (this.state.maybeInArrowParameters) {
      let r = this.lookaheadCharCode();
      if (r === 44 || r === 61 || r === 58 || r === 41) return this.setOptionalParametersError(i), e;
    }
    return super.parseConditional(e, s, i);
  }
  parseParenItem(e, s) {
    let i = super.parseParenItem(e, s);
    if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
      let r = this.startNodeAt(s);
      return r.expression = e, r.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r, "TSTypeCastExpression");
    }
    return e;
  }
  parseExportDeclaration(e) {
    if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
    let s = this.state.startLoc, i = this.eatContextual(125);
    if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(m$1.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
    let n = S(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
    return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && n.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(n, s), n.declare = true), n) : null;
  }
  parseClassId(e, s, i, r) {
    if ((!s || i) && this.isContextual(113)) return;
    super.parseClassId(e, s, i, e.declare ? 1024 : 8331);
    let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    n && (e.typeParameters = n);
  }
  parseClassPropertyAnnotation(e) {
    e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
    let s = this.tsTryParseTypeAnnotation();
    s && (e.typeAnnotation = s);
  }
  parseClassProperty(e) {
    if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(m$1.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29)) {
      let { key: s } = e;
      this.raise(m$1.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(this.offsetToSourcePos(s.start), this.offsetToSourcePos(s.end))}]` });
    }
    return super.parseClassProperty(e);
  }
  parseClassPrivateProperty(e) {
    return e.abstract && this.raise(m$1.PrivateElementHasAbstract, e), e.accessibility && this.raise(m$1.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
  }
  parseClassAccessorProperty(e) {
    return this.parseClassPropertyAnnotation(e), e.optional && this.raise(m$1.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
  }
  pushClassMethod(e, s, i, r, n, o) {
    let h = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    h && n && this.raise(m$1.ConstructorHasTypeParameters, h);
    let { declare: c2 = false, kind: p } = s;
    c2 && (p === "get" || p === "set") && this.raise(m$1.DeclareAccessor, s, { kind: p }), h && (s.typeParameters = h), super.pushClassMethod(e, s, i, r, n, o);
  }
  pushClassPrivateMethod(e, s, i, r) {
    let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, r);
  }
  declareClassPrivateMethodInScope(e, s) {
    e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && e.value.body == null || super.declareClassPrivateMethodInScope(e, s));
  }
  parseClassSuper(e) {
    super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(e, s, i, r, n, o, h) {
    let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return c2 && (e.typeParameters = c2), super.parseObjPropValue(e, s, i, r, n, o, h);
  }
  parseFunctionParams(e, s) {
    let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    i && (e.typeParameters = i), super.parseFunctionParams(e, s);
  }
  parseVarId(e, s) {
    super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
    let i = this.tsTryParseTypeAnnotation();
    i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
  }
  parseAsyncArrowFromCallExpression(e, s) {
    return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
  }
  parseMaybeAssign(e, s) {
    let i, r, n;
    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
      if (i = this.state.clone(), r = this.tryParse(() => super.parseMaybeAssign(e, s), i), !r.error) return r.node;
      let { context: c2 } = this.state, p = c2[c2.length - 1];
      (p === C$1.j_oTag || p === C$1.j_expr) && c2.pop();
    }
    if (!r?.error && !this.match(47)) return super.parseMaybeAssign(e, s);
    (!i || i === this.state) && (i = this.state.clone());
    let o, h = this.tryParse((c2) => {
      o = this.tsParseTypeParameters(this.tsParseConstModifier);
      let p = super.parseMaybeAssign(e, s);
      if ((p.type !== "ArrowFunctionExpression" || p.extra?.parenthesized) && c2(), o?.params.length !== 0 && this.resetStartLocationFromNode(p, o), p.typeParameters = o, this.hasPlugin("jsx") && p.typeParameters.params.length === 1 && !p.typeParameters.extra?.trailingComma) {
        let u = p.typeParameters.params[0];
        u.constraint || this.raise(m$1.SingleTypeParameterWithoutTrailingComma, L(u.loc.end, 1), { typeParameterName: u.name.name });
      }
      return p;
    }, i);
    if (!h.error && !h.aborted) return o && this.reportReservedArrowTypeParam(o), h.node;
    if (!r && (Vt$1(!this.hasPlugin("jsx")), n = this.tryParse(() => super.parseMaybeAssign(e, s), i), !n.error)) return n.node;
    if (r?.node) return this.state = r.failState, r.node;
    if (h.node) return this.state = h.failState, o && this.reportReservedArrowTypeParam(o), h.node;
    if (n?.node) return this.state = n.failState, n.node;
    throw r?.error || h.error || n?.error;
  }
  reportReservedArrowTypeParam(e) {
    e.params.length === 1 && !e.params[0].constraint && !e.extra?.trailingComma && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(m$1.ReservedArrowTypeParam, e);
  }
  parseMaybeUnary(e, s) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
  }
  parseArrow(e) {
    if (this.match(14)) {
      let s = this.tryParse((i) => {
        let r = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && i(), r;
      });
      if (s.aborted) return;
      s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
    }
    return super.parseArrow(e);
  }
  parseFunctionParamType(e) {
    this.eat(17) && (e.optional = true);
    let s = this.tsTryParseTypeAnnotation();
    return s && (e.typeAnnotation = s), this.resetEndLocation(e), e;
  }
  isAssignable(e, s) {
    switch (e.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(e.expression, s);
      case "TSParameterProperty":
        return true;
      default:
        return super.isAssignable(e, s);
    }
  }
  toAssignable(e, s = false) {
    switch (e.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(e, s);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        s ? this.expressionScope.recordArrowParameterBindingError(m$1.UnexpectedTypeCastInParameter, e) : this.raise(m$1.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, s);
        break;
      case "AssignmentExpression":
        !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
      default:
        super.toAssignable(e, s);
    }
  }
  toAssignableParenthesizedExpression(e, s) {
    switch (e.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, s);
        break;
      default:
        super.toAssignable(e, s);
    }
  }
  checkToRestConversion(e, s) {
    switch (e.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(e.expression, false);
        break;
      default:
        super.checkToRestConversion(e, s);
    }
  }
  isValidLVal(e, s, i, r) {
    switch (e) {
      case "TSTypeCastExpression":
        return true;
      case "TSParameterProperty":
        return "parameter";
      case "TSNonNullExpression":
        return "expression";
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
        return (r !== 64 || !i) && ["expression", true];
      default:
        return super.isValidLVal(e, s, i, r);
    }
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(e, s) {
    if (this.match(47) || this.match(51)) {
      let i = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        let r = super.parseMaybeDecoratorArguments(e, s);
        return r.typeArguments = i, r;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(e, s);
  }
  checkCommaAfterRest(e) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(e, s) {
    let i = super.parseMaybeDefault(e, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(m$1.TypeAnnotationAfterAssign, i.typeAnnotation), i;
  }
  getTokenFromCode(e) {
    if (this.state.inType) {
      if (e === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (e === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(e);
  }
  reScan_lt_gt() {
    let { type: e } = this.state;
    e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    let { type: e } = this.state;
    return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
  }
  toAssignableListItem(e, s, i) {
    let r = e[s];
    r.type === "TSTypeCastExpression" && (e[s] = this.typeCastToParameter(r)), super.toAssignableListItem(e, s, i);
  }
  typeCastToParameter(e) {
    return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
  }
  shouldParseArrow(e) {
    return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(e) {
    if (this.match(47) || this.match(51)) {
      let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      s && (e.typeArguments = s);
    }
    return super.jsxParseOpeningElementAfterName(e);
  }
  getGetterSetterExpectedParamCount(e) {
    let s = super.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e)[0];
    return r && this.isThisParam(r) ? s + 1 : s;
  }
  parseCatchClauseParam() {
    let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
    return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
  }
  tsInAmbientContext(e) {
    let { isAmbientContext: s, strict: i } = this.state;
    this.state.isAmbientContext = true, this.state.strict = false;
    try {
      return e();
    } finally {
      this.state.isAmbientContext = s, this.state.strict = i;
    }
  }
  parseClass(e, s, i) {
    let r = this.state.inAbstractClass;
    this.state.inAbstractClass = !!e.abstract;
    try {
      return super.parseClass(e, s, i);
    } finally {
      this.state.inAbstractClass = r;
    }
  }
  tsParseAbstractDeclaration(e, s) {
    if (this.match(80)) return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
    if (this.isContextual(129)) return this.hasFollowingLineBreak() ? null : (e.abstract = true, this.raise(m$1.NonClassMethodPropertyHasAbstractModifier, e), this.tsParseInterfaceDeclaration(e));
    throw this.unexpected(null, 80);
  }
  parseMethod(e, s, i, r, n, o, h) {
    let c2 = super.parseMethod(e, s, i, r, n, o, h);
    if ((c2.abstract || c2.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? c2.value : c2).body) {
      let { key: f2 } = c2;
      this.raise(m$1.AbstractMethodHasImplementation, c2, { methodName: f2.type === "Identifier" && !c2.computed ? f2.name : `[${this.input.slice(this.offsetToSourcePos(f2.start), this.offsetToSourcePos(f2.end))}]` });
    }
    return c2;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier();
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
  }
  parseExportSpecifier(e, s, i, r) {
    return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, r));
  }
  parseImportSpecifier(e, s, i, r, n) {
    return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, r, i ? 4098 : 4096));
  }
  parseTypeOnlyImportExportSpecifier(e, s, i) {
    let r = s ? "imported" : "local", n = s ? "local" : "exported", o = e[r], h, c2 = false, p = true, u = o.loc.start;
    if (this.isContextual(93)) {
      let y2 = this.parseIdentifier();
      if (this.isContextual(93)) {
        let b2 = this.parseIdentifier();
        M$1(this.state.type) ? (c2 = true, o = y2, h = s ? this.parseIdentifier() : this.parseModuleExportName(), p = false) : (h = b2, p = false);
      } else M$1(this.state.type) ? (p = false, h = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o = y2);
    } else M$1(this.state.type) && (c2 = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
    c2 && i && this.raise(s ? m$1.TypeModifierIsUsedInTypeImports : m$1.TypeModifierIsUsedInTypeExports, u), e[r] = o, e[n] = h;
    let f2 = s ? "importKind" : "exportKind";
    e[f2] = c2 ? "type" : "value", p && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = this.cloneIdentifier(e[r])), s && this.checkIdentifier(e[n], c2 ? 4098 : 4096);
  }
  fillOptionalPropertiesForTSESLint(e) {
    switch (e.type) {
      case "ExpressionStatement":
        e.directive ?? (e.directive = void 0);
        return;
      case "RestElement":
        e.value = void 0;
      case "Identifier":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "ObjectPattern":
        e.decorators ?? (e.decorators = []), e.optional ?? (e.optional = false), e.typeAnnotation ?? (e.typeAnnotation = void 0);
        return;
      case "TSParameterProperty":
        e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = false), e.readonly ?? (e.readonly = false), e.static ?? (e.static = false);
        return;
      case "TSEmptyBodyFunctionExpression":
        e.body = null;
      case "TSDeclareFunction":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        e.declare ?? (e.declare = false), e.returnType ?? (e.returnType = void 0), e.typeParameters ?? (e.typeParameters = void 0);
        return;
      case "Property":
        e.optional ?? (e.optional = false);
        return;
      case "TSMethodSignature":
      case "TSPropertySignature":
        e.optional ?? (e.optional = false);
      case "TSIndexSignature":
        e.accessibility ?? (e.accessibility = void 0), e.readonly ?? (e.readonly = false), e.static ?? (e.static = false);
        return;
      case "TSAbstractPropertyDefinition":
      case "PropertyDefinition":
      case "TSAbstractAccessorProperty":
      case "AccessorProperty":
        e.declare ?? (e.declare = false), e.definite ?? (e.definite = false), e.readonly ?? (e.readonly = false), e.typeAnnotation ?? (e.typeAnnotation = void 0);
      case "TSAbstractMethodDefinition":
      case "MethodDefinition":
        e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = false), e.optional ?? (e.optional = false);
        return;
      case "ClassExpression":
        e.id ?? (e.id = null);
      case "ClassDeclaration":
        e.abstract ?? (e.abstract = false), e.declare ?? (e.declare = false), e.decorators ?? (e.decorators = []), e.implements ?? (e.implements = []), e.superTypeArguments ?? (e.superTypeArguments = void 0), e.typeParameters ?? (e.typeParameters = void 0);
        return;
      case "TSTypeAliasDeclaration":
      case "VariableDeclaration":
        e.declare ?? (e.declare = false);
        return;
      case "VariableDeclarator":
        e.definite ?? (e.definite = false);
        return;
      case "TSEnumDeclaration":
        e.const ?? (e.const = false), e.declare ?? (e.declare = false);
        return;
      case "TSEnumMember":
        e.computed ?? (e.computed = false);
        return;
      case "TSImportType":
        e.qualifier ?? (e.qualifier = null), e.options ?? (e.options = null), e.typeArguments ?? (e.typeArguments = null);
        return;
      case "TSInterfaceDeclaration":
        e.declare ?? (e.declare = false), e.extends ?? (e.extends = []);
        return;
      case "TSMappedType":
        e.optional ?? (e.optional = false), e.readonly ?? (e.readonly = void 0);
        return;
      case "TSModuleDeclaration":
        e.declare ?? (e.declare = false), e.global ?? (e.global = e.kind === "global");
        return;
      case "TSTypeParameter":
        e.const ?? (e.const = false), e.in ?? (e.in = false), e.out ?? (e.out = false);
        return;
    }
  }
  chStartsBindingIdentifierAndNotRelationalOperator(e, s) {
    if (F(e)) {
      if (_e$1.lastIndex = s, _e$1.test(this.input)) {
        let i = this.codePointAtPos(_e$1.lastIndex);
        if (!$$1(i) && i !== 92) return false;
      }
      return true;
    } else return e === 92;
  }
  nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
    let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
    return this.chStartsBindingIdentifierAndNotRelationalOperator(s, e);
  }
  nextTokenIsIdentifierOrStringLiteralOnSameLine() {
    let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
    return this.chStartsBindingIdentifier(s, e) || s === 34 || s === 39;
  }
};
function Wi$1(a2) {
  if (a2.type !== "MemberExpression") return false;
  let { computed: t, property: e } = a2;
  return t && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : ns$1(a2.object);
}
function Ji$1(a2, t) {
  let { type: e } = a2;
  if (a2.extra?.parenthesized) return false;
  if (t) {
    if (e === "Literal") {
      let { value: s } = a2;
      if (typeof s == "string" || typeof s == "boolean") return true;
    }
  } else if (e === "StringLiteral" || e === "BooleanLiteral") return true;
  return !!(as$1(a2, t) || Gi$1(a2, t) || e === "TemplateLiteral" && a2.expressions.length === 0 || Wi$1(a2));
}
function as$1(a2, t) {
  return t ? a2.type === "Literal" && (typeof a2.value == "number" || "bigint" in a2) : a2.type === "NumericLiteral" || a2.type === "BigIntLiteral";
}
function Gi$1(a2, t) {
  if (a2.type === "UnaryExpression") {
    let { operator: e, argument: s } = a2;
    if (e === "-" && as$1(s, t)) return true;
  }
  return false;
}
function ns$1(a2) {
  return a2.type === "Identifier" ? true : a2.type !== "MemberExpression" || a2.computed ? false : ns$1(a2.object);
}
var qt$1 = O$1`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), Xi$1 = (a2) => class extends a2 {
  parsePlaceholder(e) {
    if (this.match(133)) {
      let s = this.startNode();
      return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(s, e);
    }
  }
  finishPlaceholder(e, s) {
    let i = e;
    return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
  }
  getTokenFromCode(e) {
    e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(e);
  }
  parseExprAtom(e) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
  }
  parseIdentifier(e) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
  }
  checkReservedWord(e, s, i, r) {
    e !== void 0 && super.checkReservedWord(e, s, i, r);
  }
  cloneIdentifier(e) {
    let s = super.cloneIdentifier(e);
    return s.type === "Placeholder" && (s.expectedNode = e.expectedNode), s;
  }
  cloneStringLiteral(e) {
    return e.type === "Placeholder" ? this.cloneIdentifier(e) : super.cloneStringLiteral(e);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(e, s, i, r) {
    return e === "Placeholder" || super.isValidLVal(e, s, i, r);
  }
  toAssignable(e, s) {
    e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
  }
  chStartsBindingIdentifier(e, s) {
    if (super.chStartsBindingIdentifier(e, s)) return true;
    let i = this.nextTokenStart();
    return this.input.charCodeAt(i) === 37 && this.input.charCodeAt(i + 1) === 37;
  }
  verifyBreakContinue(e, s) {
    e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
  }
  parseExpressionStatement(e, s) {
    if (s.type !== "Placeholder" || s.extra?.parenthesized) return super.parseExpressionStatement(e, s);
    if (this.match(14)) {
      let r = e;
      return r.label = this.finishPlaceholder(s, "Identifier"), this.next(), r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r, "LabeledStatement");
    }
    this.semicolon();
    let i = e;
    return i.name = s.name, this.finishPlaceholder(i, "Statement");
  }
  parseBlock(e, s, i) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
  }
  parseFunctionId(e) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
  }
  parseClass(e, s, i) {
    let r = s ? "ClassDeclaration" : "ClassExpression";
    this.next();
    let n = this.state.strict, o = this.parsePlaceholder("Identifier");
    if (o) if (this.match(81) || this.match(133) || this.match(5)) e.id = o;
    else {
      if (i || !s) return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, r);
      throw this.raise(qt$1.ClassNameIsRequired, this.state.startLoc);
    }
    else this.parseClassId(e, s, i);
    return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, r);
  }
  parseExport(e, s) {
    let i = this.parsePlaceholder("Identifier");
    if (!i) return super.parseExport(e, s);
    let r = e;
    if (!this.isContextual(98) && !this.match(12)) return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    let n = this.startNode();
    return n.exported = i, r.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], super.parseExport(r, s);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      let e = this.nextTokenStart();
      if (this.isUnparsedContextual(e, "from") && this.input.startsWith(V$1(133), this.nextTokenStartSince(e + 4))) return true;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(e, s) {
    return e.specifiers?.length ? true : super.maybeParseExportDefaultSpecifier(e, s);
  }
  checkExport(e) {
    let { specifiers: s } = e;
    s?.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
  }
  parseImport(e) {
    let s = this.parsePlaceholder("Identifier");
    if (!s) return super.parseImport(e);
    if (e.specifiers = [], !this.isContextual(98) && !this.match(12)) return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    let i = this.startNodeAtNode(s);
    return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(qt$1.UnexpectedSpace, this.state.lastTokEndLoc);
  }
}, Yi$1 = (a2) => class extends a2 {
  parseV8Intrinsic() {
    if (this.match(54)) {
      let e = this.state.startLoc, s = this.startNode();
      if (this.next(), S(this.state.type)) {
        let i = this.parseIdentifierName(), r = this.createIdentifier(s, i);
        if (this.castNodeTo(r, "V8IntrinsicIdentifier"), this.match(10)) return r;
      }
      this.unexpected(e);
    }
  }
  parseExprAtom(e) {
    return this.parseV8Intrinsic() || super.parseExprAtom(e);
  }
}, $t$1 = ["fsharp", "hack"], Ht$1 = ["^^", "@@", "^", "%", "#"];
function Qi$1(a2) {
  if (a2.has("decorators")) {
    if (a2.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    let t = a2.get("decorators").decoratorsBeforeExport;
    if (t != null && typeof t != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    let e = a2.get("decorators").allowCallParenthesized;
    if (e != null && typeof e != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (a2.has("flow") && a2.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
  if (a2.has("placeholders") && a2.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (a2.has("pipelineOperator")) {
    let t = a2.get("pipelineOperator").proposal;
    if (!$t$1.includes(t)) {
      let e = $t$1.map((s) => `"${s}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
    }
    if (t === "hack") {
      if (a2.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (a2.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      let e = a2.get("pipelineOperator").topicToken;
      if (!Ht$1.includes(e)) {
        let s = Ht$1.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${s}.`);
      }
    }
  }
  if (a2.has("moduleAttributes")) throw new Error("`moduleAttributes` has been removed in Babel 8, please migrate to import attributes instead.");
  if (a2.has("importAssertions")) throw new Error("`importAssertions` has been removed in Babel 8, please use import attributes instead. To use the non-standard `assert` syntax you can enable the `deprecatedImportAssert` parser plugin.");
  if (!a2.has("deprecatedImportAssert") && a2.has("importAttributes") && a2.get("importAttributes").deprecatedAssertSyntax) throw new Error("The 'importAttributes' plugin has been removed in Babel 8. If you need to enable support for the deprecated `assert` syntax, you can enable the `deprecatedImportAssert` parser plugin.");
  if (a2.has("recordAndTuple")) throw new Error("The 'recordAndTuple' plugin has been removed in Babel 8. Please remove it from your configuration.");
  if (a2.has("asyncDoExpressions") && !a2.has("doExpressions")) {
    let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw t.missingPlugins = "doExpressions", t;
  }
  if (a2.has("optionalChainingAssign") && a2.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  if (a2.has("discardBinding") && a2.get("discardBinding").syntaxType !== "void") throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
  {
    if (a2.has("decimal")) throw new Error("The 'decimal' plugin has been removed in Babel 8. Please remove it from your configuration.");
    if (a2.has("importReflection")) throw new Error("The 'importReflection' plugin has been removed in Babel 8. Use 'sourcePhaseImports' instead, and replace 'import module' with 'import source' in your code.");
  }
}
var os$1 = { estree: ii$1, jsx: Oi$1, flow: Li, typescript: Ki$1, v8intrinsic: Yi$1, placeholders: Xi$1 }, Zi$1 = Object.keys(os$1), ct$1 = class ct extends ot$1 {
  checkProto(t, e, s, i) {
    if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return s;
    let r = t.key;
    return (r.type === "Identifier" ? r.name : r.value) === "__proto__" ? e ? (this.raise(l.RecordNoProto, r), true) : (s && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = r.loc.start) : this.raise(l.DuplicateProto, r)), true) : s;
  }
  shouldExitDescending(t, e) {
    return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === e;
  }
  getExpression() {
    if (this.enterInitialScopes(), this.nextToken(), this.match(140)) throw this.raise(l.ParseExpressionEmptyInput, this.state.startLoc);
    let t = this.parseExpression();
    if (!this.match(140)) throw this.raise(l.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
    return this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.optionFlags & 256 && (t.tokens = this.tokens), t;
  }
  parseExpression(t, e) {
    return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
  }
  parseExpressionBase(t) {
    let e = this.state.startLoc, s = this.parseMaybeAssign(t);
    if (this.match(12)) {
      let i = this.startNodeAt(e);
      for (i.expressions = [s]; this.eat(12); ) i.expressions.push(this.parseMaybeAssign(t));
      return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
    }
    return s;
  }
  parseMaybeAssignDisallowIn(t, e) {
    return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
  }
  parseMaybeAssignAllowIn(t, e) {
    return this.allowInAnd(() => this.parseMaybeAssign(t, e));
  }
  setOptionalParametersError(t) {
    t.optionalParametersLoc = this.state.startLoc;
  }
  parseMaybeAssign(t, e) {
    let s = this.state.startLoc, i = this.isContextual(108);
    if (i && this.prodParam.hasYield) {
      this.next();
      let h = this.parseYield(s);
      return e && (h = e.call(this, h, s)), h;
    }
    let r;
    t ? r = false : (t = new X$1(), r = true);
    let { type: n } = this.state;
    (n === 10 || S(n)) && (this.state.potentialArrowAt = this.state.start);
    let o = this.parseMaybeConditional(t);
    if (e && (o = e.call(this, o, s)), hi$1(this.state.type)) {
      let h = this.startNodeAt(s), c2 = this.state.value;
      if (h.operator = c2, this.match(29)) {
        this.toAssignable(o, true), h.left = o;
        let p = s.index;
        t.doubleProtoLoc != null && t.doubleProtoLoc.index >= p && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= p && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null), t.voidPatternLoc != null && t.voidPatternLoc.index >= p && (t.voidPatternLoc = null);
      } else h.left = o;
      return this.next(), h.right = this.parseMaybeAssign(), this.checkLVal(o, this.finishNode(h, "AssignmentExpression"), void 0, void 0, void 0, void 0, c2 === "||=" || c2 === "&&=" || c2 === "??="), h;
    } else r && this.checkExpressionErrors(t, true);
    if (i) {
      let { type: h } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? he$1(h) : he$1(h) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(l.YieldNotInGeneratorFunction, s), this.parseYield(s);
    }
    return o;
  }
  parseMaybeConditional(t) {
    let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(t);
    return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, e, t);
  }
  parseConditional(t, e, s) {
    if (this.eat(17)) {
      let i = this.startNodeAt(e);
      return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
    }
    return t;
  }
  parseMaybeUnaryOrPrivate(t) {
    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
  }
  parseExprOps(t) {
    let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
    return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, e, -1);
  }
  parseExprOp(t, e, s) {
    if (this.isPrivateName(t)) {
      let r = this.getPrivateNameSV(t);
      (s >= be(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(l.PrivateInExpectedIn, t, { identifierName: r }), this.classScope.usePrivateName(r, t.loc.start);
    }
    let i = this.state.type;
    if (li$1(i) && (this.prodParam.hasIn || !this.match(58))) {
      let r = be(i);
      if (r > s) {
        if (i === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
          this.checkPipelineAtInfixOperator(t, e);
        }
        let n = this.startNodeAt(e);
        n.left = t, n.operator = this.state.value;
        let o = i === 41 || i === 42, h = i === 40;
        h && (r = be(42)), this.next(), n.right = this.parseExprOpRightExpr(i, r);
        let c2 = this.finishNode(n, o || h ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
        if (h && (p === 41 || p === 42) || o && p === 40) throw this.raise(l.MixingCoalesceWithLogical, this.state.startLoc);
        return this.parseExprOp(c2, e, s);
      }
    }
    return t;
  }
  parseExprOpRightExpr(t, e) {
    switch (this.state.startLoc, t) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
        }
      default:
        return this.parseExprOpBaseRightExpr(t, e);
    }
  }
  parseExprOpBaseRightExpr(t, e) {
    let s = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, mi$1(t) ? e - 1 : e);
  }
  parseHackPipeBody() {
    let { startLoc: t } = this.state, e = this.parseMaybeAssign();
    return Xs.has(e.type) && !e.extra?.parenthesized && this.raise(l.PipeUnparenthesizedBody, t, { type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipeTopicUnused, t), e;
  }
  checkExponentialAfterUnary(t) {
    this.match(57) && this.raise(l.UnexpectedTokenUnaryExponentiation, t.argument);
  }
  parseMaybeUnary(t, e) {
    let s = this.state.startLoc, i = this.isContextual(96);
    if (i && this.recordAwaitIfAllowed()) {
      this.next();
      let h = this.parseAwait(s);
      return e || this.checkExponentialAfterUnary(h), h;
    }
    let r = this.match(34), n = this.startNode();
    if (ui$1(this.state.type)) {
      n.operator = this.state.value, n.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
      let h = this.match(89);
      if (this.next(), n.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && h) {
        let c2 = n.argument;
        c2.type === "Identifier" ? this.raise(l.StrictDelete, n) : this.hasPropertyAsPrivateName(c2) && this.raise(l.DeletePrivateField, n);
      }
      if (!r) return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
    }
    let o = this.parseUpdate(n, r, t);
    if (i) {
      let { type: h } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? he$1(h) : he$1(h) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(l.AwaitNotInAsyncContext, s), this.parseAwait(s);
    }
    return o;
  }
  parseUpdate(t, e, s) {
    if (e) {
      let n = t;
      return this.checkLVal(n.argument, this.finishNode(n, "UpdateExpression")), t;
    }
    let i = this.state.startLoc, r = this.parseExprSubscripts(s);
    if (this.checkExpressionErrors(s, false)) return r;
    for (; pi$1(this.state.type) && !this.canInsertSemicolon(); ) {
      let n = this.startNodeAt(i);
      n.operator = this.state.value, n.prefix = false, n.argument = r, this.next(), this.checkLVal(r, r = this.finishNode(n, "UpdateExpression"));
    }
    return r;
  }
  parseExprSubscripts(t) {
    let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(t);
    return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, e);
  }
  parseSubscripts(t, e, s) {
    let i = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
    do
      t = this.parseSubscript(t, e, s, i), i.maybeAsyncArrow = false;
    while (!i.stop);
    return t;
  }
  parseSubscript(t, e, s, i) {
    let { type: r } = this.state;
    if (!s && r === 15) return this.parseBind(t, e, s, i);
    if (ze$1(r)) return this.parseTaggedTemplateExpression(t, e, i);
    let n = false;
    if (r === 18) {
      if (s && (this.raise(l.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return this.stopParseSubscript(t, i);
      i.optionalChainMember = n = true, this.next();
    }
    if (!s && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, e, i, n);
    {
      let o = this.eat(0);
      return o || n || this.eat(16) ? this.parseMember(t, e, i, o, n) : this.stopParseSubscript(t, i);
    }
  }
  stopParseSubscript(t, e) {
    return e.stop = true, t;
  }
  parseMember(t, e, s, i, r) {
    let n = this.startNodeAt(e);
    return n.object = t, n.computed = i, i ? (n.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" && this.raise(l.SuperPrivateField, e), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(true), s.optionalChainMember ? (n.optional = r, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
  }
  parseBind(t, e, s, i) {
    let r = this.startNodeAt(e);
    return r.object = t, this.next(), r.callee = this.parseNoCallExpr(), i.stop = true, this.parseSubscripts(this.finishNode(r, "BindExpression"), e, s);
  }
  parseCoverCallAndAsyncArrowHead(t, e, s, i) {
    let r = this.state.maybeInArrowParameters, n = null;
    this.state.maybeInArrowParameters = true, this.next();
    let o = this.startNodeAt(e);
    o.callee = t;
    let { maybeAsyncArrow: h, optionalChainMember: c2 } = s;
    h && (this.expressionScope.enter(zi$1()), n = new X$1()), c2 && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments() : o.arguments = this.parseCallExpressionArguments(t.type !== "Super", o, n);
    let p = this.finishCallExpression(o, c2);
    return h && this.shouldParseAsyncArrow() && !i ? (s.stop = true, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e), p)) : (h && (this.checkExpressionErrors(n, true), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = r, p;
  }
  toReferencedArguments(t, e) {
    this.toReferencedListDeep(t.arguments, e);
  }
  parseTaggedTemplateExpression(t, e, s) {
    let i = this.startNodeAt(e);
    return i.tag = t, i.quasi = this.parseTemplate(true), s.optionalChainMember && this.raise(l.OptionalChainingNoTemplate, e), this.finishNode(i, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(t) {
    return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
  }
  finishCallExpression(t, e) {
    if (t.callee.type === "Import") if (t.arguments.length === 0 || t.arguments.length > 2) this.raise(l.ImportCallArity, t);
    else for (let s of t.arguments) s.type === "SpreadElement" && this.raise(l.ImportCallSpreadArgument, s);
    return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(t, e, s) {
    let i = [], r = true, n = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = false; !this.eat(11); ) {
      if (r) r = false;
      else if (this.expect(12), this.match(11)) {
        e && this.addTrailingCommaExtraToNode(e), this.next();
        break;
      }
      i.push(this.parseExprListItem(11, false, s, t));
    }
    return this.state.inFSharpPipelineDirectBody = n, i;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(t, e) {
    return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, true, e.extra?.trailingCommaLoc), e.innerComments && G$1(t, e.innerComments), e.callee.trailingComments && G$1(t, e.callee.trailingComments), t;
  }
  parseNoCallExpr() {
    let t = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), t, true);
  }
  parseExprAtom(t) {
    let e, s = null, { type: i } = this.state;
    switch (i) {
      case 79:
        return this.parseSuper();
      case 83:
        return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(e) : this.match(10) ? this.optionFlags & 512 ? this.parseImportCall(e) : this.finishNode(e, "Import") : (this.raise(l.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e, "Import"));
      case 78:
        return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), false);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 135:
        return this.parseNumericLiteral(this.state.value);
      case 136:
        return this.parseBigIntLiteral(this.state.value);
      case 134:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(true);
      case 86:
        return this.parseBooleanLiteral(false);
      case 10: {
        let r = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(r);
      }
      case 0:
        return this.parseArrayLike(3, false, t);
      case 5:
        return this.parseObjectLike(8, false, false, t);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        s = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), false);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(false);
      case 15: {
        e = this.startNode(), this.next(), e.object = null;
        let r = e.callee = this.parseNoCallExpr();
        if (r.type === "MemberExpression") return this.finishNode(e, "BindExpression");
        throw this.raise(l.UnsupportedBind, r);
      }
      case 139:
        return this.raise(l.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        let r = this.getPluginOption("pipelineOperator", "proposal");
        if (r) return this.parseTopicReference(r);
        throw this.unexpected();
      }
      case 47: {
        let r = this.input.codePointAt(this.nextTokenStart());
        throw F(r) || r === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
      }
      default:
        if (S(i)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
          let r = this.state.potentialArrowAt === this.state.start, n = this.state.containsEsc, o = this.parseIdentifier();
          if (!n && o.name === "async" && !this.canInsertSemicolon()) {
            let { type: h } = this.state;
            if (h === 68) return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
            if (S(h)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
            if (h === 90) return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), true);
          }
          return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], false)) : o;
        } else throw this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(t, e) {
    let s = this.getPluginOption("pipelineOperator", "proposal");
    if (s) return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = L(this.state.endLoc, -1), this.parseTopicReference(s);
    throw this.unexpected();
  }
  parseTopicReference(t) {
    let e = this.startNode(), s = this.state.startLoc, i = this.state.type;
    return this.next(), this.finishTopicReference(e, s, t, i);
  }
  finishTopicReference(t, e, s, i) {
    if (this.testTopicReferenceConfiguration(s, e, i)) return this.topicReferenceIsAllowedInCurrentContext() || this.raise(l.PipeTopicUnbound, e), this.registerTopicReference(), this.finishNode(t, "TopicReference");
    throw this.raise(l.PipeTopicUnconfiguredToken, e, { token: V$1(i) });
  }
  testTopicReferenceConfiguration(t, e, s) {
    switch (t) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", { topicToken: V$1(s) }]);
      case "smart":
        return s === 27;
      default:
        throw this.raise(l.PipeTopicRequiresHackPipes, e);
    }
  }
  parseAsyncArrowUnaryFunction(t) {
    this.prodParam.enter(Ae$1(true, this.prodParam.hasYield));
    let e = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(l.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, e, true);
  }
  parseDo(t, e) {
    this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
    let s = this.state.labels;
    return this.state.labels = [], e ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s, this.finishNode(t, "DoExpression");
  }
  parseSuper() {
    let t = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.raise(l.SuperNotAllowed, t) : this.scope.allowSuper || this.raise(l.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(l.UnsupportedSuper, t), this.finishNode(t, "Super");
  }
  parsePrivateName() {
    let t = this.startNode(), e = this.startNodeAt(L(this.state.startLoc, 1)), s = this.state.value;
    return this.next(), t.id = this.createIdentifier(e, s), this.finishNode(t, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    let t = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      let e = this.createIdentifier(this.startNodeAtNode(t), "function");
      return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
    }
    return this.parseFunction(t);
  }
  parseMetaProperty(t, e, s) {
    t.meta = e;
    let i = this.state.containsEsc;
    return t.property = this.parseIdentifier(true), (t.property.name !== s || i) && this.raise(l.UnsupportedMetaProperty, t.property, { target: e.name, onlyValidPropertyName: s }), this.finishNode(t, "MetaProperty");
  }
  parseImportMetaPropertyOrPhaseCall(t) {
    if (this.next(), this.isContextual(105) || this.isContextual(97)) {
      let e = this.isContextual(105);
      return this.expectPlugin(e ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), t.phase = e ? "source" : "defer", this.parseImportCall(t);
    } else {
      let e = this.createIdentifierAt(this.startNodeAtNode(t), "import", this.state.lastTokStartLoc);
      return this.isContextual(101) && (this.inModule || this.raise(l.ImportMetaOutsideModule, e), this.sawUnambiguousESM = true), this.parseMetaProperty(t, e, "meta");
    }
  }
  parseLiteralAtNode(t, e, s) {
    return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.value = t, this.next(), this.finishNode(s, e);
  }
  parseLiteral(t, e) {
    let s = this.startNode();
    return this.parseLiteralAtNode(t, e, s);
  }
  parseStringLiteral(t) {
    return this.parseLiteral(t, "StringLiteral");
  }
  parseNumericLiteral(t) {
    return this.parseLiteral(t, "NumericLiteral");
  }
  parseBigIntLiteral(t) {
    {
      let e;
      try {
        e = BigInt(t);
      } catch {
        e = null;
      }
      return this.parseLiteral(e, "BigIntLiteral");
    }
  }
  parseDecimalLiteral(t) {
    return this.parseLiteral(t, "DecimalLiteral");
  }
  parseRegExpLiteral(t) {
    let e = this.startNode();
    return this.addExtra(e, "raw", this.input.slice(this.offsetToSourcePos(e.start), this.state.end)), e.pattern = t.pattern, e.flags = t.flags, this.next(), this.finishNode(e, "RegExpLiteral");
  }
  parseBooleanLiteral(t) {
    let e = this.startNode();
    return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
  }
  parseNullLiteral() {
    let t = this.startNode();
    return this.next(), this.finishNode(t, "NullLiteral");
  }
  parseParenAndDistinguishExpression(t) {
    let e = this.state.startLoc, s;
    this.next(), this.expressionScope.enter(Vi$1());
    let i = this.state.maybeInArrowParameters, r = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
    let n = this.state.startLoc, o = [], h = new X$1(), c2 = true, p, u;
    for (; !this.match(11); ) {
      if (c2) c2 = false;
      else if (this.expect(12, h.optionalParametersLoc === null ? null : h.optionalParametersLoc), this.match(11)) {
        u = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        let b2 = this.state.startLoc;
        if (p = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), b2)), !this.checkCommaAfterRest(41)) break;
      } else o.push(this.parseMaybeAssignAllowInOrVoidPattern(11, h, this.parseParenItem));
    }
    let f2 = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = r;
    let y2 = this.startNodeAt(e);
    return t && this.shouldParseArrow(o) && (y2 = this.parseArrow(y2)) ? (this.checkDestructuringPrivate(h), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(y2, o, false), y2) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), u && this.unexpected(u), p && this.unexpected(p), this.checkExpressionErrors(h, true), this.toReferencedListDeep(o, true), o.length > 1 ? (s = this.startNodeAt(n), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, f2)) : s = o[0], this.wrapParenthesis(e, s));
  }
  wrapParenthesis(t, e) {
    if (!(this.optionFlags & 1024)) return this.addExtra(e, "parenthesized", true), this.addExtra(e, "parenStart", t.index), this.takeSurroundingComments(e, t.index, this.state.lastTokEndLoc.index), e;
    let s = this.startNodeAt(t);
    return s.expression = e, this.finishNode(s, "ParenthesizedExpression");
  }
  shouldParseArrow(t) {
    return !this.canInsertSemicolon();
  }
  parseArrow(t) {
    if (this.eat(19)) return t;
  }
  parseParenItem(t, e) {
    return t;
  }
  parseNewOrNewTarget() {
    let t = this.startNode();
    if (this.next(), this.match(16)) {
      let e = this.createIdentifier(this.startNodeAtNode(t), "new");
      this.next();
      let s = this.parseMetaProperty(t, e, "target");
      return this.scope.allowNewTarget || this.raise(l.UnexpectedNewTarget, s), s;
    }
    return this.parseNew(t);
  }
  parseNew(t) {
    if (this.parseNewCallee(t), this.eat(10)) {
      let e = this.parseExprList(11);
      this.toReferencedList(e), t.arguments = e;
    } else t.arguments = [];
    return this.finishNode(t, "NewExpression");
  }
  parseNewCallee(t) {
    let e = this.match(83), s = this.parseNoCallExpr();
    t.callee = s, e && (s.type === "Import" || s.type === "ImportExpression") && this.raise(l.ImportCallNotNewExpression, s);
  }
  parseTemplateElement(t) {
    let { start: e, startLoc: s, end: i, value: r } = this.state, n = e + 1, o = this.startNodeAt(L(s, 1));
    r === null && (t || this.raise(l.InvalidEscapeSequenceTemplate, L(this.state.firstInvalidTemplateEscapePos, 1)));
    let h = this.match(24), c2 = h ? -1 : -2, p = i + c2;
    o.value = { raw: this.input.slice(n, p).replace(/\r\n?/g, `
`), cooked: r === null ? null : r.slice(1, c2) }, o.tail = h, this.next();
    let u = this.finishNode(o, "TemplateElement");
    return this.resetEndLocation(u, L(this.state.lastTokEndLoc, c2)), u;
  }
  parseTemplate(t) {
    let e = this.startNode(), s = this.parseTemplateElement(t), i = [s], r = [];
    for (; !s.tail; ) r.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(t));
    return e.expressions = r, e.quasis = i, this.finishNode(e, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(t, e, s, i) {
    s && this.expectPlugin("recordAndTuple");
    let r = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    let n = false, o = true, h = this.startNode();
    for (h.properties = [], this.next(); !this.match(t); ) {
      if (o) o = false;
      else if (this.expect(12), this.match(t)) {
        this.addTrailingCommaExtraToNode(h);
        break;
      }
      let p;
      e ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), n = this.checkProto(p, s, n, i)), s && !this.isObjectProperty(p) && p.type !== "SpreadElement" && this.raise(l.InvalidRecordProperty, p), h.properties.push(p);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = r;
    let c2 = "ObjectExpression";
    return e ? c2 = "ObjectPattern" : s && (c2 = "RecordExpression"), this.finishNode(h, c2);
  }
  addTrailingCommaExtraToNode(t) {
    this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
  }
  maybeAsyncOrAccessorProp(t) {
    return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(t) {
    let e = [];
    if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(l.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
    let s = this.startNode(), i = false, r = false, n;
    if (this.match(21)) return e.length && this.unexpected(), this.parseSpread();
    e.length && (s.decorators = e, e = []), s.method = false, t && (n = this.state.startLoc);
    let o = this.eat(55);
    this.parsePropertyNamePrefixOperator(s);
    let h = this.state.containsEsc;
    if (this.parsePropertyName(s, t), !o && !h && this.maybeAsyncOrAccessorProp(s)) {
      let { key: c2 } = s, p = c2.name;
      p === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(c2), o = this.eat(55), this.parsePropertyName(s)), (p === "get" || p === "set") && (r = true, this.resetPreviousNodeTrailingComments(c2), s.kind = p, this.match(55) && (o = true, this.raise(l.AccessorIsGenerator, this.state.curPosition(), { kind: p }), this.next()), this.parsePropertyName(s));
    }
    return this.parseObjPropValue(s, n, o, i, false, r, t);
  }
  getGetterSetterExpectedParamCount(t) {
    return t.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(t) {
    return t.params;
  }
  checkGetterSetterParams(t) {
    let e = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
    s.length !== e && this.raise(t.kind === "get" ? l.BadGetterArity : l.BadSetterArity, t), t.kind === "set" && s[s.length - 1]?.type === "RestElement" && this.raise(l.BadSetterRestParameter, t);
  }
  parseObjectMethod(t, e, s, i, r) {
    if (r) {
      let n = this.parseMethod(t, e, false, false, false, "ObjectMethod");
      return this.checkGetterSetterParams(n), n;
    }
    if (s || e || this.match(10)) return i && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, e, s, false, false, "ObjectMethod");
  }
  parseObjectProperty(t, e, s, i) {
    if (t.shorthand = false, this.eat(14)) return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, i), this.finishObjectProperty(t);
    if (!t.computed && t.key.type === "Identifier") {
      if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), s) t.value = this.parseMaybeDefault(e, this.cloneIdentifier(t.key));
      else if (this.match(29)) {
        let r = this.state.startLoc;
        i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = r) : this.raise(l.InvalidCoverInitializedName, r), t.value = this.parseMaybeDefault(e, this.cloneIdentifier(t.key));
      } else t.value = this.cloneIdentifier(t.key);
      return t.shorthand = true, this.finishObjectProperty(t);
    }
  }
  finishObjectProperty(t) {
    return this.finishNode(t, "ObjectProperty");
  }
  parseObjPropValue(t, e, s, i, r, n, o) {
    let h = this.parseObjectMethod(t, s, i, r, n) || this.parseObjectProperty(t, e, r, o);
    return h || this.unexpected(), h;
  }
  parsePropertyName(t, e) {
    if (this.eat(0)) t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      let { type: s, value: i } = this.state, r;
      if (M$1(s)) r = this.parseIdentifier(true);
      else switch (s) {
        case 135:
          r = this.parseNumericLiteral(i);
          break;
        case 134:
          r = this.parseStringLiteral(i);
          break;
        case 136:
          r = this.parseBigIntLiteral(i);
          break;
        case 139: {
          let n = this.state.startLoc;
          e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = n) : this.raise(l.UnexpectedPrivateField, n), r = this.parsePrivateName();
          break;
        }
        default:
          this.unexpected();
      }
      t.key = r, s !== 139 && (t.computed = false);
    }
  }
  initFunction(t, e) {
    t.id = null, t.generator = false, t.async = e;
  }
  parseMethod(t, e, s, i, r, n, o = false) {
    this.initFunction(t, s), t.generator = e, this.scope.enter(530 | (o ? 576 : 0) | (r ? 32 : 0)), this.prodParam.enter(Ae$1(s, t.generator)), this.parseFunctionParams(t, i);
    let h = this.parseFunctionBodyAndFinish(t, n, true);
    return this.prodParam.exit(), this.scope.exit(), h;
  }
  parseArrayLike(t, e, s) {
    e && this.expectPlugin("recordAndTuple");
    let i = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    let r = this.startNode();
    return this.next(), r.elements = this.parseExprList(t, !e, s, r), this.state.inFSharpPipelineDirectBody = i, this.finishNode(r, e ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(t, e, s, i) {
    this.scope.enter(518);
    let r = Ae$1(s, false);
    !this.match(5) && this.prodParam.hasIn && (r |= 8), this.prodParam.enter(r), this.initFunction(t, s);
    let n = this.state.maybeInArrowParameters;
    return e && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n, this.finishNode(t, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(t, e, s) {
    this.toAssignableList(e, s, false), t.params = e;
  }
  parseFunctionBodyAndFinish(t, e, s = false) {
    return this.parseFunctionBody(t, false, s), this.finishNode(t, e);
  }
  parseFunctionBody(t, e, s = false) {
    let i = e && !this.match(5);
    if (this.expressionScope.enter(rs$1()), i) t.body = this.parseMaybeAssign(), this.checkParams(t, false, e, false);
    else {
      let r = this.state.strict, n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(true, false, (o) => {
        let h = !this.isSimpleParamList(t.params);
        o && h && this.raise(l.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
        let c2 = !r && this.state.strict;
        this.checkParams(t, !this.state.strict && !e && !s && !h, e, c2), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c2);
      }), this.prodParam.exit(), this.state.labels = n;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(t) {
    return t.type === "Identifier";
  }
  isSimpleParamList(t) {
    for (let e = 0, s = t.length; e < s; e++) if (!this.isSimpleParameter(t[e])) return false;
    return true;
  }
  checkParams(t, e, s, i = true) {
    let r = !e && /* @__PURE__ */ new Set(), n = { type: "FormalParameters" };
    for (let o of t.params) this.checkLVal(o, n, 5, r, i);
  }
  parseExprList(t, e, s, i) {
    let r = [], n = true;
    for (; !this.eat(t); ) {
      if (n) n = false;
      else if (this.expect(12), this.match(t)) {
        i && this.addTrailingCommaExtraToNode(i), this.next();
        break;
      }
      r.push(this.parseExprListItem(t, e, s));
    }
    return r;
  }
  parseExprListItem(t, e, s, i) {
    let r;
    if (this.match(12)) e || this.raise(l.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), r = null;
    else if (this.match(21)) {
      let n = this.state.startLoc;
      r = this.parseParenItem(this.parseSpread(s), n);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), i || this.raise(l.UnexpectedArgumentPlaceholder, this.state.startLoc);
      let n = this.startNode();
      this.next(), r = this.finishNode(n, "ArgumentPlaceholder");
    } else r = this.parseMaybeAssignAllowInOrVoidPattern(t, s, this.parseParenItem);
    return r;
  }
  parseIdentifier(t) {
    let e = this.startNode(), s = this.parseIdentifierName(t);
    return this.createIdentifier(e, s);
  }
  createIdentifier(t, e) {
    return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
  }
  createIdentifierAt(t, e, s) {
    return t.name = e, t.loc.identifierName = e, this.finishNodeAt(t, "Identifier", s);
  }
  parseIdentifierName(t) {
    let e, { startLoc: s, type: i } = this.state;
    M$1(i) ? e = this.state.value : this.unexpected();
    let r = ni$1(i);
    return t ? r && this.replaceToken(132) : this.checkReservedWord(e, s, r, false), this.next(), e;
  }
  checkReservedWord(t, e, s, i) {
    if (t.length > 10 || !Ci$1(t)) return;
    if (s && Ai$1(t)) {
      this.raise(l.UnexpectedKeyword, e, { keyword: t });
      return;
    }
    if ((this.state.strict ? i ? es$1 : Qt$1 : Yt$1)(t, this.inModule)) {
      this.raise(l.UnexpectedReservedWord, e, { reservedWord: t });
      return;
    } else if (t === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(l.YieldBindingIdentifier, e);
        return;
      }
    } else if (t === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(l.AwaitBindingIdentifier, e);
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(l.AwaitBindingIdentifierInStaticBlock, e);
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError(e);
    } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(l.ArgumentsInClass, e);
      return;
    }
  }
  recordAwaitIfAllowed() {
    let t = this.prodParam.hasAwait;
    return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = true), t;
  }
  parseAwait(t) {
    let e = this.startNodeAt(t);
    return this.expressionScope.recordParameterInitializerError(l.AwaitExpressionFormalParameter, e), this.eat(55) && this.raise(l.ObsoleteAwaitStar, e), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e.argument = this.parseMaybeUnary(null, true)), this.finishNode(e, "AwaitExpression");
  }
  isAmbiguousPrefixOrIdentifier() {
    if (this.hasPrecedingLineBreak()) return true;
    let { type: t } = this.state;
    return t === 53 || t === 10 || t === 0 || ze$1(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
  }
  parseYield(t) {
    let e = this.startNodeAt(t);
    this.expressionScope.recordParameterInitializerError(l.YieldInParameter, e);
    let s = false, i = null;
    if (!this.hasPrecedingLineBreak()) switch (s = this.eat(55), this.state.type) {
      case 13:
      case 140:
      case 8:
      case 11:
      case 3:
      case 9:
      case 14:
      case 12:
        if (!s) break;
      default:
        i = this.parseMaybeAssign();
    }
    return e.delegate = s, e.argument = i, this.finishNode(e, "YieldExpression");
  }
  parseImportCall(t) {
    if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12)) {
      if (this.match(11)) this.addTrailingCommaExtraToNode(t.source);
      else if (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(t.options), !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(l.ImportCallArity, t);
      }
    }
    return this.expect(11), this.finishNode(t, "ImportExpression");
  }
  checkPipelineAtInfixOperator(t, e) {
    this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(l.PipelineHeadSequenceExpression, e);
  }
  parseSmartPipelineBodyInStyle(t, e) {
    if (this.isSimpleReference(t)) {
      let s = this.startNodeAt(e);
      return s.callee = t, this.finishNode(s, "PipelineBareFunction");
    } else {
      let s = this.startNodeAt(e);
      return this.checkSmartPipeTopicBodyEarlyErrors(e), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
    }
  }
  isSimpleReference(t) {
    switch (t.type) {
      case "MemberExpression":
        return !t.computed && this.isSimpleReference(t.object);
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(t) {
    if (this.match(19)) throw this.raise(l.PipelineBodyNoArrow, this.state.startLoc);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipelineTopicUnused, t);
  }
  withTopicBindingContext(t) {
    let e = this.state.topicContext;
    this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
    try {
      return t();
    } finally {
      this.state.topicContext = e;
    }
  }
  withSmartMixTopicForbiddingContext(t) {
    return t();
  }
  withSoloAwaitPermittingContext(t) {
    let e = this.state.soloAwait;
    this.state.soloAwait = true;
    try {
      return t();
    } finally {
      this.state.soloAwait = e;
    }
  }
  allowInAnd(t) {
    let e = this.prodParam.currentFlags();
    if (8 & ~e) {
      this.prodParam.enter(e | 8);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  disallowInAnd(t) {
    let e = this.prodParam.currentFlags();
    if (8 & e) {
      this.prodParam.enter(e & -9);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(t) {
    let e = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    let s = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, t);
    return this.state.inFSharpPipelineDirectBody = s, i;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    let t = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    let e = this.startNodeAt(this.state.endLoc);
    this.next();
    let s = this.initializeScopes(true);
    this.enterInitialScopes();
    try {
      t.body = this.parseProgram(e, 8, "module");
    } finally {
      s();
    }
    return this.finishNode(t, "ModuleExpression");
  }
  parseVoidPattern(t) {
    this.expectPlugin("discardBinding");
    let e = this.startNode();
    return t != null && (t.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(e, "VoidPattern");
  }
  parseMaybeAssignAllowInOrVoidPattern(t, e, s) {
    if (e != null && this.match(88)) {
      let i = this.lookaheadCharCode();
      if (i === 44 || i === (t === 3 ? 93 : t === 8 ? 125 : 41) || i === 61) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(e));
    }
    return this.parseMaybeAssignAllowIn(e, s);
  }
  parsePropertyNamePrefixOperator(t) {
  }
}, je$1 = { kind: 1 }, er$1 = { kind: 2 }, tr$1 = /[\uD800-\uDFFF]/u, Ve$1 = /in(?:stanceof)?/y;
function sr$1(a2, t, e) {
  for (let s = 0; s < a2.length; s++) {
    let i = a2[s], { type: r } = i;
    typeof r == "number" && (i.type = Jt$1(r));
  }
  return a2;
}
var lt$1 = class lt extends ct$1 {
  parseTopLevel(t, e) {
    return t.program = this.parseProgram(e, 140, this.options.sourceType === "module" ? "module" : "script"), t.comments = this.comments, this.optionFlags & 256 && (t.tokens = sr$1(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
  }
  parseProgram(t, e, s) {
    if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, e), this.inModule) {
      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) for (let [r, n] of Array.from(this.scope.undefinedExports)) this.raise(l.ModuleExportUndefined, n, { localName: r });
      this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
    }
    let i;
    return e === 140 ? i = this.finishNode(t, "Program") : i = this.finishNodeAt(t, "Program", L(this.state.startLoc, -1)), i;
  }
  stmtToDirective(t) {
    let e = this.castNodeTo(t, "Directive"), s = this.castNodeTo(t.expression, "DirectiveLiteral"), i = s.value, r = this.input.slice(this.offsetToSourcePos(s.start), this.offsetToSourcePos(s.end)), n = s.value = r.slice(1, -1);
    return this.addExtra(s, "raw", r), this.addExtra(s, "rawValue", n), this.addExtra(s, "expressionValue", i), e.value = s, delete t.expression, e;
  }
  parseInterpreterDirective() {
    if (!this.match(28)) return null;
    let t = this.startNode();
    return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(100) ? this.hasFollowingBindingAtom() : false;
  }
  isUsing() {
    return this.isContextual(107) ? this.nextTokenIsIdentifierOnSameLine() : false;
  }
  isForUsing() {
    if (!this.isContextual(107)) return false;
    let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
    if (this.isUnparsedContextual(t, "of")) {
      let s = this.lookaheadCharCodeSince(t + 2);
      if (s !== 61 && s !== 58 && s !== 59) return false;
    }
    return !!(this.chStartsBindingIdentifier(e, t) || this.isUnparsedContextual(t, "void"));
  }
  nextTokenIsIdentifierOnSameLine() {
    let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
    return this.chStartsBindingIdentifier(e, t);
  }
  isAwaitUsing() {
    if (!this.isContextual(96)) return false;
    let t = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(t, "using")) {
      t = this.nextTokenInLineStartSince(t + 5);
      let e = this.codePointAtPos(t);
      if (this.chStartsBindingIdentifier(e, t)) return true;
    }
    return false;
  }
  chStartsBindingIdentifier(t, e) {
    if (F(t)) {
      if (Ve$1.lastIndex = e, Ve$1.test(this.input)) {
        let s = this.codePointAtPos(Ve$1.lastIndex);
        if (!$$1(s) && s !== 92) return false;
      }
      return true;
    } else return t === 92;
  }
  chStartsBindingPattern(t) {
    return t === 91 || t === 123;
  }
  hasFollowingBindingAtom() {
    let t = this.nextTokenStart(), e = this.codePointAtPos(t);
    return this.chStartsBindingPattern(e) || this.chStartsBindingIdentifier(e, t);
  }
  hasInLineFollowingBindingIdentifierOrBrace() {
    let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
    return e === 123 || this.chStartsBindingIdentifier(e, t);
  }
  allowsUsing() {
    return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(t = false) {
    let e = 0;
    return this.options.annexB && !this.state.strict && (e |= 4, t && (e |= 8)), this.parseStatementLike(e);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(t) {
    let e = null;
    return this.match(26) && (e = this.parseDecorators(true)), this.parseStatementContent(t, e);
  }
  parseStatementContent(t, e) {
    let s = this.state.type, i = this.startNode(), r = !!(t & 2), n = !!(t & 4), o = t & 1;
    switch (s) {
      case 60:
        return this.parseBreakContinueStatement(i, true);
      case 63:
        return this.parseBreakContinueStatement(i, false);
      case 64:
        return this.parseDebuggerStatement(i);
      case 90:
        return this.parseDoWhileStatement(i);
      case 91:
        return this.parseForStatement(i);
      case 68:
        if (this.lookaheadCharCode() === 46) break;
        return n || this.raise(this.state.strict ? l.StrictFunction : this.options.annexB ? l.SloppyFunctionAnnexB : l.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, false, !r && n);
      case 80:
        return r || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e, i), true);
      case 69:
        return this.parseIfStatement(i);
      case 70:
        return this.parseReturnStatement(i);
      case 71:
        return this.parseSwitchStatement(i);
      case 72:
        return this.parseThrowStatement(i);
      case 73:
        return this.parseTryStatement(i);
      case 96:
        if (this.isAwaitUsing()) return this.allowsUsing() ? r ? this.recordAwaitIfAllowed() || this.raise(l.AwaitUsingNotInAsyncContext, i) : this.raise(l.UnexpectedLexicalDeclaration, i) : this.raise(l.UnexpectedUsingDeclaration, i), this.next(), this.parseVarStatement(i, "await using");
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
        return this.allowsUsing() ? r || this.raise(l.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(l.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
      case 100: {
        if (this.state.containsEsc) break;
        let p = this.nextTokenStart(), u = this.codePointAtPos(p);
        if (u !== 91 && (!r && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(u, p) && u !== 123)) break;
      }
      case 75:
        r || this.raise(l.UnexpectedLexicalDeclaration, this.state.startLoc);
      case 74: {
        let p = this.state.value;
        return this.parseVarStatement(i, p);
      }
      case 92:
        return this.parseWhileStatement(i);
      case 76:
        return this.parseWithStatement(i);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(i);
      case 83: {
        let p = this.lookaheadCharCode();
        if (p === 40 || p === 46) break;
      }
      case 82: {
        !(this.optionFlags & 8) && !o && this.raise(l.UnexpectedImportExport, this.state.startLoc), this.next();
        let p;
        return s === 83 ? p = this.parseImport(i) : p = this.parseExport(i, e), this.assertModuleNodeAllowed(p), p;
      }
      default:
        if (this.isAsyncFunction()) return r || this.raise(l.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, true, !r && n);
    }
    let h = this.state.value, c2 = this.parseExpression();
    return S(s) && c2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, h, c2, t) : this.parseExpressionStatement(i, c2, e);
  }
  assertModuleNodeAllowed(t) {
    !(this.optionFlags & 8) && !this.inModule && this.raise(l.ImportOutsideModule, t);
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
  }
  maybeTakeDecorators(t, e, s) {
    return t && (e.decorators?.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(l.DecoratorsBeforeAfterExport, e.decorators[0]), e.decorators.unshift(...t)) : e.decorators = t, this.resetStartLocationFromNode(e, t[0]), s && this.resetStartLocationFromNode(s, e)), e;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(t) {
    let e = [];
    do
      e.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(l.DecoratorExportClass, this.state.startLoc);
    else if (!this.canHaveLeadingDecorator()) throw this.raise(l.UnexpectedLeadingDecorator, this.state.startLoc);
    return e;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    let t = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      let e = this.state.startLoc, s;
      if (this.match(10)) {
        let i = this.state.startLoc;
        this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
        let r = this.state.startLoc;
        t.expression = this.parseMaybeDecoratorArguments(s, i), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== s && this.raise(l.DecoratorArgumentsOutsideParentheses, r);
      } else {
        for (s = this.parseIdentifier(false); this.eat(16); ) {
          let i = this.startNodeAt(e);
          i.object = s, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(true), i.computed = false, s = this.finishNode(i, "MemberExpression");
        }
        t.expression = this.parseMaybeDecoratorArguments(s, e);
      }
    } else t.expression = this.parseExprSubscripts();
    return this.finishNode(t, "Decorator");
  }
  parseMaybeDecoratorArguments(t, e) {
    if (this.eat(10)) {
      let s = this.startNodeAt(e);
      return s.callee = t, s.arguments = this.parseCallExpressionArguments(), this.toReferencedList(s.arguments), this.finishNode(s, "CallExpression");
    }
    return t;
  }
  parseBreakContinueStatement(t, e) {
    return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(t, e) {
    let s;
    for (s = 0; s < this.state.labels.length; ++s) {
      let i = this.state.labels[s];
      if ((t.label == null || i.name === t.label.name) && (i.kind != null && (e || i.kind === 1) || t.label && e)) break;
    }
    if (s === this.state.labels.length) {
      let i = e ? "BreakStatement" : "ContinueStatement";
      this.raise(l.IllegalBreakContinue, t, { type: i });
    }
  }
  parseDebuggerStatement(t) {
    return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    let t = this.parseExpression();
    return this.expect(11), t;
  }
  parseDoWhileStatement(t) {
    return this.next(), this.state.labels.push(je$1), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
  }
  parseForStatement(t) {
    this.next(), this.state.labels.push(je$1);
    let e = null;
    if (this.isContextual(96) && this.recordAwaitIfAllowed() && (e = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return e !== null && this.unexpected(e), this.parseFor(t, null);
    let s = this.isContextual(100);
    {
      let h = this.isAwaitUsing(), c2 = h || this.isForUsing(), p = s && this.hasFollowingBindingAtom() || c2;
      if (this.match(74) || this.match(75) || p) {
        let u = this.startNode(), f2;
        h ? (f2 = "await using", this.recordAwaitIfAllowed() || this.raise(l.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f2 = this.state.value, this.next(), this.parseVar(u, true, f2);
        let y2 = this.finishNode(u, "VariableDeclaration"), b2 = this.match(58);
        return b2 && c2 && this.raise(l.ForInUsing, y2), (b2 || this.isContextual(102)) && y2.declarations.length === 1 ? this.parseForIn(t, y2, e) : (e !== null && this.unexpected(e), this.parseFor(t, y2));
      }
    }
    let i = this.isContextual(95), r = new X$1(), n = this.parseExpression(true, r), o = this.isContextual(102);
    if (o && (s && this.raise(l.ForOfLet, n), e === null && i && n.type === "Identifier" && this.raise(l.ForOfAsync, n)), o || this.match(58)) {
      this.checkDestructuringPrivate(r), this.toAssignable(n, true);
      let h = o ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(n, { type: h }), this.parseForIn(t, n, e);
    } else this.checkExpressionErrors(r, true);
    return e !== null && this.unexpected(e), this.parseFor(t, n);
  }
  parseFunctionStatement(t, e, s) {
    return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (e ? 8 : 0));
  }
  parseIfStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
  }
  parseReturnStatement(t) {
    return this.prodParam.hasReturn || this.raise(l.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
  }
  parseSwitchStatement(t) {
    this.next(), t.discriminant = this.parseHeaderExpression();
    let e = t.cases = [];
    this.expect(5), this.state.labels.push(er$1), this.scope.enter(256);
    let s;
    for (let i; !this.match(8); ) if (this.match(61) || this.match(65)) {
      let r = this.match(61);
      s && this.finishNode(s, "SwitchCase"), e.push(s = this.startNode()), s.consequent = [], this.next(), r ? s.test = this.parseExpression() : (i && this.raise(l.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = true, s.test = null), this.expect(14);
    } else s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
  }
  parseThrowStatement(t) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(l.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
  }
  parseCatchClauseParam() {
    let t = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, { type: "CatchClause" }, 9), t;
  }
  parseTryStatement(t) {
    if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
      let e = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(0)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
    }
    return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(l.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
  }
  parseVarStatement(t, e, s = false) {
    return this.next(), this.parseVar(t, false, e, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
  }
  parseWhileStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(je$1), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
  }
  parseWithStatement(t) {
    return this.state.strict && this.raise(l.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
  }
  parseEmptyStatement(t) {
    return this.next(), this.finishNode(t, "EmptyStatement");
  }
  parseLabeledStatement(t, e, s, i) {
    for (let n of this.state.labels) n.name === e && this.raise(l.LabelRedeclaration, s, { labelName: e });
    let r = ci$1(this.state.type) ? 1 : this.match(71) ? 2 : null;
    for (let n = this.state.labels.length - 1; n >= 0; n--) {
      let o = this.state.labels[n];
      if (o.statementStart === t.start) o.statementStart = this.sourceToOffsetPos(this.state.start), o.kind = r;
      else break;
    }
    return this.state.labels.push({ name: e, kind: r, statementStart: this.sourceToOffsetPos(this.state.start) }), t.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
  }
  parseExpressionStatement(t, e, s) {
    return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
  }
  parseBlock(t = false, e = true, s) {
    let i = this.startNode();
    return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(0), this.parseBlockBody(i, t, false, 8, s), e && this.scope.exit(), this.finishNode(i, "BlockStatement");
  }
  isValidDirective(t) {
    return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
  }
  parseBlockBody(t, e, s, i, r) {
    let n = t.body = [], o = t.directives = [];
    this.parseBlockOrModuleBlockBody(n, e ? o : void 0, s, i, r);
  }
  parseBlockOrModuleBlockBody(t, e, s, i, r) {
    let n = this.state.strict, o = false, h = false;
    for (; !this.match(i); ) {
      let c2 = s ? this.parseModuleItem() : this.parseStatementListItem();
      if (e && !h) {
        if (this.isValidDirective(c2)) {
          let p = this.stmtToDirective(c2);
          e.push(p), !o && p.value.value === "use strict" && (o = true, this.setStrict(true));
          continue;
        }
        h = true, this.state.strictErrors.clear();
      }
      t.push(c2);
    }
    r?.call(this, o), n || this.setStrict(false), this.next();
  }
  parseFor(t, e) {
    return t.init = e, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
  }
  parseForIn(t, e, s) {
    let i = this.match(58);
    return this.next(), i ? s !== null && this.unexpected(s) : t.await = s !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(l.ForInOfLoopInitializer, e, { type: i ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(l.InvalidLhs, e, { ancestor: { type: "ForStatement" } }), t.left = e, t.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(t, e, s, i = false) {
    let r = t.declarations = [];
    for (t.kind = s; ; ) {
      let n = this.startNode();
      if (this.parseVarId(n, s), n.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n.init === null && !i && (n.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(102))) ? this.raise(l.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(l.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s })), r.push(this.finishNode(n, "VariableDeclarator")), !this.eat(12)) break;
    }
    return t;
  }
  parseVarId(t, e) {
    let s = this.parseBindingAtom();
    e === "using" || e === "await using" ? (s.type === "ArrayPattern" || s.type === "ObjectPattern") && this.raise(l.UsingDeclarationHasBindingPattern, s.loc.start) : s.type === "VoidPattern" && this.raise(l.UnexpectedVoidPattern, s.loc.start), this.checkLVal(s, { type: "VariableDeclarator" }, e === "var" ? 5 : 8201), t.id = s;
  }
  parseAsyncFunctionExpression(t) {
    return this.parseFunction(t, 8);
  }
  parseFunction(t, e = 0) {
    let s = e & 2, i = !!(e & 1), r = i && !(e & 4), n = !!(e & 8);
    this.initFunction(t, n), this.match(55) && (s && this.raise(l.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = true), i && (t.id = this.parseFunctionId(r));
    let o = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = false, this.scope.enter(514), this.prodParam.enter(Ae$1(n, t.generator)), i || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(t, i ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
  }
  parseFunctionId(t) {
    return t || S(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(t, e) {
    this.expect(10), this.expressionScope.enter(ji$1()), t.params = this.parseBindingList(11, 41, 2 | (e ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(t) {
    t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
  }
  parseClass(t, e, s) {
    this.next();
    let i = this.state.strict;
    return this.state.strict = true, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  nameIsConstructor(t) {
    return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
  }
  isNonstaticConstructor(t) {
    return !t.computed && !t.static && this.nameIsConstructor(t.key);
  }
  parseClassBody(t, e) {
    this.classScope.enter();
    let s = { hadConstructor: false, hadSuperClass: t }, i = [], r = this.startNode();
    if (r.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (i.length > 0) throw this.raise(l.DecoratorSemicolon, this.state.lastTokEndLoc);
          continue;
        }
        if (this.match(26)) {
          i.push(this.parseDecorator());
          continue;
        }
        let n = this.startNode();
        i.length && (n.decorators = i, this.resetStartLocationFromNode(n, i[0]), i = []), this.parseClassMember(r, n, s), n.kind === "constructor" && n.decorators && n.decorators.length > 0 && this.raise(l.DecoratorConstructor, n);
      }
    }), this.state.strict = e, this.next(), i.length) throw this.raise(l.TrailingDecorator, this.state.startLoc);
    return this.classScope.exit(), this.finishNode(r, "ClassBody");
  }
  parseClassMemberFromModifier(t, e) {
    let s = this.parseIdentifier(true);
    if (this.isClassMethod()) {
      let i = e;
      return i.kind = "method", i.computed = false, i.key = s, i.static = false, this.pushClassMethod(t, i, false, false, false, false), true;
    } else if (this.isClassProperty()) {
      let i = e;
      return i.computed = false, i.key = s, i.static = false, t.body.push(this.parseClassProperty(i)), true;
    }
    return this.resetPreviousNodeTrailingComments(s), false;
  }
  parseClassMember(t, e, s) {
    let i = this.isContextual(106);
    if (i) {
      if (this.parseClassMemberFromModifier(t, e)) return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(t, e);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(t, e, s, i);
  }
  parseClassMemberWithIsStatic(t, e, s, i) {
    let r = e, n = e, o = e, h = e, c2 = e, p = r, u = r;
    if (e.static = i, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
      p.kind = "method";
      let w = this.match(139);
      if (this.parseClassElementName(p), this.parsePostMemberNameModifiers(p), w) {
        this.pushClassPrivateMethod(t, n, true, false);
        return;
      }
      this.isNonstaticConstructor(r) && this.raise(l.ConstructorIsGenerator, r.key), this.pushClassMethod(t, r, true, false, false, false);
      return;
    }
    let f2 = !this.state.containsEsc && S(this.state.type), y2 = this.parseClassElementName(e), b2 = f2 ? y2.name : null, N = this.isPrivateName(y2), I2 = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(u), this.isClassMethod()) {
      if (p.kind = "method", N) {
        this.pushClassPrivateMethod(t, n, false, false);
        return;
      }
      let w = this.isNonstaticConstructor(r), E = false;
      w && (r.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(l.DuplicateConstructor, y2), w && this.hasPlugin("typescript") && e.override && this.raise(l.OverrideOnConstructor, y2), s.hadConstructor = true, E = s.hadSuperClass), this.pushClassMethod(t, r, false, false, w, E);
    } else if (this.isClassProperty()) N ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o);
    else if (b2 === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(y2);
      let w = this.eat(55);
      u.optional && this.unexpected(I2), p.kind = "method";
      let E = this.match(139);
      this.parseClassElementName(p), this.parsePostMemberNameModifiers(u), E ? this.pushClassPrivateMethod(t, n, w, true) : (this.isNonstaticConstructor(r) && this.raise(l.ConstructorIsAsync, r.key), this.pushClassMethod(t, r, w, true, false, false));
    } else if ((b2 === "get" || b2 === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(y2), p.kind = b2;
      let w = this.match(139);
      this.parseClassElementName(r), w ? this.pushClassPrivateMethod(t, n, false, false) : (this.isNonstaticConstructor(r) && this.raise(l.ConstructorIsAccessor, r.key), this.pushClassMethod(t, r, false, false, false, false)), this.checkGetterSetterParams(r);
    } else if (b2 === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y2);
      let w = this.match(139);
      this.parseClassElementName(o), this.pushClassAccessorProperty(t, c2, w);
    } else this.isLineTerminator() ? N ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o) : this.unexpected();
  }
  parseClassElementName(t) {
    let { type: e, value: s } = this.state;
    if ((e === 132 || e === 134) && t.static && s === "prototype" && this.raise(l.StaticPrototype, this.state.startLoc), e === 139) {
      s === "constructor" && this.raise(l.ConstructorClassPrivateField, this.state.startLoc);
      let i = this.parsePrivateName();
      return t.key = i, i;
    }
    return this.parsePropertyName(t), t.key;
  }
  parseClassStaticBlock(t, e) {
    this.scope.enter(720);
    let s = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    let i = e.body = [];
    this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(e, "StaticBlock")), e.decorators?.length && this.raise(l.DecoratorStaticBlock, e);
  }
  pushClassProperty(t, e) {
    !e.computed && this.nameIsConstructor(e.key) && this.raise(l.ConstructorClassField, e.key), t.body.push(this.parseClassProperty(e));
  }
  pushClassPrivateProperty(t, e) {
    let s = this.parseClassPrivateProperty(e);
    t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
  }
  pushClassAccessorProperty(t, e, s) {
    !s && !e.computed && this.nameIsConstructor(e.key) && this.raise(l.ConstructorClassField, e.key);
    let i = this.parseClassAccessorProperty(e);
    t.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
  }
  pushClassMethod(t, e, s, i, r, n) {
    t.body.push(this.parseMethod(e, s, i, r, n, "ClassMethod", true));
  }
  pushClassPrivateMethod(t, e, s, i) {
    let r = this.parseMethod(e, s, i, false, false, "ClassPrivateMethod", true);
    t.body.push(r);
    let n = r.kind === "get" ? r.static ? 6 : 2 : r.kind === "set" ? r.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(r, n);
  }
  declareClassPrivateMethodInScope(t, e) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
  }
  parsePostMemberNameModifiers(t) {
  }
  parseClassPrivateProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
  }
  parseClassProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
  }
  parseClassAccessorProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
  }
  parseInitializer(t) {
    this.scope.enter(592), this.expressionScope.enter(rs$1()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(t, e, s, i = 8331) {
    if (S(this.state.type)) t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, i);
    else if (s || !e) t.id = null;
    else throw this.raise(l.MissingClassName, this.state.startLoc);
  }
  parseClassSuper(t) {
    t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(t, e) {
    let s = this.parseMaybeImportPhase(t, true), i = this.maybeParseExportDefaultSpecifier(t, s), r = !i || this.eat(12), n = r && this.eatExportStar(t), o = n && this.maybeParseExportNamespaceSpecifier(t), h = r && (!o || this.eat(12)), c2 = i || n;
    if (n && !o) {
      if (i && this.unexpected(), e) throw this.raise(l.UnsupportedDecoratorExport, t);
      return this.parseExportFrom(t, true), this.sawUnambiguousESM = true, this.finishNode(t, "ExportAllDeclaration");
    }
    let p = this.maybeParseExportNamedSpecifiers(t);
    i && r && !n && !p && this.unexpected(null, 5), o && h && this.unexpected(null, 98);
    let u;
    if (c2 || p) {
      if (u = false, e) throw this.raise(l.UnsupportedDecoratorExport, t);
      this.parseExportFrom(t, c2);
    } else u = this.maybeParseExportDeclaration(t);
    if (c2 || p || u) {
      let f2 = t;
      if (this.checkExport(f2, true, false, !!f2.source), f2.declaration?.type === "ClassDeclaration") this.maybeTakeDecorators(e, f2.declaration, f2);
      else if (e) throw this.raise(l.UnsupportedDecoratorExport, t);
      return this.sawUnambiguousESM = true, this.finishNode(f2, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      let f2 = t, y2 = this.parseExportDefaultExpression();
      if (f2.declaration = y2, y2.type === "ClassDeclaration") this.maybeTakeDecorators(e, y2, f2);
      else if (e) throw this.raise(l.UnsupportedDecoratorExport, t);
      return this.checkExport(f2, true, true), this.sawUnambiguousESM = true, this.finishNode(f2, "ExportDefaultDeclaration");
    }
    throw this.unexpected(null, 5);
  }
  eatExportStar(t) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(t, e) {
    if (e || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", e?.loc.start);
      let s = e || this.parseIdentifier(true), i = this.startNodeAtNode(s);
      return i.exported = s, t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(t) {
    if (this.isContextual(93)) {
      t.specifiers ?? (t.specifiers = []);
      let e = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), e.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e, "ExportNamespaceSpecifier")), true;
    }
    return false;
  }
  maybeParseExportNamedSpecifiers(t) {
    if (this.match(5)) {
      let e = t;
      e.specifiers || (e.specifiers = []);
      let s = e.exportKind === "type";
      return e.specifiers.push(...this.parseExportSpecifiers(s)), e.source = null, e.attributes = [], e.declaration = null, true;
    }
    return false;
  }
  maybeParseExportDeclaration(t) {
    return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, t.attributes = [], t.declaration = this.parseExportDeclaration(t), true) : false;
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return false;
    let t = this.nextTokenInLineStart();
    return this.isUnparsedContextual(t, "function");
  }
  parseExportDefaultExpression() {
    let t = this.startNode();
    if (this.match(68)) return this.next(), this.parseFunction(t, 5);
    if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
    if (this.match(80)) return this.parseClass(t, true, true);
    if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(l.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
    if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(l.UnsupportedDefaultExport, this.state.startLoc);
    let e = this.parseMaybeAssignAllowIn();
    return this.semicolon(), e;
  }
  parseExportDeclaration(t) {
    return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    let { type: t } = this.state;
    if (S(t)) {
      if (t === 95 && !this.state.containsEsc || t === 100) return false;
      if ((t === 130 || t === 129) && !this.state.containsEsc) {
        let i = this.nextTokenStart(), r = this.input.charCodeAt(i);
        if (r === 123 || this.chStartsBindingIdentifier(r, i) && !this.input.startsWith("from", i)) return this.expectOnePlugin(["flow", "typescript"]), false;
      }
    } else if (!this.match(65)) return false;
    let e = this.nextTokenStart(), s = this.isUnparsedContextual(e, "from");
    if (this.input.charCodeAt(e) === 44 || S(this.state.type) && s) return true;
    if (this.match(65) && s) {
      let i = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
      return i === 34 || i === 39;
    }
    return false;
  }
  parseExportFrom(t, e) {
    this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : e && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    let { type: t } = this.state;
    return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(l.DecoratorBeforeExport, this.state.startLoc), true) : this.isUsing() ? (this.raise(l.UsingDeclarationExport, this.state.startLoc), true) : this.isAwaitUsing() ? (this.raise(l.UsingDeclarationExport, this.state.startLoc), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(t, e, s, i) {
    if (e) {
      if (s) {
        if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
          let r = t.declaration;
          r.type === "Identifier" && r.name === "from" && r.end - r.start === 4 && !r.extra?.parenthesized && this.raise(l.ExportDefaultFromAsIdentifier, r);
        }
      } else if (t.specifiers?.length) for (let r of t.specifiers) {
        let { exported: n } = r, o = n.type === "Identifier" ? n.name : n.value;
        if (this.checkDuplicateExports(r, o), !i && r.local) {
          let { local: h } = r;
          h.type !== "Identifier" ? this.raise(l.ExportBindingIsString, r, { localName: h.value, exportName: o }) : (this.checkReservedWord(h.name, h.loc.start, true, false), this.scope.checkLocalExport(h));
        }
      }
      else if (t.declaration) {
        let r = t.declaration;
        if (r.type === "FunctionDeclaration" || r.type === "ClassDeclaration") {
          let { id: n } = r;
          if (!n) throw new Error("Assertion failure");
          this.checkDuplicateExports(t, n.name);
        } else if (r.type === "VariableDeclaration") for (let n of r.declarations) this.checkDeclaration(n.id);
      }
    }
  }
  checkDeclaration(t) {
    if (t.type === "Identifier") this.checkDuplicateExports(t, t.name);
    else if (t.type === "ObjectPattern") for (let e of t.properties) this.checkDeclaration(e);
    else if (t.type === "ArrayPattern") for (let e of t.elements) e && this.checkDeclaration(e);
    else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
  }
  checkDuplicateExports(t, e) {
    this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(l.DuplicateDefaultExport, t) : this.raise(l.DuplicateExport, t, { exportName: e })), this.exportedIdentifiers.add(e);
  }
  parseExportSpecifiers(t) {
    let e = [], s = true;
    for (this.expect(5); !this.eat(8); ) {
      if (s) s = false;
      else if (this.expect(12), this.eat(8)) break;
      let i = this.isContextual(130), r = this.match(134), n = this.startNode();
      n.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(n, r, t, i));
    }
    return e;
  }
  parseExportSpecifier(t, e, s, i) {
    return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = this.cloneStringLiteral(t.local) : t.exported || (t.exported = this.cloneIdentifier(t.local)), this.finishNode(t, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(134)) {
      let t = this.parseStringLiteral(this.state.value), e = tr$1.exec(t.value);
      return e && this.raise(l.ModuleExportNameHasLoneSurrogate, t, { surrogateCharCode: e[0].charCodeAt(0) }), t;
    }
    return this.parseIdentifier(true);
  }
  isJSONModuleImport(t) {
    return t.assertions != null ? t.assertions.some(({ key: e, value: s }) => s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type")) : false;
  }
  checkImportReflection(t) {
    let { specifiers: e } = t, s = e.length === 1 ? e[0].type : null;
    t.phase === "source" ? s !== "ImportDefaultSpecifier" && this.raise(l.SourcePhaseImportRequiresDefault, e[0].loc.start) : t.phase === "defer" ? s !== "ImportNamespaceSpecifier" && this.raise(l.DeferImportRequiresNamespace, e[0].loc.start) : t.module && (s !== "ImportDefaultSpecifier" && this.raise(l.ImportReflectionNotBinding, e[0].loc.start), t.assertions?.length > 0 && this.raise(l.ImportReflectionHasAssertion, e[0].loc.start));
  }
  checkJSONModuleImport(t) {
    if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
      let { specifiers: e } = t;
      if (e != null) {
        let s = e.find((i) => {
          let r;
          if (i.type === "ExportSpecifier" ? r = i.local : i.type === "ImportSpecifier" && (r = i.imported), r !== void 0) return r.type === "Identifier" ? r.name !== "default" : r.value !== "default";
        });
        s !== void 0 && this.raise(l.ImportJSONBindingNotDefault, s.loc.start);
      }
    }
  }
  isPotentialImportPhase(t) {
    return t ? false : this.isContextual(105) || this.isContextual(97);
  }
  applyImportPhase(t, e, s, i) {
    e || (this.hasPlugin("importReflection") && (t.module = false), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
  }
  parseMaybeImportPhase(t, e) {
    if (!this.isPotentialImportPhase(e)) return this.applyImportPhase(t, e, null), null;
    let s = this.startNode(), i = this.parseIdentifierName(true), { type: r } = this.state;
    return (M$1(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12) ? (this.applyImportPhase(t, e, i, s.loc.start), null) : (this.applyImportPhase(t, e, null), this.createIdentifier(s, i));
  }
  isPrecedingIdImportPhase(t) {
    let { type: e } = this.state;
    return S(e) ? e !== 98 || this.lookaheadCharCode() === 102 : e !== 12;
  }
  parseImport(t) {
    return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, false));
  }
  parseImportSpecifiersAndAfter(t, e) {
    t.specifiers = [];
    let i = !this.maybeParseDefaultImportSpecifier(t, e) || this.eat(12), r = i && this.maybeParseStarImportSpecifier(t);
    return i && !r && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
  }
  parseImportSourceAndAttributes(t) {
    return t.specifiers ?? (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(134) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(t, e, s) {
    e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s));
  }
  finishImportSpecifier(t, e, s = 8201) {
    return this.checkLVal(t.local, { type: e }, s), this.finishNode(t, e);
  }
  parseImportAttributes() {
    this.expect(5);
    let t = [], e = /* @__PURE__ */ new Set();
    do {
      if (this.match(8)) break;
      let s = this.startNode(), i = this.state.value;
      if (e.has(i) && this.raise(l.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i }), e.add(i), this.match(134) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(true), this.expect(14), !this.match(134)) throw this.raise(l.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), t;
  }
  parseModuleAttributes() {
    let t = [], e = /* @__PURE__ */ new Set();
    do {
      let s = this.startNode();
      if (s.key = this.parseIdentifier(true), s.key.name !== "type" && this.raise(l.ModuleAttributeDifferentFromType, s.key), e.has(s.key.name) && this.raise(l.ModuleAttributesWithDuplicateKeys, s.key, { key: s.key.name }), e.add(s.key.name), this.expect(14), !this.match(134)) throw this.raise(l.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return t;
  }
  maybeParseImportAttributes(t) {
    let e;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
      this.next(), e = this.parseImportAttributes();
    } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin("deprecatedImportAssert") || this.raise(l.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", true), this.next(), e = this.parseImportAttributes()) : e = [];
    t.attributes = e;
  }
  maybeParseDefaultImportSpecifier(t, e) {
    if (e) {
      let s = this.startNodeAtNode(e);
      return s.local = e, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), true;
    } else if (M$1(this.state.type)) return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true;
    return false;
  }
  maybeParseStarImportSpecifier(t) {
    if (this.match(55)) {
      let e = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), true;
    }
    return false;
  }
  parseNamedImportSpecifiers(t) {
    let e = true;
    for (this.expect(5); !this.eat(8); ) {
      if (e) e = false;
      else {
        if (this.eat(14)) throw this.raise(l.DestructureNamedImport, this.state.startLoc);
        if (this.expect(12), this.eat(8)) break;
      }
      let s = this.startNode(), i = this.match(134), r = this.isContextual(130);
      s.imported = this.parseModuleExportName();
      let n = this.parseImportSpecifier(s, i, t.importKind === "type" || t.importKind === "typeof", r, void 0);
      t.specifiers.push(n);
    }
  }
  parseImportSpecifier(t, e, s, i, r) {
    if (this.eatContextual(93)) t.local = this.parseIdentifier();
    else {
      let { imported: n } = t;
      if (e) throw this.raise(l.ImportBindingIsString, t, { importName: n.value });
      this.checkReservedWord(n.name, t.loc.start, true, true), t.local || (t.local = this.cloneIdentifier(n));
    }
    return this.finishImportSpecifier(t, "ImportSpecifier", r);
  }
  isThisParam(t) {
    return t.type === "Identifier" && t.name === "this";
  }
}, Ce$1 = class Ce extends lt$1 {
  constructor(t, e, s) {
    let i = ti$1(t);
    super(i, e), this.options = i, this.initializeScopes(), this.plugins = s, this.filename = i.sourceFilename, this.startIndex = i.startIndex;
    let r = 0;
    i.allowAwaitOutsideFunction && (r |= 1), i.allowReturnOutsideFunction && (r |= 2), i.allowImportExportEverywhere && (r |= 8), i.allowSuperOutsideMethod && (r |= 16), i.allowUndeclaredExports && (r |= 64), i.allowNewTargetOutsideFunction && (r |= 4), i.allowYieldOutsideFunction && (r |= 32), i.ranges && (r |= 128), i.tokens && (r |= 256), i.createImportExpressions && (r |= 512), i.createParenthesizedExpressions && (r |= 1024), i.errorRecovery && (r |= 2048), i.attachComment && (r |= 4096), i.annexB && (r |= 8192), this.optionFlags = r;
  }
  getScopeHandler() {
    return ue$1;
  }
  parse() {
    this.enterInitialScopes();
    let t = this.startNode(), e = this.startNode();
    this.nextToken(), t.errors = null;
    let s = this.parseTopLevel(t, e);
    return s.errors = this.state.errors, s.comments.length = this.state.commentsLen, s;
  }
};
function Ee(a2, t) {
  if (t?.sourceType === "unambiguous") {
    t = Object.assign({}, t);
    try {
      t.sourceType = "module";
      let e = ce$1(t, a2), s = e.parse();
      if (e.sawUnambiguousESM) return s;
      if (e.ambiguousScriptDifferentAst) try {
        return t.sourceType = "script", ce$1(t, a2).parse();
      } catch {
      }
      else s.program.sourceType = "script";
      return s;
    } catch (e) {
      try {
        return t.sourceType = "script", ce$1(t, a2).parse();
      } catch {
      }
      throw e;
    }
  } else return ce$1(t, a2).parse();
}
function Ie$1(a2, t) {
  let e = ce$1(t, a2);
  return e.options.strictMode && (e.state.strict = true), e.getExpression();
}
function ir$1(a2) {
  let t = {};
  for (let e of Object.keys(a2)) t[e] = Jt$1(a2[e]);
  return t;
}
ir$1(ai$1);
function ce$1(a2, t) {
  let e = Ce$1, s = /* @__PURE__ */ new Map();
  if (a2?.plugins) {
    for (let i of a2.plugins) {
      let r, n;
      typeof i == "string" ? r = i : [r, n] = i, s.has(r) || s.set(r, n || {});
    }
    Qi$1(s), e = rr$1(s);
  }
  return new e(a2, t, s);
}
var Kt$1 = /* @__PURE__ */ new Map();
function rr$1(a2) {
  let t = [];
  for (let i of Zi$1) a2.has(i) && t.push(i);
  let e = t.join("|"), s = Kt$1.get(e);
  if (!s) {
    s = Ce$1;
    for (let i of t) s = os$1[i](s);
    Kt$1.set(e, s);
  }
  return s;
}
function Ne$1(a2) {
  return (t, e, s) => {
    let i = !!s?.backwards;
    if (e === false) return false;
    let { length: r } = t, n = e;
    for (; n >= 0 && n < r; ) {
      let o = t.charAt(n);
      if (a2 instanceof RegExp) {
        if (!a2.test(o)) return n;
      } else if (!a2.includes(o)) return n;
      i ? n-- : n++;
    }
    return n === -1 || n === r ? n : false;
  };
}
var hs$1 = Ne$1(" 	"), cs$1 = Ne$1(/[^\n\r]/u);
function ar(a2, t) {
  if (t === false) return false;
  if (a2.charAt(t) === "/" && a2.charAt(t + 1) === "*") {
    for (let e = t + 2; e < a2.length; ++e) if (a2.charAt(e) === "*" && a2.charAt(e + 1) === "/") return e + 2;
  }
  return t;
}
var ls$1 = ar;
var ps$1 = (a2) => a2 === `
` || a2 === "\r" || a2 === "\u2028" || a2 === "\u2029";
function nr$1(a2, t, e) {
  let s = !!e?.backwards;
  if (t === false) return false;
  let i = a2.charAt(t);
  if (s) {
    if (a2.charAt(t - 1) === "\r" && i === `
`) return t - 2;
    if (ps$1(i)) return t - 1;
  } else {
    if (i === "\r" && a2.charAt(t + 1) === `
`) return t + 2;
    if (ps$1(i)) return t + 1;
  }
  return t;
}
var us$1 = nr$1;
function or(a2, t) {
  return t === false ? false : a2.charAt(t) === "/" && a2.charAt(t + 1) === "/" ? cs$1(a2, t) : t;
}
var fs$1 = or;
function hr$1(a2, t) {
  let e = null, s = t;
  for (; s !== e; ) e = s, s = hs$1(a2, s), s = ls$1(a2, s), s = fs$1(a2, s), s = us$1(a2, s);
  return s;
}
var ds$1 = hr$1;
function ms$2(a2) {
  let t = [];
  for (let e of a2) try {
    return e();
  } catch (s) {
    t.push(s);
  }
  throw Object.assign(new Error("All combinations failed"), { errors: t });
}
function cr$1(a2) {
  if (!a2.startsWith("#!")) return "";
  let t = a2.indexOf(`
`);
  return t === -1 ? a2 : a2.slice(0, t);
}
var ke$1 = cr$1;
var Z = (a2, t) => (e, s, ...i) => e | 1 && s == null ? void 0 : (t.call(s) ?? s[a2]).apply(s, i);
var lr$1 = Array.prototype.findLast ?? function(a2) {
  for (let t = this.length - 1; t >= 0; t--) {
    let e = this[t];
    if (a2(e, t, this)) return e;
  }
}, pr = Z("findLast", function() {
  if (Array.isArray(this)) return lr$1;
}), ys$1 = pr;
function ur$1(a2) {
  return this[a2 < 0 ? this.length + a2 : a2];
}
var fr$1 = Z("at", function() {
  if (Array.isArray(this) || typeof this == "string") return ur$1;
}), xs$1 = fr$1;
function D(a2) {
  let t = a2.range?.[0] ?? a2.start, e = (a2.declaration?.decorators ?? a2.decorators)?.[0];
  return e ? Math.min(D(e), t) : t;
}
function v$1(a2) {
  return a2.range?.[1] ?? a2.end;
}
function dr$1(a2) {
  let t = new Set(a2);
  return (e) => t.has(e?.type);
}
var ee$1 = dr$1;
var mr$1 = ee$1(["Block", "CommentBlock", "MultiLine"]), te = mr$1;
var yr$1 = ee$1(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), Ps$1 = yr$1;
var bt$1 = /* @__PURE__ */ new WeakMap();
function xr$1(a2) {
  return bt$1.has(a2) || bt$1.set(a2, te(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a2.value)), bt$1.get(a2);
}
var gs$1 = xr$1;
function Pr$1(a2) {
  if (!te(a2)) return false;
  let t = `*${a2.value}*`.split(`
`);
  return t.length > 1 && t.every((e) => e.trimStart()[0] === "*");
}
var At$1 = /* @__PURE__ */ new WeakMap();
function gr$1(a2) {
  return At$1.has(a2) || At$1.set(a2, Pr$1(a2)), At$1.get(a2);
}
var St$1 = gr$1;
function Tr$1(a2) {
  if (a2.length < 2) return;
  let t;
  for (let e = a2.length - 1; e >= 0; e--) {
    let s = a2[e];
    if (t && v$1(s) === D(t) && St$1(s) && St$1(t) && (a2.splice(e + 1, 1), s.value += "*//*" + t.value, s.range = [D(s), v$1(t)]), !Ps$1(s) && !te(s)) throw new TypeError(`Unknown comment type: "${s.type}".`);
    t = s;
  }
}
var Ts$1 = Tr$1;
var de$1 = null;
function me$1(a2) {
  if (de$1 !== null && typeof de$1.property) {
    let t = de$1;
    return de$1 = me$1.prototype = null, t;
  }
  return de$1 = me$1.prototype = a2 ?? /* @__PURE__ */ Object.create(null), new me$1();
}
var br = 10;
for (let a2 = 0; a2 <= br; a2++) me$1();
function wt$1(a2) {
  return me$1(a2);
}
function Ar$1(a2, t = "type") {
  wt$1(a2);
  function e(s) {
    let i = s[t], r = a2[i];
    if (!Array.isArray(r)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
    return r;
  }
  return e;
}
var bs$1 = Ar$1;
var As$1 = { AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], AnyTypeAnnotation: [], ArgumentPlaceholder: [], ArrayExpression: ["elements"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrayTypeAnnotation: ["elementType"], ArrowFunctionExpression: ["typeParameters", "params", "predicate", "returnType", "body"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], AwaitExpression: ["argument"], BigIntLiteral: [], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], BinaryExpression: ["left", "right"], BindExpression: ["object", "callee"], BlockStatement: ["directives", "body"], BooleanLiteral: [], BooleanLiteralTypeAnnotation: [], BooleanTypeAnnotation: [], BreakStatement: ["label"], CallExpression: ["callee", "typeArguments", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassAccessorProperty: ["decorators", "key", "typeAnnotation", "value"], ClassBody: ["body"], ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeArguments", "mixins", "implements", "body", "superTypeParameters"], ClassExpression: ["decorators", "id", "typeParameters", "superClass", "superTypeArguments", "mixins", "implements", "body", "superTypeParameters"], ClassImplements: ["id", "typeParameters"], ClassMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ClassPrivateMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ClassPrivateProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalExpression: ["test", "consequent", "alternate"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], ContinueStatement: ["label"], DebuggerStatement: [], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclaredPredicate: ["value"], DeclareEnum: ["id", "body"], DeclareExportAllDeclaration: ["source", "attributes"], DeclareExportDeclaration: ["declaration", "specifiers", "source", "attributes"], DeclareFunction: ["id", "predicate"], DeclareHook: ["id"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareNamespace: ["id", "body"], DeclareOpaqueType: ["id", "typeParameters", "supertype", "lowerBound", "upperBound"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareVariable: ["id"], Decorator: ["expression"], Directive: ["value"], DirectiveLiteral: [], DoExpression: ["body"], DoWhileStatement: ["body", "test"], EmptyStatement: [], EmptyTypeAnnotation: [], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], EnumBooleanBody: ["members"], EnumBooleanMember: ["id", "init"], EnumDeclaration: ["id", "body"], EnumDefaultedMember: ["id"], EnumNumberBody: ["members"], EnumNumberMember: ["id", "init"], EnumStringBody: ["members"], EnumStringMember: ["id", "init"], EnumSymbolBody: ["members"], ExistsTypeAnnotation: [], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportDefaultSpecifier: ["exported"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportNamespaceSpecifier: ["exported"], ExportSpecifier: ["local", "exported"], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionExpression: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionTypeAnnotation: ["typeParameters", "this", "params", "rest", "returnType"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], ImportAttribute: ["key", "value"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportExpression: ["source", "options"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], IndexedAccessType: ["objectType", "indexType"], InferredPredicate: [], InferTypeAnnotation: ["typeParameter"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceExtends: ["id", "typeParameters"], InterfaceTypeAnnotation: ["extends", "body"], InterpreterDirective: [], IntersectionTypeAnnotation: ["types"], JsExpressionRoot: ["node"], JsonRoot: ["node"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXClosingFragment: [], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "typeArguments", "attributes"], JSXOpeningFragment: [], JSXSpreadAttribute: ["argument"], JSXSpreadChild: ["expression"], JSXText: [], KeyofTypeAnnotation: ["argument"], LabeledStatement: ["label", "body"], Literal: [], LogicalExpression: ["left", "right"], MatchArrayPattern: ["elements", "rest"], MatchAsPattern: ["pattern", "target"], MatchBindingPattern: ["id"], MatchExpression: ["argument", "cases"], MatchExpressionCase: ["pattern", "body", "guard"], MatchIdentifierPattern: ["id"], MatchLiteralPattern: ["literal"], MatchMemberPattern: ["base", "property"], MatchObjectPattern: ["properties", "rest"], MatchObjectPatternProperty: ["key", "pattern"], MatchOrPattern: ["patterns"], MatchRestPattern: ["argument"], MatchStatement: ["argument", "cases"], MatchStatementCase: ["pattern", "body", "guard"], MatchUnaryPattern: ["argument"], MatchWildcardPattern: [], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["decorators", "key", "value"], MixedTypeAnnotation: [], ModuleExpression: ["body"], NeverTypeAnnotation: [], NewExpression: ["callee", "typeArguments", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxAs: ["key", "alias"], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKey: [], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGPipeExpression: ["left", "right", "arguments"], NGRoot: ["node"], NullableTypeAnnotation: ["typeAnnotation"], NullLiteral: [], NullLiteralTypeAnnotation: [], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], NumericLiteral: [], ObjectExpression: ["properties"], ObjectMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], ObjectProperty: ["decorators", "key", "value"], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["variance", "id", "key", "value"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype", "lowerBound", "upperBound"], OptionalCallExpression: ["callee", "typeArguments", "arguments"], OptionalIndexedAccessType: ["objectType", "indexType"], OptionalMemberExpression: ["object", "property"], ParenthesizedExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], PipelineTopicExpression: ["expression"], Placeholder: [], PrivateIdentifier: [], PrivateName: ["id"], Program: ["directives", "body"], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], QualifiedTypeIdentifier: ["qualification", "id"], QualifiedTypeofIdentifier: ["qualification", "id"], RegExpLiteral: [], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SatisfiesExpression: ["expression", "typeAnnotation"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], StaticBlock: ["body"], StringLiteral: [], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], Super: [], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], SymbolTypeAnnotation: [], TaggedTemplateExpression: ["tag", "typeArguments", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThisTypeAnnotation: [], ThrowStatement: ["argument"], TopicReference: [], TryStatement: ["block", "handler", "finalizer"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAnyKeyword: [], TSArrayType: ["elementType"], TSAsExpression: ["expression", "typeAnnotation"], TSAsyncKeyword: [], TSBigIntKeyword: [], TSBooleanKeyword: [], TSCallSignatureDeclaration: ["typeParameters", "params", "returnType"], TSClassImplements: ["expression", "typeArguments"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSConstructorType: ["typeParameters", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "params", "returnType"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareKeyword: [], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSEnumDeclaration: ["id", "body"], TSEnumMember: ["id", "initializer"], TSExportAssignment: ["expression"], TSExportKeyword: [], TSExternalModuleReference: ["expression"], TSFunctionType: ["typeParameters", "params", "returnType"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSImportType: ["options", "qualifier", "typeArguments", "source"], TSIndexedAccessType: ["objectType", "indexType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSInferType: ["typeParameter"], TSInstantiationExpression: ["expression", "typeArguments"], TSInterfaceBody: ["body"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceHeritage: ["expression", "typeArguments"], TSIntersectionType: ["types"], TSIntrinsicKeyword: [], TSJSDocAllType: [], TSJSDocNonNullableType: ["typeAnnotation"], TSJSDocNullableType: ["typeAnnotation"], TSJSDocUnknownType: [], TSLiteralType: ["literal"], TSMappedType: ["key", "constraint", "nameType", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "params", "returnType"], TSModuleBlock: ["body"], TSModuleDeclaration: ["id", "body"], TSNamedTupleMember: ["label", "elementType"], TSNamespaceExportDeclaration: ["id"], TSNeverKeyword: [], TSNonNullExpression: ["expression"], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSOptionalType: ["typeAnnotation"], TSParameterProperty: ["parameter", "decorators"], TSParenthesizedType: ["typeAnnotation"], TSPrivateKeyword: [], TSPropertySignature: ["key", "typeAnnotation"], TSProtectedKeyword: [], TSPublicKeyword: [], TSQualifiedName: ["left", "right"], TSReadonlyKeyword: [], TSRestType: ["typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSStaticKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSTemplateLiteralType: ["quasis", "types"], TSThisType: [], TSTupleType: ["elementTypes"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSTypeAnnotation: ["typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSTypeLiteral: ["members"], TSTypeOperator: ["typeAnnotation"], TSTypeParameter: ["name", "constraint", "default"], TSTypeParameterDeclaration: ["params"], TSTypeParameterInstantiation: ["params"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeArguments"], TSTypeReference: ["typeName", "typeArguments"], TSUndefinedKeyword: [], TSUnionType: ["types"], TSUnknownKeyword: [], TSVoidKeyword: [], TupleTypeAnnotation: ["types", "elementTypes"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeOperator: ["typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], TypePredicate: ["parameterName", "typeAnnotation"], UnaryExpression: ["argument"], UndefinedTypeAnnotation: [], UnionTypeAnnotation: ["types"], UnknownTypeAnnotation: [], UpdateExpression: ["argument"], V8IntrinsicIdentifier: [], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], Variance: [], VoidPattern: [], VoidTypeAnnotation: [], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] };
var Sr = bs$1(As$1), Ss$1 = Sr;
function Ct$1(a2, t) {
  if (!(a2 !== null && typeof a2 == "object")) return a2;
  if (Array.isArray(a2)) {
    for (let s = 0; s < a2.length; s++) a2[s] = Ct$1(a2[s], t);
    return a2;
  }
  t.onEnter && (a2 = t.onEnter(a2) || a2);
  let e = Ss$1(a2);
  for (let s = 0; s < e.length; s++) a2[e[s]] = Ct$1(a2[e[s]], t);
  return t.onLeave(a2) || a2;
}
var ws$1 = Ct$1;
ee$1(["RegExpLiteral", "BigIntLiteral", "NumericLiteral", "StringLiteral", "DirectiveLiteral", "Literal", "JSXText", "TemplateElement", "StringLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation"]);
function wr$1(a2, t) {
  let { parser: e, text: s } = t, { comments: i } = a2, r = e === "oxc" && t.oxcAstType === "ts";
  Ts$1(i);
  let n;
  a2 = ws$1(a2, { onLeave(h) {
    switch (h.type) {
      case "ParenthesizedExpression": {
        let { expression: c2 } = h, p = D(h);
        if (c2.type === "TypeCastExpression") return c2.range = [p, v$1(h)], c2;
        let u = false;
        if (!r) {
          if (!n) {
            n = [];
            for (let y2 of i) gs$1(y2) && n.push(v$1(y2));
          }
          let f2 = ys$1(0, n, (y2) => y2 <= p);
          u = f2 && s.slice(f2, p).trim().length === 0;
        }
        if (!u) return c2.extra = { ...c2.extra, parenthesized: true }, c2;
        break;
      }
      case "LogicalExpression":
        if (Cs$1(h)) return Et$1(h);
        break;
      case "TemplateLiteral":
        if (h.expressions.length !== h.quasis.length - 1) throw new Error("Malformed template literal.");
        break;
      case "TemplateElement":
        if (e === "flow" || e === "hermes" || e === "espree" || e === "typescript" || r) {
          let c2 = D(h) + 1, p = v$1(h) - (h.tail ? 1 : 2);
          h.range = [c2, p];
        }
        break;
      case "VariableDeclaration": {
        let c2 = xs$1(0, h.declarations, -1);
        c2?.init && s[v$1(c2)] !== ";" && (h.range = [D(h), v$1(c2)]);
        break;
      }
      case "TSParenthesizedType":
        return h.typeAnnotation;
      case "TopicReference":
        a2.extra = { ...a2.extra, __isUsingHackPipeline: true };
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (h.types.length === 1) return h.types[0];
        break;
      case "ImportExpression":
        e === "hermes" && h.attributes && !h.options && (h.options = h.attributes);
        break;
      case "TSImportType":
        !h.source && h.argument.type === "TSLiteralType" && (h.source = h.argument.literal, delete h.argument);
        break;
    }
  } });
  let o = a2.type === "File" ? a2.program : a2;
  return o.interpreter && (i.unshift(o.interpreter), delete o.interpreter), r && a2.hashbang && (i.unshift(a2.hashbang), delete a2.hashbang), a2.type === "Program" && (a2.range = [0, s.length]), a2;
}
function Cs$1(a2) {
  return a2.type === "LogicalExpression" && a2.right.type === "LogicalExpression" && a2.operator === a2.right.operator;
}
function Et$1(a2) {
  return Cs$1(a2) ? Et$1({ type: "LogicalExpression", operator: a2.operator, left: Et$1({ type: "LogicalExpression", operator: a2.operator, left: a2.left, right: a2.right.left, range: [D(a2.left), v$1(a2.right.left)] }), right: a2.right.right, range: [D(a2), v$1(a2)] }) : a2;
}
var Es$1 = wr$1;
function Cr$1(a2, t) {
  let e = new SyntaxError(a2 + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
  return Object.assign(e, t);
}
var ve$1 = Cr$1;
var Is$1 = "Unexpected parseExpression() input: ";
function Er$1(a2) {
  let { message: t, loc: e, reasonCode: s } = a2;
  if (!e) return a2;
  let { line: i, column: r } = e, n = a2;
  (s === "MissingPlugin" || s === "MissingOneOfPlugins") && (t = "Unexpected token.", n = void 0);
  let o = ` (${i}:${r})`;
  return t.endsWith(o) && (t = t.slice(0, -o.length)), t.startsWith(Is$1) && (t = t.slice(Is$1.length)), ve$1(t, { loc: { start: { line: i, column: r + 1 } }, cause: n });
}
var Le$1 = Er$1;
var Ir$1 = String.prototype.replaceAll ?? function(a2, t) {
  return a2.global ? this.replace(a2, t) : this.split(a2).join(t);
}, Nr$1 = Z("replaceAll", function() {
  if (typeof this == "string") return Ir$1;
}), ye$1 = Nr$1;
var kr$1 = /\*\/$/, vr$1 = /^\/\*\*?/, Lr$1 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Dr$1 = /(^|\s+)\/\/([^\n\r]*)/g, Ns$1 = /^(\r?\n)+/, Mr$1 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ks$1 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Or$1 = /(\r?\n|^) *\* ?/g, Fr$1 = [];
function vs$1(a2) {
  let t = a2.match(Lr$1);
  return t ? t[0].trimStart() : "";
}
function Ls$1(a2) {
  a2 = ye$1(0, a2.replace(vr$1, "").replace(kr$1, ""), Or$1, "$1");
  let e = "";
  for (; e !== a2; ) e = a2, a2 = ye$1(0, a2, Mr$1, `
$1 $2
`);
  a2 = a2.replace(Ns$1, "").trimEnd();
  let s = /* @__PURE__ */ Object.create(null), i = ye$1(0, a2, ks$1, "").replace(Ns$1, "").trimEnd(), r;
  for (; r = ks$1.exec(a2); ) {
    let n = ye$1(0, r[2], Dr$1, "");
    if (typeof s[r[1]] == "string" || Array.isArray(s[r[1]])) {
      let o = s[r[1]];
      s[r[1]] = [...Fr$1, ...Array.isArray(o) ? o : [o], n];
    } else s[r[1]] = n;
  }
  return { comments: i, pragmas: s };
}
var Ds$1 = ["noformat", "noprettier"], Ms$1 = ["format", "prettier"];
function Os$1(a2) {
  let t = ke$1(a2);
  t && (a2 = a2.slice(t.length + 1));
  let e = vs$1(a2), { pragmas: s, comments: i } = Ls$1(e);
  return { shebang: t, text: a2, pragmas: s, comments: i };
}
function Fs$1(a2) {
  let { pragmas: t } = Os$1(a2);
  return Ms$1.some((e) => Object.prototype.hasOwnProperty.call(t, e));
}
function Bs$1(a2) {
  let { pragmas: t } = Os$1(a2);
  return Ds$1.some((e) => Object.prototype.hasOwnProperty.call(t, e));
}
function Br(a2) {
  return a2 = typeof a2 == "function" ? { parse: a2 } : a2, { astFormat: "estree", hasPragma: Fs$1, hasIgnorePragma: Bs$1, locStart: D, locEnd: v$1, ...a2 };
}
var H$1 = Br;
var De = "module";
var It$1 = "commonjs";
function Rs$1(a2) {
  if (typeof a2 == "string") {
    if (a2 = a2.toLowerCase(), /\.(?:mjs|mts)$/iu.test(a2)) return De;
    if (/\.(?:cjs|cts)$/iu.test(a2)) return It$1;
  }
}
function Rr$1(a2, t) {
  let { type: e = "JsExpressionRoot", rootMarker: s, text: i } = t, { tokens: r, comments: n } = a2;
  return delete a2.tokens, delete a2.comments, { tokens: r, comments: n, type: e, node: a2, range: [0, i.length], rootMarker: s };
}
var Me$1 = Rr$1;
var se$1 = (a2) => H$1(zr$1(a2)), Ur$1 = { sourceType: De, allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, attachComment: false, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }], ["discardBinding", { syntaxType: "void" }]], tokens: false, ranges: false }, Us$1 = "v8intrinsic", _s$1 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "fsharp" }]], U$1 = (a2, t = Ur$1) => ({ ...t, plugins: [...t.plugins, ...a2] }), _r$1 = /@(?:no)?flow\b/u;
function jr$1(a2, t) {
  if (t?.endsWith(".js.flow")) return true;
  let e = ke$1(a2);
  e && (a2 = a2.slice(e.length));
  let s = ds$1(a2, 0);
  return s !== false && (a2 = a2.slice(0, s)), _r$1.test(a2);
}
function Vr$1(a2, t, e) {
  let s = a2(t, e), i = s.errors.find((r) => !qr$1.has(r.reasonCode));
  if (i) throw i;
  return s;
}
function zr$1({ isExpression: a2 = false, optionsCombinations: t }) {
  return (e, s = {}) => {
    let { filepath: i } = s;
    if (typeof i != "string" && (i = void 0), (s.parser === "babel" || s.parser === "__babel_estree") && jr$1(e, i)) return s.parser = "babel-flow", Vs.parse(e, s);
    let r = t, n = s.__babelSourceType ?? Rs$1(i);
    n && n !== De && (r = r.map((p) => ({ ...p, sourceType: n, ...n === It$1 ? { allowReturnOutsideFunction: void 0, allowNewTargetOutsideFunction: void 0 } : void 0 })));
    let o = /%[A-Z]/u.test(e);
    e.includes("|>") ? r = (o ? [..._s$1, Us$1] : _s$1).flatMap((u) => r.map((f2) => U$1([u], f2))) : o && (r = r.map((p) => U$1([Us$1], p)));
    let h = a2 ? Ie$1 : Ee, c2;
    try {
      c2 = ms$2(r.map((p) => () => Vr$1(h, e, p)));
    } catch ({ errors: [p] }) {
      throw Le$1(p);
    }
    return a2 && (c2 = Me$1(c2, { text: e, rootMarker: s.rootMarker })), Es$1(c2, { text: e });
  };
}
var qr$1 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport", "ImportAttributesUseAssert", "DeclarationMissingInitializer"]), js$1 = [U$1(["jsx"])], $r$1 = se$1({ optionsCombinations: js$1 }), Hr$1 = se$1({ optionsCombinations: [U$1(["jsx", "typescript"]), U$1(["typescript"])] }), Kr$1 = se$1({ isExpression: true, optionsCombinations: [U$1(["jsx"])] }), Wr$1 = se$1({ isExpression: true, optionsCombinations: [U$1(["typescript"])] }), Vs = se$1({ optionsCombinations: [U$1(["jsx", ["flow", { all: true }], "flowComments"])] }), Jr$1 = se$1({ optionsCombinations: js$1.map((a2) => U$1(["estree"], a2)) });
var vt$1 = {};
Fe$1(vt$1, { json: () => Yr$1, "json-stringify": () => ea$1, json5: () => Qr$1, jsonc: () => Zr$1 });
function Gr$1(a2) {
  return Array.isArray(a2) && a2.length > 0;
}
var kt$1 = Gr$1;
var zs$1 = { tokens: false, ranges: false, attachComment: false, createParenthesizedExpressions: true };
function Xr$1(a2) {
  let t = Ee(a2, zs$1), { program: e } = t;
  if (e.body.length === 0 && e.directives.length === 0 && !e.interpreter) return t;
}
function Oe$1(a2, t = {}) {
  let { allowComments: e = true, allowEmpty: s = false } = t, i;
  try {
    i = Ie$1(a2, zs$1);
  } catch (r) {
    if (s && r.code === "BABEL_PARSER_SYNTAX_ERROR" && r.reasonCode === "ParseExpressionEmptyInput") try {
      i = Xr$1(a2);
    } catch {
    }
    if (!i) throw Le$1(r);
  }
  if (!e && kt$1(i.comments)) throw z$1(i.comments[0], "Comment");
  return i = Me$1(i, { type: "JsonRoot", text: a2 }), i.node.type === "File" ? delete i.node : ie$1(i.node), i;
}
function z$1(a2, t) {
  let [e, s] = [a2.loc.start, a2.loc.end].map(({ line: i, column: r }) => ({ line: i, column: r + 1 }));
  return ve$1(`${t} is not allowed in JSON.`, { loc: { start: e, end: s } });
}
function ie$1(a2) {
  switch (a2.type) {
    case "ArrayExpression":
      for (let t of a2.elements) t !== null && ie$1(t);
      return;
    case "ObjectExpression":
      for (let t of a2.properties) ie$1(t);
      return;
    case "ObjectProperty":
      if (a2.computed) throw z$1(a2.key, "Computed key");
      if (a2.shorthand) throw z$1(a2.key, "Shorthand property");
      a2.key.type !== "Identifier" && ie$1(a2.key), ie$1(a2.value);
      return;
    case "UnaryExpression": {
      let { operator: t, argument: e } = a2;
      if (t !== "+" && t !== "-") throw z$1(a2, `Operator '${a2.operator}'`);
      if (e.type === "NumericLiteral" || e.type === "Identifier" && (e.name === "Infinity" || e.name === "NaN")) return;
      throw z$1(e, `Operator '${t}' before '${e.type}'`);
    }
    case "Identifier":
      if (a2.name !== "Infinity" && a2.name !== "NaN" && a2.name !== "undefined") throw z$1(a2, `Identifier '${a2.name}'`);
      return;
    case "TemplateLiteral":
      if (kt$1(a2.expressions)) throw z$1(a2.expressions[0], "'TemplateLiteral' with expression");
      for (let t of a2.quasis) ie$1(t);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw z$1(a2, `'${a2.type}'`);
  }
}
var Yr$1 = H$1({ parse: (a2) => Oe$1(a2), hasPragma: () => true, hasIgnorePragma: () => false }), Qr$1 = H$1((a2) => Oe$1(a2)), Zr$1 = H$1((a2) => Oe$1(a2, { allowEmpty: true })), ea$1 = H$1({ parse: (a2) => Oe$1(a2, { allowComments: false }), astFormat: "estree-json" });
var ta$1 = { ...Nt$1, ...vt$1 };
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var lib$7 = {};
var context$1 = {};
var traverseNode = {};
var context = {};
var path = {};
var virtualTypes = {};
var hasRequiredVirtualTypes;
function requireVirtualTypes() {
  if (hasRequiredVirtualTypes) return virtualTypes;
  hasRequiredVirtualTypes = 1;
  Object.defineProperty(virtualTypes, "__esModule", {
    value: true
  });
  virtualTypes.Var = virtualTypes.User = virtualTypes.Statement = virtualTypes.SpreadProperty = virtualTypes.Scope = virtualTypes.RestProperty = virtualTypes.ReferencedMemberExpression = virtualTypes.ReferencedIdentifier = virtualTypes.Referenced = virtualTypes.Pure = virtualTypes.NumericLiteralTypeAnnotation = virtualTypes.Generated = virtualTypes.ForAwaitStatement = virtualTypes.Flow = virtualTypes.Expression = virtualTypes.ExistentialTypeParam = virtualTypes.BlockScoped = virtualTypes.BindingIdentifier = void 0;
  virtualTypes.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
  virtualTypes.ReferencedMemberExpression = ["MemberExpression"];
  virtualTypes.BindingIdentifier = ["Identifier"];
  virtualTypes.Statement = ["Statement"];
  virtualTypes.Expression = ["Expression"];
  virtualTypes.Scope = ["Scopable", "Pattern"];
  virtualTypes.Referenced = null;
  virtualTypes.BlockScoped = ["FunctionDeclaration", "ClassDeclaration", "VariableDeclaration"];
  virtualTypes.Var = ["VariableDeclaration"];
  virtualTypes.User = null;
  virtualTypes.Generated = null;
  virtualTypes.Pure = null;
  virtualTypes.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  virtualTypes.RestProperty = ["RestElement"];
  virtualTypes.SpreadProperty = ["RestElement"];
  virtualTypes.ExistentialTypeParam = ["ExistsTypeAnnotation"];
  virtualTypes.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  virtualTypes.ForAwaitStatement = ["ForOfStatement"];
  return virtualTypes;
}
var browser = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms$1;
  hasRequiredMs = 1;
  var s = 1e3;
  var m2 = s * 60;
  var h = m2 * 60;
  var d2 = h * 24;
  var w = d2 * 7;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns2 of split) {
        if (ns2[0] === "-") {
          createDebug.skips.push(ns2.slice(1));
        } else {
          createDebug.names.push(ns2);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns2 of createDebug.names) {
        if (matchesTemplate(name, ns2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports$1.storage.getItem("debug") || exports$1.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = requireCommon()(exports$1);
    const { formatters: formatters2 } = module2.exports;
    formatters2.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var scope = {};
var renamer = {};
var lib$6 = {};
var isReactComponent = {};
var buildMatchMemberExpression = {};
var matchesPattern = {};
var generated$3 = {};
var shallowEqual = {};
var hasRequiredShallowEqual;
function requireShallowEqual() {
  if (hasRequiredShallowEqual) return shallowEqual;
  hasRequiredShallowEqual = 1;
  Object.defineProperty(shallowEqual, "__esModule", {
    value: true
  });
  shallowEqual.default = shallowEqual$1;
  function shallowEqual$1(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }
  return shallowEqual;
}
var deprecationWarning = {};
var hasRequiredDeprecationWarning;
function requireDeprecationWarning() {
  if (hasRequiredDeprecationWarning) return deprecationWarning;
  hasRequiredDeprecationWarning = 1;
  Object.defineProperty(deprecationWarning, "__esModule", {
    value: true
  });
  deprecationWarning.default = deprecationWarning$1;
  const warnings = /* @__PURE__ */ new Set();
  function deprecationWarning$1(oldName, newName, prefix = "", cacheKey = oldName) {
    if (warnings.has(cacheKey)) return;
    warnings.add(cacheKey);
    const {
      internal,
      trace
    } = captureShortStackTrace(1, 2);
    if (internal) {
      return;
    }
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
  }
  function captureShortStackTrace(skip, length) {
    const {
      stackTraceLimit,
      prepareStackTrace
    } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace) return {
      internal: false,
      trace: ""
    };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
    };
  }
  return deprecationWarning;
}
var hasRequiredGenerated$3;
function requireGenerated$3() {
  if (hasRequiredGenerated$3) return generated$3;
  hasRequiredGenerated$3 = 1;
  Object.defineProperty(generated$3, "__esModule", {
    value: true
  });
  generated$3.isAccessor = isAccessor;
  generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
  generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
  generated$3.isArrayExpression = isArrayExpression;
  generated$3.isArrayPattern = isArrayPattern;
  generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
  generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
  generated$3.isAssignmentExpression = isAssignmentExpression;
  generated$3.isAssignmentPattern = isAssignmentPattern;
  generated$3.isAwaitExpression = isAwaitExpression;
  generated$3.isBigIntLiteral = isBigIntLiteral;
  generated$3.isBinary = isBinary;
  generated$3.isBinaryExpression = isBinaryExpression;
  generated$3.isBindExpression = isBindExpression;
  generated$3.isBlock = isBlock;
  generated$3.isBlockParent = isBlockParent;
  generated$3.isBlockStatement = isBlockStatement;
  generated$3.isBooleanLiteral = isBooleanLiteral;
  generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  generated$3.isBreakStatement = isBreakStatement;
  generated$3.isCallExpression = isCallExpression;
  generated$3.isCatchClause = isCatchClause;
  generated$3.isClass = isClass;
  generated$3.isClassAccessorProperty = isClassAccessorProperty;
  generated$3.isClassBody = isClassBody;
  generated$3.isClassDeclaration = isClassDeclaration;
  generated$3.isClassExpression = isClassExpression;
  generated$3.isClassImplements = isClassImplements;
  generated$3.isClassMethod = isClassMethod;
  generated$3.isClassPrivateMethod = isClassPrivateMethod;
  generated$3.isClassPrivateProperty = isClassPrivateProperty;
  generated$3.isClassProperty = isClassProperty;
  generated$3.isCompletionStatement = isCompletionStatement;
  generated$3.isConditional = isConditional;
  generated$3.isConditionalExpression = isConditionalExpression;
  generated$3.isContinueStatement = isContinueStatement;
  generated$3.isDebuggerStatement = isDebuggerStatement;
  generated$3.isDecimalLiteral = isDecimalLiteral;
  generated$3.isDeclaration = isDeclaration;
  generated$3.isDeclareClass = isDeclareClass;
  generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
  generated$3.isDeclareFunction = isDeclareFunction;
  generated$3.isDeclareInterface = isDeclareInterface;
  generated$3.isDeclareModule = isDeclareModule;
  generated$3.isDeclareModuleExports = isDeclareModuleExports;
  generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
  generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
  generated$3.isDeclareVariable = isDeclareVariable;
  generated$3.isDeclaredPredicate = isDeclaredPredicate;
  generated$3.isDecorator = isDecorator;
  generated$3.isDirective = isDirective;
  generated$3.isDirectiveLiteral = isDirectiveLiteral;
  generated$3.isDoExpression = isDoExpression;
  generated$3.isDoWhileStatement = isDoWhileStatement;
  generated$3.isEmptyStatement = isEmptyStatement;
  generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  generated$3.isEnumBody = isEnumBody;
  generated$3.isEnumBooleanBody = isEnumBooleanBody;
  generated$3.isEnumBooleanMember = isEnumBooleanMember;
  generated$3.isEnumDeclaration = isEnumDeclaration;
  generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
  generated$3.isEnumMember = isEnumMember;
  generated$3.isEnumNumberBody = isEnumNumberBody;
  generated$3.isEnumNumberMember = isEnumNumberMember;
  generated$3.isEnumStringBody = isEnumStringBody;
  generated$3.isEnumStringMember = isEnumStringMember;
  generated$3.isEnumSymbolBody = isEnumSymbolBody;
  generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
  generated$3.isExportAllDeclaration = isExportAllDeclaration;
  generated$3.isExportDeclaration = isExportDeclaration;
  generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
  generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
  generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
  generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  generated$3.isExportSpecifier = isExportSpecifier;
  generated$3.isExpression = isExpression;
  generated$3.isExpressionStatement = isExpressionStatement;
  generated$3.isExpressionWrapper = isExpressionWrapper;
  generated$3.isFile = isFile;
  generated$3.isFlow = isFlow;
  generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
  generated$3.isFlowDeclaration = isFlowDeclaration;
  generated$3.isFlowPredicate = isFlowPredicate;
  generated$3.isFlowType = isFlowType;
  generated$3.isFor = isFor;
  generated$3.isForInStatement = isForInStatement;
  generated$3.isForOfStatement = isForOfStatement;
  generated$3.isForStatement = isForStatement;
  generated$3.isForXStatement = isForXStatement;
  generated$3.isFunction = isFunction;
  generated$3.isFunctionDeclaration = isFunctionDeclaration;
  generated$3.isFunctionExpression = isFunctionExpression;
  generated$3.isFunctionParameter = isFunctionParameter;
  generated$3.isFunctionParent = isFunctionParent;
  generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  generated$3.isFunctionTypeParam = isFunctionTypeParam;
  generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
  generated$3.isIdentifier = isIdentifier;
  generated$3.isIfStatement = isIfStatement;
  generated$3.isImmutable = isImmutable2;
  generated$3.isImport = isImport;
  generated$3.isImportAttribute = isImportAttribute;
  generated$3.isImportDeclaration = isImportDeclaration;
  generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
  generated$3.isImportExpression = isImportExpression;
  generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
  generated$3.isImportSpecifier = isImportSpecifier;
  generated$3.isIndexedAccessType = isIndexedAccessType;
  generated$3.isInferredPredicate = isInferredPredicate;
  generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
  generated$3.isInterfaceExtends = isInterfaceExtends;
  generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  generated$3.isInterpreterDirective = isInterpreterDirective;
  generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  generated$3.isJSX = isJSX;
  generated$3.isJSXAttribute = isJSXAttribute;
  generated$3.isJSXClosingElement = isJSXClosingElement;
  generated$3.isJSXClosingFragment = isJSXClosingFragment;
  generated$3.isJSXElement = isJSXElement;
  generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
  generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
  generated$3.isJSXFragment = isJSXFragment;
  generated$3.isJSXIdentifier = isJSXIdentifier;
  generated$3.isJSXMemberExpression = isJSXMemberExpression;
  generated$3.isJSXNamespacedName = isJSXNamespacedName;
  generated$3.isJSXOpeningElement = isJSXOpeningElement;
  generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
  generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
  generated$3.isJSXSpreadChild = isJSXSpreadChild;
  generated$3.isJSXText = isJSXText;
  generated$3.isLVal = isLVal;
  generated$3.isLabeledStatement = isLabeledStatement;
  generated$3.isLiteral = isLiteral;
  generated$3.isLogicalExpression = isLogicalExpression;
  generated$3.isLoop = isLoop;
  generated$3.isMemberExpression = isMemberExpression;
  generated$3.isMetaProperty = isMetaProperty;
  generated$3.isMethod = isMethod;
  generated$3.isMiscellaneous = isMiscellaneous;
  generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
  generated$3.isModuleDeclaration = isModuleDeclaration;
  generated$3.isModuleExpression = isModuleExpression;
  generated$3.isModuleSpecifier = isModuleSpecifier;
  generated$3.isNewExpression = isNewExpression;
  generated$3.isNoop = isNoop;
  generated$3.isNullLiteral = isNullLiteral;
  generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
  generated$3.isNumberLiteral = isNumberLiteral;
  generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
  generated$3.isNumericLiteral = isNumericLiteral;
  generated$3.isObjectExpression = isObjectExpression;
  generated$3.isObjectMember = isObjectMember;
  generated$3.isObjectMethod = isObjectMethod;
  generated$3.isObjectPattern = isObjectPattern;
  generated$3.isObjectProperty = isObjectProperty;
  generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
  generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
  generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
  generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  generated$3.isObjectTypeProperty = isObjectTypeProperty;
  generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  generated$3.isOpaqueType = isOpaqueType;
  generated$3.isOptionalCallExpression = isOptionalCallExpression;
  generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
  generated$3.isParenthesizedExpression = isParenthesizedExpression;
  generated$3.isPattern = isPattern;
  generated$3.isPatternLike = isPatternLike;
  generated$3.isPipelineBareFunction = isPipelineBareFunction;
  generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
  generated$3.isPlaceholder = isPlaceholder;
  generated$3.isPrivate = isPrivate;
  generated$3.isPrivateName = isPrivateName;
  generated$3.isProgram = isProgram;
  generated$3.isProperty = isProperty;
  generated$3.isPureish = isPureish;
  generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  generated$3.isRecordExpression = isRecordExpression;
  generated$3.isRegExpLiteral = isRegExpLiteral;
  generated$3.isRegexLiteral = isRegexLiteral;
  generated$3.isRestElement = isRestElement;
  generated$3.isRestProperty = isRestProperty;
  generated$3.isReturnStatement = isReturnStatement;
  generated$3.isScopable = isScopable;
  generated$3.isSequenceExpression = isSequenceExpression;
  generated$3.isSpreadElement = isSpreadElement;
  generated$3.isSpreadProperty = isSpreadProperty;
  generated$3.isStandardized = isStandardized;
  generated$3.isStatement = isStatement;
  generated$3.isStaticBlock = isStaticBlock;
  generated$3.isStringLiteral = isStringLiteral;
  generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
  generated$3.isSuper = isSuper;
  generated$3.isSwitchCase = isSwitchCase;
  generated$3.isSwitchStatement = isSwitchStatement;
  generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  generated$3.isTSAnyKeyword = isTSAnyKeyword;
  generated$3.isTSArrayType = isTSArrayType;
  generated$3.isTSAsExpression = isTSAsExpression;
  generated$3.isTSBaseType = isTSBaseType;
  generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
  generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
  generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  generated$3.isTSConditionalType = isTSConditionalType;
  generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  generated$3.isTSConstructorType = isTSConstructorType;
  generated$3.isTSDeclareFunction = isTSDeclareFunction;
  generated$3.isTSDeclareMethod = isTSDeclareMethod;
  generated$3.isTSEntityName = isTSEntityName;
  generated$3.isTSEnumBody = isTSEnumBody;
  generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
  generated$3.isTSEnumMember = isTSEnumMember;
  generated$3.isTSExportAssignment = isTSExportAssignment;
  generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
  generated$3.isTSFunctionType = isTSFunctionType;
  generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  generated$3.isTSImportType = isTSImportType;
  generated$3.isTSIndexSignature = isTSIndexSignature;
  generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
  generated$3.isTSInferType = isTSInferType;
  generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
  generated$3.isTSInterfaceBody = isTSInterfaceBody;
  generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  generated$3.isTSIntersectionType = isTSIntersectionType;
  generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  generated$3.isTSLiteralType = isTSLiteralType;
  generated$3.isTSMappedType = isTSMappedType;
  generated$3.isTSMethodSignature = isTSMethodSignature;
  generated$3.isTSModuleBlock = isTSModuleBlock;
  generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
  generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
  generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  generated$3.isTSNeverKeyword = isTSNeverKeyword;
  generated$3.isTSNonNullExpression = isTSNonNullExpression;
  generated$3.isTSNullKeyword = isTSNullKeyword;
  generated$3.isTSNumberKeyword = isTSNumberKeyword;
  generated$3.isTSObjectKeyword = isTSObjectKeyword;
  generated$3.isTSOptionalType = isTSOptionalType;
  generated$3.isTSParameterProperty = isTSParameterProperty;
  generated$3.isTSParenthesizedType = isTSParenthesizedType;
  generated$3.isTSPropertySignature = isTSPropertySignature;
  generated$3.isTSQualifiedName = isTSQualifiedName;
  generated$3.isTSRestType = isTSRestType;
  generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
  generated$3.isTSStringKeyword = isTSStringKeyword;
  generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
  generated$3.isTSTemplateLiteralType = isTSTemplateLiteralType;
  generated$3.isTSThisType = isTSThisType;
  generated$3.isTSTupleType = isTSTupleType;
  generated$3.isTSType = isTSType;
  generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
  generated$3.isTSTypeAssertion = isTSTypeAssertion;
  generated$3.isTSTypeElement = isTSTypeElement;
  generated$3.isTSTypeLiteral = isTSTypeLiteral;
  generated$3.isTSTypeOperator = isTSTypeOperator;
  generated$3.isTSTypeParameter = isTSTypeParameter;
  generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  generated$3.isTSTypePredicate = isTSTypePredicate;
  generated$3.isTSTypeQuery = isTSTypeQuery;
  generated$3.isTSTypeReference = isTSTypeReference;
  generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
  generated$3.isTSUnionType = isTSUnionType;
  generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
  generated$3.isTSVoidKeyword = isTSVoidKeyword;
  generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
  generated$3.isTemplateElement = isTemplateElement;
  generated$3.isTemplateLiteral = isTemplateLiteral;
  generated$3.isTerminatorless = isTerminatorless;
  generated$3.isThisExpression = isThisExpression;
  generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
  generated$3.isThrowStatement = isThrowStatement;
  generated$3.isTopicReference = isTopicReference;
  generated$3.isTryStatement = isTryStatement;
  generated$3.isTupleExpression = isTupleExpression;
  generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
  generated$3.isTypeAlias = isTypeAlias;
  generated$3.isTypeAnnotation = isTypeAnnotation;
  generated$3.isTypeCastExpression = isTypeCastExpression;
  generated$3.isTypeParameter = isTypeParameter;
  generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
  generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
  generated$3.isTypeScript = isTypeScript;
  generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  generated$3.isUnaryExpression = isUnaryExpression;
  generated$3.isUnaryLike = isUnaryLike;
  generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
  generated$3.isUpdateExpression = isUpdateExpression;
  generated$3.isUserWhitespacable = isUserWhitespacable;
  generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  generated$3.isVariableDeclaration = isVariableDeclaration;
  generated$3.isVariableDeclarator = isVariableDeclarator;
  generated$3.isVariance = isVariance;
  generated$3.isVoidPattern = isVoidPattern;
  generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
  generated$3.isWhile = isWhile;
  generated$3.isWhileStatement = isWhileStatement;
  generated$3.isWithStatement = isWithStatement;
  generated$3.isYieldExpression = isYieldExpression;
  var _shallowEqual = requireShallowEqual();
  var _deprecationWarning = requireDeprecationWarning();
  function isArrayExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAssignmentExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AssignmentExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBinaryExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BinaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterpreterDirective(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterpreterDirective") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDirective(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Directive") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDirectiveLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DirectiveLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlockStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BlockStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBreakStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BreakStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCallExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "CallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCatchClause(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "CatchClause") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isConditionalExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ConditionalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isContinueStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ContinueStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDebuggerStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DebuggerStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDoWhileStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DoWhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEmptyStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EmptyStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpressionStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExpressionStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFile(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "File") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForInStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForInStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Identifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIfStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLabeledStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "LabeledStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumericLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumericLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRegExpLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RegExpLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLogicalExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "LogicalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNewExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NewExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isProgram(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Program") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRestElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RestElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isReturnStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ReturnStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSequenceExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SequenceExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isParenthesizedExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ParenthesizedExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSwitchCase(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SwitchCase") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSwitchStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SwitchStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThisExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThisExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThrowStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThrowStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTryStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TryStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnaryExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UnaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUpdateExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UpdateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariableDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VariableDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariableDeclarator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VariableDeclarator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWhileStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "WhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWithStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "WithStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAssignmentPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AssignmentPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrayPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrowFunctionExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrowFunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportAllDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDefaultDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportDefaultDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportNamedDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportNamedDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForOfStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForOfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportDefaultSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportNamespaceSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMetaProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MetaProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSpreadElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SpreadElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSuper(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Super") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTaggedTemplateExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TaggedTemplateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTemplateElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TemplateElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTemplateLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TemplateLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isYieldExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "YieldExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAwaitExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AwaitExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImport(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Import") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBigIntLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BigIntLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportNamespaceSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalCallExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalCallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassAccessorProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassAccessorProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassPrivateProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassPrivateProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassPrivateMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassPrivateMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPrivateName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PrivateName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStaticBlock(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StaticBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAnyTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AnyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrayTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassImplements(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassImplements") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareClass(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareClass") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareInterface(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareInterface") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareModule(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareModule") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareModuleExports(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareModuleExports") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareTypeAlias(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareTypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareOpaqueType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareOpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareVariable(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareVariable") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareExportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareExportAllDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclaredPredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclaredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExistsTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExistsTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionTypeParam(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionTypeParam") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isGenericTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "GenericTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInferredPredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InferredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceExtends(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceExtends") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIntersectionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IntersectionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMixedTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MixedTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEmptyTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EmptyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullableTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullableTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumberLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumberTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeInternalSlot(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeInternalSlot") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeCallProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeCallProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeIndexer(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeIndexer") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeSpreadProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeSpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOpaqueType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isQualifiedTypeIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "QualifiedTypeIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSymbolTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SymbolTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThisTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThisTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTupleTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TupleTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeofTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeofTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeAlias(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeCastExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeCastExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameter(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameterDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameterInstantiation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UnionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariance(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Variance") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVoidTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VoidTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBooleanBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumBooleanBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumNumberBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumNumberBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumStringBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumStringBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumSymbolBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumSymbolBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBooleanMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumBooleanMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumNumberMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumNumberMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumStringMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumStringMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumDefaultedMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumDefaultedMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXClosingElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXClosingElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXEmptyExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXEmptyExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXExpressionContainer(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXExpressionContainer") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXSpreadChild(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXSpreadChild") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXNamespacedName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXNamespacedName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXOpeningElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXOpeningElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXSpreadAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXSpreadAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXText(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXText") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXOpeningFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXOpeningFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXClosingFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXClosingFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNoop(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Noop") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPlaceholder(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Placeholder") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isV8IntrinsicIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "V8IntrinsicIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArgumentPlaceholder(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArgumentPlaceholder") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBindExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BindExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDecorator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Decorator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDoExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DoExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDefaultSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRecordExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RecordExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTupleExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TupleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDecimalLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DecimalLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ModuleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTopicReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelineTopicExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelineTopicExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelineBareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelineBareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelinePrimaryTopicReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelinePrimaryTopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVoidPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VoidPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSParameterProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSParameterProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSDeclareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSDeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSDeclareMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSDeclareMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSQualifiedName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSQualifiedName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSCallSignatureDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSCallSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConstructSignatureDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConstructSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSPropertySignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSPropertySignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSMethodSignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSMethodSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIndexSignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIndexSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSAnyKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSAnyKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBooleanKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSBooleanKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBigIntKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSBigIntKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIntrinsicKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIntrinsicKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNeverKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNeverKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNullKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNullKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNumberKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNumberKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSObjectKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSObjectKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSStringKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSStringKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSSymbolKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSSymbolKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUndefinedKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUndefinedKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUnknownKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUnknownKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSVoidKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSVoidKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSThisType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSThisType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSFunctionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSFunctionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConstructorType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConstructorType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypePredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypePredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeQuery(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeQuery") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSArrayType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSArrayType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTupleType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTupleType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSOptionalType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSOptionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSRestType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSRestType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNamedTupleMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNamedTupleMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUnionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUnionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIntersectionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIntersectionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConditionalType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConditionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInferType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInferType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSParenthesizedType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSParenthesizedType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeOperator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeOperator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSMappedType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSMappedType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTemplateLiteralType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTemplateLiteralType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSLiteralType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSLiteralType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExpressionWithTypeArguments(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExpressionWithTypeArguments") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInterfaceDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInterfaceBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInterfaceBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAliasDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAliasDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInstantiationExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInstantiationExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSAsExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSAsExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSSatisfiesExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSSatisfiesExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAssertion(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAssertion") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSModuleDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSModuleDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSModuleBlock(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSModuleBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSImportType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSImportType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSImportEqualsDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSImportEqualsDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExternalModuleReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExternalModuleReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNonNullExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNonNullExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExportAssignment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExportAssignment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNamespaceExportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNamespaceExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameterInstantiation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameterDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameter(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStandardized(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpression(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBinary(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isScopable(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlockParent(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlock(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTerminatorless(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCompletionStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isConditional(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLoop(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWhile(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpressionWrapper(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFor(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForXStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunction(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionParent(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPureish(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Declaration") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionParameter(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPatternLike(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLVal(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEntityName(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLiteral(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImmutable2(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUserWhitespacable(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMethod(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectMember(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isProperty(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnaryLike(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPattern(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Pattern") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClass(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportOrExportDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleSpecifier(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAccessor(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPrivate(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlow(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowBaseAnnotation(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowPredicate(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBody(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumMember(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSX(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMiscellaneous(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeScript(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeElement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBaseType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberLiteral(node2, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node2) return false;
    if (node2.type !== "NumberLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRegexLiteral(node2, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node2) return false;
    if (node2.type !== "RegexLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRestProperty(node2, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node2) return false;
    if (node2.type !== "RestProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSpreadProperty(node2, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node2) return false;
    if (node2.type !== "SpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleDeclaration(node2, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node2, opts);
  }
  return generated$3;
}
var hasRequiredMatchesPattern;
function requireMatchesPattern() {
  if (hasRequiredMatchesPattern) return matchesPattern;
  hasRequiredMatchesPattern = 1;
  Object.defineProperty(matchesPattern, "__esModule", {
    value: true
  });
  matchesPattern.default = matchesPattern$1;
  var _index = requireGenerated$3();
  function isMemberExpressionLike(node2) {
    return (0, _index.isMemberExpression)(node2) || (0, _index.isMetaProperty)(node2);
  }
  function matchesPattern$1(member, match, allowPartial) {
    if (!isMemberExpressionLike(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node2;
    for (node2 = member; isMemberExpressionLike(node2); node2 = (_object = node2.object) != null ? _object : node2.meta) {
      var _object;
      nodes.push(node2.property);
    }
    nodes.push(node2);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for (let i = 0, j2 = nodes.length - 1; i < parts.length; i++, j2--) {
      const node3 = nodes[j2];
      let value;
      if ((0, _index.isIdentifier)(node3)) {
        value = node3.name;
      } else if ((0, _index.isStringLiteral)(node3)) {
        value = node3.value;
      } else if ((0, _index.isThisExpression)(node3)) {
        value = "this";
      } else if ((0, _index.isSuper)(node3)) {
        value = "super";
      } else if ((0, _index.isPrivateName)(node3)) {
        value = "#" + node3.id.name;
      } else {
        return false;
      }
      if (parts[i] !== value) return false;
    }
    return true;
  }
  return matchesPattern;
}
var hasRequiredBuildMatchMemberExpression;
function requireBuildMatchMemberExpression() {
  if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
  hasRequiredBuildMatchMemberExpression = 1;
  Object.defineProperty(buildMatchMemberExpression, "__esModule", {
    value: true
  });
  buildMatchMemberExpression.default = buildMatchMemberExpression$1;
  var _matchesPattern = requireMatchesPattern();
  function buildMatchMemberExpression$1(match, allowPartial) {
    const parts = match.split(".");
    return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
  }
  return buildMatchMemberExpression;
}
var hasRequiredIsReactComponent;
function requireIsReactComponent() {
  if (hasRequiredIsReactComponent) return isReactComponent;
  hasRequiredIsReactComponent = 1;
  Object.defineProperty(isReactComponent, "__esModule", {
    value: true
  });
  isReactComponent.default = void 0;
  var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
  const isReactComponent$1 = (0, _buildMatchMemberExpression.default)("React.Component");
  isReactComponent.default = isReactComponent$1;
  return isReactComponent;
}
var isCompatTag = {};
var hasRequiredIsCompatTag;
function requireIsCompatTag() {
  if (hasRequiredIsCompatTag) return isCompatTag;
  hasRequiredIsCompatTag = 1;
  Object.defineProperty(isCompatTag, "__esModule", {
    value: true
  });
  isCompatTag.default = isCompatTag$1;
  function isCompatTag$1(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }
  return isCompatTag;
}
var buildChildren = {};
var cleanJSXElementLiteralChild = {};
var generated$2 = {};
var lowercase = {};
var validate = {};
var definitions = {};
var core = {};
var is$1 = {};
var isType = {};
var hasRequiredIsType;
function requireIsType() {
  if (hasRequiredIsType) return isType;
  hasRequiredIsType = 1;
  Object.defineProperty(isType, "__esModule", {
    value: true
  });
  isType.default = isType$1;
  var _index = requireDefinitions();
  function isType$1(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (nodeType == null) return false;
    if (_index.ALIAS_KEYS[targetType]) return false;
    const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases != null && aliases.includes(nodeType)) return true;
    return false;
  }
  return isType;
}
var isPlaceholderType = {};
var hasRequiredIsPlaceholderType;
function requireIsPlaceholderType() {
  if (hasRequiredIsPlaceholderType) return isPlaceholderType;
  hasRequiredIsPlaceholderType = 1;
  Object.defineProperty(isPlaceholderType, "__esModule", {
    value: true
  });
  isPlaceholderType.default = isPlaceholderType$1;
  var _index = requireDefinitions();
  function isPlaceholderType$1(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases != null && aliases.includes(targetType)) return true;
    return false;
  }
  return isPlaceholderType;
}
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is$1;
  hasRequiredIs = 1;
  Object.defineProperty(is$1, "__esModule", {
    value: true
  });
  is$1.default = is2;
  var _shallowEqual = requireShallowEqual();
  var _isType = requireIsType();
  var _isPlaceholderType = requireIsPlaceholderType();
  var _index = requireDefinitions();
  function is2(type, node2, opts) {
    if (!node2) return false;
    const matches = (0, _isType.default)(node2.type, type);
    if (!matches) {
      if (!opts && node2.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node2.expectedNode, type);
      }
      return false;
    }
    if (opts === void 0) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node2, opts);
    }
  }
  return is$1;
}
var isValidIdentifier = {};
var lib$5 = {};
var identifier = {};
var hasRequiredIdentifier;
function requireIdentifier() {
  if (hasRequiredIdentifier) return identifier;
  hasRequiredIdentifier = 1;
  Object.defineProperty(identifier, "__esModule", {
    value: true
  });
  identifier.isIdentifierChar = isIdentifierChar;
  identifier.isIdentifierName = isIdentifierName;
  identifier.isIdentifierStart = isIdentifierStart;
  let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-࢏ࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚ౜ౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ೜-ೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-Ƛ꟱-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
  let nonASCIIidentifierChars = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-᫝᫠-᫫ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let i = 0; i < name.length; i++) {
      let cp2 = name.charCodeAt(i);
      if ((cp2 & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp2)) {
          return false;
        }
      } else if (!isIdentifierChar(cp2)) {
        return false;
      }
    }
    return !isFirst;
  }
  return identifier;
}
var keyword = {};
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", {
    value: true
  });
  keyword.isKeyword = isKeyword;
  keyword.isReservedWord = isReservedWord;
  keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  keyword.isStrictBindReservedWord = isStrictBindReservedWord;
  keyword.isStrictReservedWord = isStrictReservedWord;
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  return keyword;
}
var hasRequiredLib$7;
function requireLib$7() {
  if (hasRequiredLib$7) return lib$5;
  hasRequiredLib$7 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports$1, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports$1, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports$1, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports$1, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = requireIdentifier();
    var _keyword = requireKeyword();
  })(lib$5);
  return lib$5;
}
var hasRequiredIsValidIdentifier;
function requireIsValidIdentifier() {
  if (hasRequiredIsValidIdentifier) return isValidIdentifier;
  hasRequiredIsValidIdentifier = 1;
  Object.defineProperty(isValidIdentifier, "__esModule", {
    value: true
  });
  isValidIdentifier.default = isValidIdentifier$1;
  var _helperValidatorIdentifier = requireLib$7();
  function isValidIdentifier$1(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  }
  return isValidIdentifier;
}
var lib$4 = {};
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$4;
  hasRequiredLib$6 = 1;
  Object.defineProperty(lib$4, "__esModule", {
    value: true
  });
  lib$4.readCodePoint = readCodePoint;
  lib$4.readInt = readInt;
  lib$4.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  };
  const isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (; ; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({
          code,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("	");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code,
      pos
    };
  }
  return lib$4;
}
var constants = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", {
    value: true
  });
  constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
  constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  constants.FLATTENABLE_KEYS = ["body", "expressions"];
  constants.FOR_INIT_KEYS = ["left", "init"];
  constants.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  const LOGICAL_OPERATORS = constants.LOGICAL_OPERATORS = ["||", "&&", "??"];
  constants.UPDATE_OPERATORS = ["++", "--"];
  const BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  const EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  const COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  const BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  const NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  constants.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
  constants.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op2) => op2 + "="), ...LOGICAL_OPERATORS.map((op2) => op2 + "=")];
  const BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  const NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  const STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
  constants.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  constants.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  {
    constants.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    constants.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
  return constants;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.allExpandedTypes = utils.VISITOR_KEYS = utils.NODE_UNION_SHAPES__PRIVATE = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0;
  utils.arrayOf = arrayOf;
  utils.arrayOfType = arrayOfType;
  utils.assertEach = assertEach;
  utils.assertNodeOrValueType = assertNodeOrValueType;
  utils.assertNodeType = assertNodeType;
  utils.assertOneOf = assertOneOf;
  utils.assertOptionalChainStart = assertOptionalChainStart;
  utils.assertShape = assertShape;
  utils.assertValueType = assertValueType;
  utils.chain = chain;
  utils.default = defineType;
  utils.defineAliasedType = defineAliasedType;
  utils.validate = validate2;
  utils.validateArrayOfType = validateArrayOfType;
  utils.validateOptional = validateOptional;
  utils.validateOptionalType = validateOptionalType;
  utils.validateType = validateType;
  var _is = requireIs();
  var _validate = requireValidate();
  const VISITOR_KEYS = utils.VISITOR_KEYS = {};
  const ALIAS_KEYS = utils.ALIAS_KEYS = {};
  const FLIPPED_ALIAS_KEYS = utils.FLIPPED_ALIAS_KEYS = {};
  const NODE_FIELDS = utils.NODE_FIELDS = {};
  const BUILDER_KEYS = utils.BUILDER_KEYS = {};
  const DEPRECATED_KEYS = utils.DEPRECATED_KEYS = {};
  const NODE_PARENT_VALIDATIONS = utils.NODE_PARENT_VALIDATIONS = {};
  const NODE_UNION_SHAPES__PRIVATE = utils.NODE_UNION_SHAPES__PRIVATE = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate2(validate3) {
    return {
      validate: validate3
    };
  }
  function validateType(...typeNames) {
    return validate2(assertNodeType(...typeNames));
  }
  function validateOptional(validate3) {
    return {
      validate: validate3,
      optional: true
    };
  }
  function validateOptionalType(...typeNames) {
    return {
      validate: assertNodeType(...typeNames),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(...typeNames) {
    return arrayOf(assertNodeType(...typeNames));
  }
  function validateArrayOfType(...typeNames) {
    return validate2(arrayOfType(...typeNames));
  }
  function assertEach(callback) {
    const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
    };
    function validator(node2, key, val) {
      if (!Array.isArray(val)) return;
      let i = 0;
      const subKey = {
        toString() {
          return `${key}[${i}]`;
        }
      };
      for (; i < val.length; i++) {
        const v2 = val[i];
        callback(node2, subKey, v2);
        childValidator(node2, subKey, v2);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf(...values) {
    function validate3(node2, key, val) {
      if (!values.includes(val)) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }
    validate3.oneOf = values;
    return validate3;
  }
  const allExpandedTypes = utils.allExpandedTypes = [];
  function assertNodeType(...types2) {
    const expandedTypes = /* @__PURE__ */ new Set();
    allExpandedTypes.push({
      types: types2,
      set: expandedTypes
    });
    function validate3(node2, key, val) {
      const valType = val == null ? void 0 : val.type;
      if (valType != null) {
        if (expandedTypes.has(valType)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
        if (valType === "Placeholder") {
          for (const type of types2) {
            if ((0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node2, key, val);
              return;
            }
          }
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(valType)}`);
    }
    validate3.oneOfNodeTypes = types2;
    return validate3;
  }
  function assertNodeOrValueType(...types2) {
    function validate3(node2, key, val) {
      const primitiveType = getType(val);
      for (const type of types2) {
        if (primitiveType === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate3.oneOfNodeOrValueTypes = types2;
    return validate3;
  }
  function assertValueType(type) {
    function validate3(node2, key, val) {
      if (getType(val) === type) {
        return;
      }
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate3.type = type;
    return validate3;
  }
  function assertShape(shape) {
    const keys = Object.keys(shape);
    function validate3(node2, key, val) {
      const errors = [];
      for (const property of keys) {
        try {
          (0, _validate.validateField)(node2, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(`Property ${key} of ${node2.type} expected to have the following:
${errors.join("\n")}`);
      }
    }
    validate3.shapeOf = shape;
    return validate3;
  }
  function assertOptionalChainStart() {
    function validate3(node2) {
      var _current;
      let current = node2;
      while (node2) {
        const {
          type
        } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${node2.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate3;
  }
  function chain(...fns) {
    function validate3(...args) {
      for (const fn2 of fns) {
        fn2(...args);
      }
    }
    validate3.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    return validate3;
  }
  const validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]);
  const validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]);
  const store = {};
  function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$;
        if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
        defined != null ? defined : defined = [];
        opts.aliases = defined;
      }
      const additional = aliases.filter((a2) => !defined.includes(a2));
      defined.unshift(...additional);
      defineType(type, opts);
    };
  }
  function defineType(type, opts = {}) {
    const inherits2 = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits2.fields) {
        const keys = Object.getOwnPropertyNames(inherits2.fields);
        for (const key of keys) {
          const field = inherits2.fields[key];
          const def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    const visitor = opts.visitor || inherits2.visitor || [];
    const aliases = opts.aliases || inherits2.aliases || [];
    const builder2 = opts.builder || inherits2.builder || opts.visitor || [];
    for (const k2 of Object.keys(opts)) {
      if (!validTypeOpts.has(k2)) {
        throw new Error(`Unknown type option "${k2}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder2)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== void 0 && !builder2.includes(key)) {
        field.optional = true;
      }
      if (field.default === void 0) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k2 of Object.keys(field)) {
        if (!validFieldKeys.has(k2)) {
          throw new Error(`Unknown field key "${k2}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder2;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    if (opts.unionShape) {
      NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;
    }
    store[type] = opts;
  }
  return utils;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", {
    value: true
  });
  core.patternLikeCommon = core.importAttributes = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyUnionShapeCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0;
  var _is = requireIs();
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$7();
  var _helperStringParser = requireLib$6();
  var _index = requireConstants();
  var _utils = requireUtils();
  const classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          key: {
            validate: allowPrivateName ? (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
          }
        }
      }]
    }
  });
  core.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;
  const defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
          const identifier2 = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils.assertOneOf)("=");
          return function(node2, key, val) {
            const validator = (0, _is.default)("Pattern", node2.left) ? pattern : identifier2;
            validator(node2, key, val);
          };
        }(), {
          oneOf: _index.ASSIGNMENT_OPERATORS
        })
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.operator === "in" ? inOp : expression;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  const functionCommon = () => ({
    params: (0, _utils.validateArrayOfType)("FunctionParameter"),
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  core.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  });
  core.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
      const identifier2 = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier2(node2, "id", node2.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  const patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  core.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          if (!(0, _isValidIdentifier.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node2) {
      const match = /\.(\w+)$/.exec(key.toString());
      if (!match) return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp)) return;
        if ((0, _is.default)("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node2
        })) return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, {
          meta: node2
        })) return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node2.name) || (0, _helperValidatorIdentifier.isReservedWord)(node2.name, false)) && node2.name !== "this") {
        throw new TypeError(`"${node2.name}" is not a valid identifier`);
      }
    } : void 0
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node2, key, val) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          const invalid = /[^dgimsuvy]/.exec(val);
          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string"),
        default: ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          property: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          property: {
            validate: (0, _utils.assertNodeType)("Identifier", "PrivateName")
          }
        }
      }]
    },
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        default: false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  defineType("ObjectMethod", Object.assign({
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }));
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
          }
        }
      }]
    },
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, shorthand) {
          if (!shorthand) return;
          if (node2.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
          if (!(0, _is.default)("Identifier", node2.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      const expression = (0, _utils.assertNodeType)("Expression");
      return function(parent, key, node2) {
        const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
        validator(node2, "value", node2.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
      const match = /(\w+)\[(\d+)\]/.exec(key.toString());
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    } : void 0
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, _utils.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: (0, _utils.validateArrayOfType)("SwitchCase")
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node2) {
          if (!node2.handler && !node2.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, _utils.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      const withoutInit = (0, _utils.assertNodeType)("Identifier", "Placeholder");
      const constOrLetOrVar = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder");
      const usingOrAwaitUsing = (0, _utils.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
      return function(parent, key, node2) {
        const {
          kind,
          declarations
        } = node2;
        const parentIsForX = (0, _is.default)("ForXStatement", parent, {
          left: node2
        });
        if (parentIsForX) {
          if (declarations.length !== 1) {
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          }
        }
        for (const decl of declarations) {
          if (kind === "const" || kind === "let" || kind === "var") {
            if (!parentIsForX && !decl.init) {
              withoutInit(decl, "id", decl.id);
            } else {
              constOrLetOrVar(decl, "id", decl.id);
            }
          } else {
            usingOrAwaitUsing(decl, "id", decl.id);
          }
        }
      };
    })() : void 0
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "VoidPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern")
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
      const identifier2 = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier2(node2, "id", node2.id);
        }
      };
    }()
  });
  const importAttributes = core.importAttributes = {
    attributes: {
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: true,
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    }
  };
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, importAttributes)
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: true,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node2, key, val) {
          if (val && node2.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
          if (val && node2.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, _utils.assertNodeType)("Declaration")
      }
    }, importAttributes, {
      specifiers: {
        default: [],
        validate: (0, _utils.arrayOf)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
          return Object.assign(function(node2, key, val) {
            const validator = node2.source ? sourced : sourceless;
            validator(node2, key, val);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          });
        }())
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    })
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(node2, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node2, key, val);
            } else {
              lval(node2, key, val);
            }
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, importAttributes, {
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    })
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node2, key, val) {
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!(0, _is.default)("Identifier", node2.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, _utils.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  const classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils.chain)(function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function(node2, key, val) {
          const validator = node2.computed ? computed : normal;
          validator(node2, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: (0, _utils.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", Object.assign({
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  }));
  defineType("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      ["typeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node2) {
          const raw = node2.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          };
          const {
            str,
            firstInvalidLoc
          } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
            unterminated() {
              unterminatedCalled = true;
            },
            strictNumericEscape: error,
            invalidEscapeSequence: error,
            numericSeparatorInEscapeSequence: error,
            unexpectedNumericSeparator: error,
            invalidDigit: error,
            invalidCodePoint: error
          });
          if (!unterminatedCalled) throw new Error("Invalid raw");
          node2.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        default: false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
          if (val && !node2.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("ClassProperty", Object.assign({
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  }));
  defineType("ClassAccessorProperty", Object.assign({
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"]
  }, classMethodOrPropertyUnionShapeCommon(true), {
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node2, key, val) {
            const validator = node2.computed ? computed : normal;
            validator(node2, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  }));
  defineType("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  defineType("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
  return core;
}
var flow$1 = {};
var hasRequiredFlow$1;
function requireFlow$1() {
  if (hasRequiredFlow$1) return flow$1;
  hasRequiredFlow$1 = 1;
  var _core = requireCore();
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("Flow");
  const defineInterfaceishType = (name) => {
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }, _core.importAttributes)
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, _core.importAttributes)
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)("Identifier", "StringLiteral"),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  return flow$1;
}
var jsx$1 = {};
var hasRequiredJsx$1;
function requireJsx$1() {
  if (hasRequiredJsx$1) return jsx$1;
  hasRequiredJsx$1 = 1;
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
  return jsx$1;
}
var misc = {};
var placeholders = {};
var hasRequiredPlaceholders;
function requirePlaceholders() {
  if (hasRequiredPlaceholders) return placeholders;
  hasRequiredPlaceholders = 1;
  Object.defineProperty(placeholders, "__esModule", {
    value: true
  });
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;
  var _utils = requireUtils();
  const PLACEHOLDERS = placeholders.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  const PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }
  const PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
  return placeholders;
}
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var _utils = requireUtils();
  var _placeholders = requirePlaceholders();
  var _core = requireCore();
  const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }, (0, _core.patternLikeCommon)())
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  return misc;
}
var experimental = {};
var hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental) return experimental;
  hasRequiredExperimental = 1;
  var _utils = requireUtils();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  {
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
  }
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });
  return experimental;
}
var typescript$1 = {};
var hasRequiredTypescript$1;
function requireTypescript$1() {
  if (hasRequiredTypescript$1) return typescript$1;
  hasRequiredTypescript$1 = 1;
  var _utils = requireUtils();
  var _core = requireCore();
  var _is = requireIs();
  const defineType = (0, _utils.defineAliasedType)("TypeScript");
  const bool = (0, _utils.assertValueType)("boolean");
  const tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", Object.assign({
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
  }, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  }));
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  const signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  });
  const callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  const namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, _utils.validateOptional)(bool)
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: true,
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  const unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: (0, _utils.assertValueType)("string"),
        default: "keyof"
      },
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }, {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    })
  });
  defineType("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal2 = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          const validator = function validator2(parent, key, node2) {
            if ((0, _is.default)("UnaryExpression", node2)) {
              unaryOperator(node2, "operator", node2.operator);
              unaryExpression(node2, "argument", node2.argument);
            } else {
              literal2(parent, key, node2);
            }
          };
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        }()
      }
    }
  });
  {
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
  }
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSEnumMember")
    }
  });
  {
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
  }
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, _utils.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, _utils.validateOptional)(bool)
    }, {
      global: (0, _utils.validateOptional)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, _utils.assertNodeType)("ObjectExpression"),
        optional: true
      }
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, _utils.validate)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    })
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSType")
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSTypeParameter")
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      in: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      const: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
  return typescript$1;
}
var deprecatedAliases = {};
var hasRequiredDeprecatedAliases;
function requireDeprecatedAliases() {
  if (hasRequiredDeprecatedAliases) return deprecatedAliases;
  hasRequiredDeprecatedAliases = 1;
  Object.defineProperty(deprecatedAliases, "__esModule", {
    value: true
  });
  deprecatedAliases.DEPRECATED_ALIASES = void 0;
  deprecatedAliases.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
  return deprecatedAliases;
}
var hasRequiredDefinitions;
function requireDefinitions() {
  if (hasRequiredDefinitions) return definitions;
  hasRequiredDefinitions = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports$1, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports$1, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports$1, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports$1, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports$1, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports$1, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports$1, "NODE_UNION_SHAPES__PRIVATE", {
      enumerable: true,
      get: function() {
        return _utils.NODE_UNION_SHAPES__PRIVATE;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports$1.TYPES = void 0;
    Object.defineProperty(exports$1, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    requireCore();
    requireFlow$1();
    requireJsx$1();
    requireMisc();
    requireExperimental();
    requireTypescript$1();
    var _utils = requireUtils();
    var _placeholders = requirePlaceholders();
    var _deprecatedAliases = requireDeprecatedAliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    for (const {
      types: types2,
      set
    } of _utils.allExpandedTypes) {
      for (const type of types2) {
        const aliases = _utils.FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          aliases.forEach(set.add, set);
        } else {
          set.add(type);
        }
      }
    }
    exports$1.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  })(definitions);
  return definitions;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", {
    value: true
  });
  validate.default = validate$1;
  validate.validateChild = validateChild;
  validate.validateField = validateField;
  validate.validateInternal = validateInternal;
  var _index = requireDefinitions();
  function validate$1(node2, key, val) {
    if (!node2) return;
    const fields = _index.NODE_FIELDS[node2.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node2, key, val, field);
    validateChild(node2, key, val);
  }
  function validateInternal(field, node2, key, val, maybeNode) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node2, key, val);
    if (maybeNode) {
      var _NODE_PARENT_VALIDATI;
      const type = val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node2, key, val);
    }
  }
  function validateField(node2, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node2, key, val);
  }
  function validateChild(node2, key, val) {
    var _NODE_PARENT_VALIDATI2;
    const type = val == null ? void 0 : val.type;
    if (type == null) return;
    (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node2, key, val);
  }
  return validate;
}
var hasRequiredLowercase;
function requireLowercase() {
  if (hasRequiredLowercase) return lowercase;
  hasRequiredLowercase = 1;
  Object.defineProperty(lowercase, "__esModule", {
    value: true
  });
  lowercase.anyTypeAnnotation = anyTypeAnnotation;
  lowercase.argumentPlaceholder = argumentPlaceholder;
  lowercase.arrayExpression = arrayExpression;
  lowercase.arrayPattern = arrayPattern;
  lowercase.arrayTypeAnnotation = arrayTypeAnnotation;
  lowercase.arrowFunctionExpression = arrowFunctionExpression;
  lowercase.assignmentExpression = assignmentExpression;
  lowercase.assignmentPattern = assignmentPattern;
  lowercase.awaitExpression = awaitExpression;
  lowercase.bigIntLiteral = bigIntLiteral;
  lowercase.binaryExpression = binaryExpression;
  lowercase.bindExpression = bindExpression;
  lowercase.blockStatement = blockStatement;
  lowercase.booleanLiteral = booleanLiteral;
  lowercase.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  lowercase.booleanTypeAnnotation = booleanTypeAnnotation;
  lowercase.breakStatement = breakStatement;
  lowercase.callExpression = callExpression;
  lowercase.catchClause = catchClause;
  lowercase.classAccessorProperty = classAccessorProperty;
  lowercase.classBody = classBody;
  lowercase.classDeclaration = classDeclaration;
  lowercase.classExpression = classExpression;
  lowercase.classImplements = classImplements;
  lowercase.classMethod = classMethod;
  lowercase.classPrivateMethod = classPrivateMethod;
  lowercase.classPrivateProperty = classPrivateProperty;
  lowercase.classProperty = classProperty;
  lowercase.conditionalExpression = conditionalExpression;
  lowercase.continueStatement = continueStatement;
  lowercase.debuggerStatement = debuggerStatement;
  lowercase.decimalLiteral = decimalLiteral;
  lowercase.declareClass = declareClass;
  lowercase.declareExportAllDeclaration = declareExportAllDeclaration;
  lowercase.declareExportDeclaration = declareExportDeclaration;
  lowercase.declareFunction = declareFunction;
  lowercase.declareInterface = declareInterface;
  lowercase.declareModule = declareModule;
  lowercase.declareModuleExports = declareModuleExports;
  lowercase.declareOpaqueType = declareOpaqueType;
  lowercase.declareTypeAlias = declareTypeAlias;
  lowercase.declareVariable = declareVariable;
  lowercase.declaredPredicate = declaredPredicate;
  lowercase.decorator = decorator;
  lowercase.directive = directive;
  lowercase.directiveLiteral = directiveLiteral;
  lowercase.doExpression = doExpression;
  lowercase.doWhileStatement = doWhileStatement;
  lowercase.emptyStatement = emptyStatement;
  lowercase.emptyTypeAnnotation = emptyTypeAnnotation;
  lowercase.enumBooleanBody = enumBooleanBody;
  lowercase.enumBooleanMember = enumBooleanMember;
  lowercase.enumDeclaration = enumDeclaration;
  lowercase.enumDefaultedMember = enumDefaultedMember;
  lowercase.enumNumberBody = enumNumberBody;
  lowercase.enumNumberMember = enumNumberMember;
  lowercase.enumStringBody = enumStringBody;
  lowercase.enumStringMember = enumStringMember;
  lowercase.enumSymbolBody = enumSymbolBody;
  lowercase.existsTypeAnnotation = existsTypeAnnotation;
  lowercase.exportAllDeclaration = exportAllDeclaration;
  lowercase.exportDefaultDeclaration = exportDefaultDeclaration;
  lowercase.exportDefaultSpecifier = exportDefaultSpecifier;
  lowercase.exportNamedDeclaration = exportNamedDeclaration;
  lowercase.exportNamespaceSpecifier = exportNamespaceSpecifier;
  lowercase.exportSpecifier = exportSpecifier;
  lowercase.expressionStatement = expressionStatement;
  lowercase.file = file;
  lowercase.forInStatement = forInStatement;
  lowercase.forOfStatement = forOfStatement;
  lowercase.forStatement = forStatement;
  lowercase.functionDeclaration = functionDeclaration;
  lowercase.functionExpression = functionExpression;
  lowercase.functionTypeAnnotation = functionTypeAnnotation;
  lowercase.functionTypeParam = functionTypeParam;
  lowercase.genericTypeAnnotation = genericTypeAnnotation;
  lowercase.identifier = identifier2;
  lowercase.ifStatement = ifStatement;
  lowercase.import = _import;
  lowercase.importAttribute = importAttribute;
  lowercase.importDeclaration = importDeclaration;
  lowercase.importDefaultSpecifier = importDefaultSpecifier;
  lowercase.importExpression = importExpression;
  lowercase.importNamespaceSpecifier = importNamespaceSpecifier;
  lowercase.importSpecifier = importSpecifier;
  lowercase.indexedAccessType = indexedAccessType;
  lowercase.inferredPredicate = inferredPredicate;
  lowercase.interfaceDeclaration = interfaceDeclaration;
  lowercase.interfaceExtends = interfaceExtends;
  lowercase.interfaceTypeAnnotation = interfaceTypeAnnotation;
  lowercase.interpreterDirective = interpreterDirective;
  lowercase.intersectionTypeAnnotation = intersectionTypeAnnotation;
  lowercase.jSXAttribute = lowercase.jsxAttribute = jsxAttribute;
  lowercase.jSXClosingElement = lowercase.jsxClosingElement = jsxClosingElement;
  lowercase.jSXClosingFragment = lowercase.jsxClosingFragment = jsxClosingFragment;
  lowercase.jSXElement = lowercase.jsxElement = jsxElement;
  lowercase.jSXEmptyExpression = lowercase.jsxEmptyExpression = jsxEmptyExpression;
  lowercase.jSXExpressionContainer = lowercase.jsxExpressionContainer = jsxExpressionContainer;
  lowercase.jSXFragment = lowercase.jsxFragment = jsxFragment;
  lowercase.jSXIdentifier = lowercase.jsxIdentifier = jsxIdentifier;
  lowercase.jSXMemberExpression = lowercase.jsxMemberExpression = jsxMemberExpression;
  lowercase.jSXNamespacedName = lowercase.jsxNamespacedName = jsxNamespacedName;
  lowercase.jSXOpeningElement = lowercase.jsxOpeningElement = jsxOpeningElement;
  lowercase.jSXOpeningFragment = lowercase.jsxOpeningFragment = jsxOpeningFragment;
  lowercase.jSXSpreadAttribute = lowercase.jsxSpreadAttribute = jsxSpreadAttribute;
  lowercase.jSXSpreadChild = lowercase.jsxSpreadChild = jsxSpreadChild;
  lowercase.jSXText = lowercase.jsxText = jsxText;
  lowercase.labeledStatement = labeledStatement;
  lowercase.logicalExpression = logicalExpression;
  lowercase.memberExpression = memberExpression;
  lowercase.metaProperty = metaProperty;
  lowercase.mixedTypeAnnotation = mixedTypeAnnotation;
  lowercase.moduleExpression = moduleExpression;
  lowercase.newExpression = newExpression;
  lowercase.noop = noop;
  lowercase.nullLiteral = nullLiteral;
  lowercase.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  lowercase.nullableTypeAnnotation = nullableTypeAnnotation;
  lowercase.numberLiteral = NumberLiteral;
  lowercase.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  lowercase.numberTypeAnnotation = numberTypeAnnotation;
  lowercase.numericLiteral = numericLiteral;
  lowercase.objectExpression = objectExpression;
  lowercase.objectMethod = objectMethod;
  lowercase.objectPattern = objectPattern;
  lowercase.objectProperty = objectProperty;
  lowercase.objectTypeAnnotation = objectTypeAnnotation;
  lowercase.objectTypeCallProperty = objectTypeCallProperty;
  lowercase.objectTypeIndexer = objectTypeIndexer;
  lowercase.objectTypeInternalSlot = objectTypeInternalSlot;
  lowercase.objectTypeProperty = objectTypeProperty;
  lowercase.objectTypeSpreadProperty = objectTypeSpreadProperty;
  lowercase.opaqueType = opaqueType;
  lowercase.optionalCallExpression = optionalCallExpression;
  lowercase.optionalIndexedAccessType = optionalIndexedAccessType;
  lowercase.optionalMemberExpression = optionalMemberExpression;
  lowercase.parenthesizedExpression = parenthesizedExpression;
  lowercase.pipelineBareFunction = pipelineBareFunction;
  lowercase.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  lowercase.pipelineTopicExpression = pipelineTopicExpression;
  lowercase.placeholder = placeholder;
  lowercase.privateName = privateName;
  lowercase.program = program;
  lowercase.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  lowercase.recordExpression = recordExpression;
  lowercase.regExpLiteral = regExpLiteral;
  lowercase.regexLiteral = RegexLiteral;
  lowercase.restElement = restElement;
  lowercase.restProperty = RestProperty;
  lowercase.returnStatement = returnStatement;
  lowercase.sequenceExpression = sequenceExpression;
  lowercase.spreadElement = spreadElement;
  lowercase.spreadProperty = SpreadProperty;
  lowercase.staticBlock = staticBlock;
  lowercase.stringLiteral = stringLiteral;
  lowercase.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  lowercase.stringTypeAnnotation = stringTypeAnnotation;
  lowercase.super = _super;
  lowercase.switchCase = switchCase;
  lowercase.switchStatement = switchStatement;
  lowercase.symbolTypeAnnotation = symbolTypeAnnotation;
  lowercase.taggedTemplateExpression = taggedTemplateExpression;
  lowercase.templateElement = templateElement;
  lowercase.templateLiteral = templateLiteral;
  lowercase.thisExpression = thisExpression;
  lowercase.thisTypeAnnotation = thisTypeAnnotation;
  lowercase.throwStatement = throwStatement;
  lowercase.topicReference = topicReference;
  lowercase.tryStatement = tryStatement;
  lowercase.tSAnyKeyword = lowercase.tsAnyKeyword = tsAnyKeyword;
  lowercase.tSArrayType = lowercase.tsArrayType = tsArrayType;
  lowercase.tSAsExpression = lowercase.tsAsExpression = tsAsExpression;
  lowercase.tSBigIntKeyword = lowercase.tsBigIntKeyword = tsBigIntKeyword;
  lowercase.tSBooleanKeyword = lowercase.tsBooleanKeyword = tsBooleanKeyword;
  lowercase.tSCallSignatureDeclaration = lowercase.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  lowercase.tSConditionalType = lowercase.tsConditionalType = tsConditionalType;
  lowercase.tSConstructSignatureDeclaration = lowercase.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  lowercase.tSConstructorType = lowercase.tsConstructorType = tsConstructorType;
  lowercase.tSDeclareFunction = lowercase.tsDeclareFunction = tsDeclareFunction;
  lowercase.tSDeclareMethod = lowercase.tsDeclareMethod = tsDeclareMethod;
  lowercase.tSEnumBody = lowercase.tsEnumBody = tsEnumBody;
  lowercase.tSEnumDeclaration = lowercase.tsEnumDeclaration = tsEnumDeclaration;
  lowercase.tSEnumMember = lowercase.tsEnumMember = tsEnumMember;
  lowercase.tSExportAssignment = lowercase.tsExportAssignment = tsExportAssignment;
  lowercase.tSExpressionWithTypeArguments = lowercase.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  lowercase.tSExternalModuleReference = lowercase.tsExternalModuleReference = tsExternalModuleReference;
  lowercase.tSFunctionType = lowercase.tsFunctionType = tsFunctionType;
  lowercase.tSImportEqualsDeclaration = lowercase.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  lowercase.tSImportType = lowercase.tsImportType = tsImportType;
  lowercase.tSIndexSignature = lowercase.tsIndexSignature = tsIndexSignature;
  lowercase.tSIndexedAccessType = lowercase.tsIndexedAccessType = tsIndexedAccessType;
  lowercase.tSInferType = lowercase.tsInferType = tsInferType;
  lowercase.tSInstantiationExpression = lowercase.tsInstantiationExpression = tsInstantiationExpression;
  lowercase.tSInterfaceBody = lowercase.tsInterfaceBody = tsInterfaceBody;
  lowercase.tSInterfaceDeclaration = lowercase.tsInterfaceDeclaration = tsInterfaceDeclaration;
  lowercase.tSIntersectionType = lowercase.tsIntersectionType = tsIntersectionType;
  lowercase.tSIntrinsicKeyword = lowercase.tsIntrinsicKeyword = tsIntrinsicKeyword;
  lowercase.tSLiteralType = lowercase.tsLiteralType = tsLiteralType;
  lowercase.tSMappedType = lowercase.tsMappedType = tsMappedType;
  lowercase.tSMethodSignature = lowercase.tsMethodSignature = tsMethodSignature;
  lowercase.tSModuleBlock = lowercase.tsModuleBlock = tsModuleBlock;
  lowercase.tSModuleDeclaration = lowercase.tsModuleDeclaration = tsModuleDeclaration;
  lowercase.tSNamedTupleMember = lowercase.tsNamedTupleMember = tsNamedTupleMember;
  lowercase.tSNamespaceExportDeclaration = lowercase.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  lowercase.tSNeverKeyword = lowercase.tsNeverKeyword = tsNeverKeyword;
  lowercase.tSNonNullExpression = lowercase.tsNonNullExpression = tsNonNullExpression;
  lowercase.tSNullKeyword = lowercase.tsNullKeyword = tsNullKeyword;
  lowercase.tSNumberKeyword = lowercase.tsNumberKeyword = tsNumberKeyword;
  lowercase.tSObjectKeyword = lowercase.tsObjectKeyword = tsObjectKeyword;
  lowercase.tSOptionalType = lowercase.tsOptionalType = tsOptionalType;
  lowercase.tSParameterProperty = lowercase.tsParameterProperty = tsParameterProperty;
  lowercase.tSParenthesizedType = lowercase.tsParenthesizedType = tsParenthesizedType;
  lowercase.tSPropertySignature = lowercase.tsPropertySignature = tsPropertySignature;
  lowercase.tSQualifiedName = lowercase.tsQualifiedName = tsQualifiedName;
  lowercase.tSRestType = lowercase.tsRestType = tsRestType;
  lowercase.tSSatisfiesExpression = lowercase.tsSatisfiesExpression = tsSatisfiesExpression;
  lowercase.tSStringKeyword = lowercase.tsStringKeyword = tsStringKeyword;
  lowercase.tSSymbolKeyword = lowercase.tsSymbolKeyword = tsSymbolKeyword;
  lowercase.tSTemplateLiteralType = lowercase.tsTemplateLiteralType = tsTemplateLiteralType;
  lowercase.tSThisType = lowercase.tsThisType = tsThisType;
  lowercase.tSTupleType = lowercase.tsTupleType = tsTupleType;
  lowercase.tSTypeAliasDeclaration = lowercase.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  lowercase.tSTypeAnnotation = lowercase.tsTypeAnnotation = tsTypeAnnotation;
  lowercase.tSTypeAssertion = lowercase.tsTypeAssertion = tsTypeAssertion;
  lowercase.tSTypeLiteral = lowercase.tsTypeLiteral = tsTypeLiteral;
  lowercase.tSTypeOperator = lowercase.tsTypeOperator = tsTypeOperator;
  lowercase.tSTypeParameter = lowercase.tsTypeParameter = tsTypeParameter;
  lowercase.tSTypeParameterDeclaration = lowercase.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  lowercase.tSTypeParameterInstantiation = lowercase.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  lowercase.tSTypePredicate = lowercase.tsTypePredicate = tsTypePredicate;
  lowercase.tSTypeQuery = lowercase.tsTypeQuery = tsTypeQuery;
  lowercase.tSTypeReference = lowercase.tsTypeReference = tsTypeReference;
  lowercase.tSUndefinedKeyword = lowercase.tsUndefinedKeyword = tsUndefinedKeyword;
  lowercase.tSUnionType = lowercase.tsUnionType = tsUnionType;
  lowercase.tSUnknownKeyword = lowercase.tsUnknownKeyword = tsUnknownKeyword;
  lowercase.tSVoidKeyword = lowercase.tsVoidKeyword = tsVoidKeyword;
  lowercase.tupleExpression = tupleExpression;
  lowercase.tupleTypeAnnotation = tupleTypeAnnotation;
  lowercase.typeAlias = typeAlias;
  lowercase.typeAnnotation = typeAnnotation;
  lowercase.typeCastExpression = typeCastExpression;
  lowercase.typeParameter = typeParameter;
  lowercase.typeParameterDeclaration = typeParameterDeclaration;
  lowercase.typeParameterInstantiation = typeParameterInstantiation;
  lowercase.typeofTypeAnnotation = typeofTypeAnnotation;
  lowercase.unaryExpression = unaryExpression;
  lowercase.unionTypeAnnotation = unionTypeAnnotation;
  lowercase.updateExpression = updateExpression;
  lowercase.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  lowercase.variableDeclaration = variableDeclaration;
  lowercase.variableDeclarator = variableDeclarator;
  lowercase.variance = variance;
  lowercase.voidPattern = voidPattern;
  lowercase.voidTypeAnnotation = voidTypeAnnotation;
  lowercase.whileStatement = whileStatement;
  lowercase.withStatement = withStatement;
  lowercase.yieldExpression = yieldExpression;
  var _validate = requireValidate();
  var _deprecationWarning = requireDeprecationWarning();
  var utils2 = requireUtils();
  const {
    validateInternal: validate2
  } = _validate;
  const {
    NODE_FIELDS
  } = utils2;
  function bigIntLiteral(value) {
    if (typeof value === "bigint") {
      value = value.toString();
    }
    const node2 = {
      type: "BigIntLiteral",
      value
    };
    const defs = NODE_FIELDS.BigIntLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function arrayExpression(elements = []) {
    const node2 = {
      type: "ArrayExpression",
      elements
    };
    const defs = NODE_FIELDS.ArrayExpression;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function assignmentExpression(operator, left, right) {
    const node2 = {
      type: "AssignmentExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function binaryExpression(operator, left, right) {
    const node2 = {
      type: "BinaryExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.BinaryExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function interpreterDirective(value) {
    const node2 = {
      type: "InterpreterDirective",
      value
    };
    const defs = NODE_FIELDS.InterpreterDirective;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function directive(value) {
    const node2 = {
      type: "Directive",
      value
    };
    const defs = NODE_FIELDS.Directive;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function directiveLiteral(value) {
    const node2 = {
      type: "DirectiveLiteral",
      value
    };
    const defs = NODE_FIELDS.DirectiveLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function blockStatement(body, directives = []) {
    const node2 = {
      type: "BlockStatement",
      body,
      directives
    };
    const defs = NODE_FIELDS.BlockStatement;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.directives, node2, "directives", directives, 1);
    return node2;
  }
  function breakStatement(label = null) {
    const node2 = {
      type: "BreakStatement",
      label
    };
    const defs = NODE_FIELDS.BreakStatement;
    validate2(defs.label, node2, "label", label, 1);
    return node2;
  }
  function callExpression(callee, _arguments) {
    const node2 = {
      type: "CallExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.CallExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    return node2;
  }
  function catchClause(param = null, body) {
    const node2 = {
      type: "CatchClause",
      param,
      body
    };
    const defs = NODE_FIELDS.CatchClause;
    validate2(defs.param, node2, "param", param, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function conditionalExpression(test, consequent, alternate) {
    const node2 = {
      type: "ConditionalExpression",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.ConditionalExpression;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    validate2(defs.alternate, node2, "alternate", alternate, 1);
    return node2;
  }
  function continueStatement(label = null) {
    const node2 = {
      type: "ContinueStatement",
      label
    };
    const defs = NODE_FIELDS.ContinueStatement;
    validate2(defs.label, node2, "label", label, 1);
    return node2;
  }
  function debuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  }
  function doWhileStatement(test, body) {
    const node2 = {
      type: "DoWhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.DoWhileStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function emptyStatement() {
    return {
      type: "EmptyStatement"
    };
  }
  function expressionStatement(expression) {
    const node2 = {
      type: "ExpressionStatement",
      expression
    };
    const defs = NODE_FIELDS.ExpressionStatement;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function file(program2, comments2 = null, tokens = null) {
    const node2 = {
      type: "File",
      program: program2,
      comments: comments2,
      tokens
    };
    const defs = NODE_FIELDS.File;
    validate2(defs.program, node2, "program", program2, 1);
    validate2(defs.comments, node2, "comments", comments2, 1);
    validate2(defs.tokens, node2, "tokens", tokens);
    return node2;
  }
  function forInStatement(left, right, body) {
    const node2 = {
      type: "ForInStatement",
      left,
      right,
      body
    };
    const defs = NODE_FIELDS.ForInStatement;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function forStatement(init = null, test = null, update = null, body) {
    const node2 = {
      type: "ForStatement",
      init,
      test,
      update,
      body
    };
    const defs = NODE_FIELDS.ForStatement;
    validate2(defs.init, node2, "init", init, 1);
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.update, node2, "update", update, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function functionDeclaration(id = null, params, body, generator = false, async = false) {
    const node2 = {
      type: "FunctionDeclaration",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function functionExpression(id = null, params, body, generator = false, async = false) {
    const node2 = {
      type: "FunctionExpression",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionExpression;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function identifier2(name) {
    const node2 = {
      type: "Identifier",
      name
    };
    const defs = NODE_FIELDS.Identifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function ifStatement(test, consequent, alternate = null) {
    const node2 = {
      type: "IfStatement",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.IfStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    validate2(defs.alternate, node2, "alternate", alternate, 1);
    return node2;
  }
  function labeledStatement(label, body) {
    const node2 = {
      type: "LabeledStatement",
      label,
      body
    };
    const defs = NODE_FIELDS.LabeledStatement;
    validate2(defs.label, node2, "label", label, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function stringLiteral(value) {
    const node2 = {
      type: "StringLiteral",
      value
    };
    const defs = NODE_FIELDS.StringLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function numericLiteral(value) {
    const node2 = {
      type: "NumericLiteral",
      value
    };
    const defs = NODE_FIELDS.NumericLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function nullLiteral() {
    return {
      type: "NullLiteral"
    };
  }
  function booleanLiteral(value) {
    const node2 = {
      type: "BooleanLiteral",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function regExpLiteral(pattern, flags = "") {
    const node2 = {
      type: "RegExpLiteral",
      pattern,
      flags
    };
    const defs = NODE_FIELDS.RegExpLiteral;
    validate2(defs.pattern, node2, "pattern", pattern);
    validate2(defs.flags, node2, "flags", flags);
    return node2;
  }
  function logicalExpression(operator, left, right) {
    const node2 = {
      type: "LogicalExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.LogicalExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function memberExpression(object, property, computed = false, optional = null) {
    const node2 = {
      type: "MemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.MemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function newExpression(callee, _arguments) {
    const node2 = {
      type: "NewExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.NewExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    return node2;
  }
  function program(body, directives = [], sourceType = "script", interpreter = null) {
    const node2 = {
      type: "Program",
      body,
      directives,
      sourceType,
      interpreter
    };
    const defs = NODE_FIELDS.Program;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.directives, node2, "directives", directives, 1);
    validate2(defs.sourceType, node2, "sourceType", sourceType);
    validate2(defs.interpreter, node2, "interpreter", interpreter, 1);
    return node2;
  }
  function objectExpression(properties) {
    const node2 = {
      type: "ObjectExpression",
      properties
    };
    const defs = NODE_FIELDS.ObjectExpression;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    const node2 = {
      type: "ObjectMethod",
      kind,
      key,
      params,
      body,
      computed,
      generator,
      async
    };
    const defs = NODE_FIELDS.ObjectMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
    const node2 = {
      type: "ObjectProperty",
      key,
      value,
      computed,
      shorthand,
      decorators
    };
    const defs = NODE_FIELDS.ObjectProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.shorthand, node2, "shorthand", shorthand);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function restElement(argument) {
    const node2 = {
      type: "RestElement",
      argument
    };
    const defs = NODE_FIELDS.RestElement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function returnStatement(argument = null) {
    const node2 = {
      type: "ReturnStatement",
      argument
    };
    const defs = NODE_FIELDS.ReturnStatement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function sequenceExpression(expressions2) {
    const node2 = {
      type: "SequenceExpression",
      expressions: expressions2
    };
    const defs = NODE_FIELDS.SequenceExpression;
    validate2(defs.expressions, node2, "expressions", expressions2, 1);
    return node2;
  }
  function parenthesizedExpression(expression) {
    const node2 = {
      type: "ParenthesizedExpression",
      expression
    };
    const defs = NODE_FIELDS.ParenthesizedExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function switchCase(test = null, consequent) {
    const node2 = {
      type: "SwitchCase",
      test,
      consequent
    };
    const defs = NODE_FIELDS.SwitchCase;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    return node2;
  }
  function switchStatement(discriminant, cases) {
    const node2 = {
      type: "SwitchStatement",
      discriminant,
      cases
    };
    const defs = NODE_FIELDS.SwitchStatement;
    validate2(defs.discriminant, node2, "discriminant", discriminant, 1);
    validate2(defs.cases, node2, "cases", cases, 1);
    return node2;
  }
  function thisExpression() {
    return {
      type: "ThisExpression"
    };
  }
  function throwStatement(argument) {
    const node2 = {
      type: "ThrowStatement",
      argument
    };
    const defs = NODE_FIELDS.ThrowStatement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function tryStatement(block, handler = null, finalizer = null) {
    const node2 = {
      type: "TryStatement",
      block,
      handler,
      finalizer
    };
    const defs = NODE_FIELDS.TryStatement;
    validate2(defs.block, node2, "block", block, 1);
    validate2(defs.handler, node2, "handler", handler, 1);
    validate2(defs.finalizer, node2, "finalizer", finalizer, 1);
    return node2;
  }
  function unaryExpression(operator, argument, prefix = true) {
    const node2 = {
      type: "UnaryExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UnaryExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.prefix, node2, "prefix", prefix);
    return node2;
  }
  function updateExpression(operator, argument, prefix = false) {
    const node2 = {
      type: "UpdateExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UpdateExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.prefix, node2, "prefix", prefix);
    return node2;
  }
  function variableDeclaration(kind, declarations) {
    const node2 = {
      type: "VariableDeclaration",
      kind,
      declarations
    };
    const defs = NODE_FIELDS.VariableDeclaration;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.declarations, node2, "declarations", declarations, 1);
    return node2;
  }
  function variableDeclarator(id, init = null) {
    const node2 = {
      type: "VariableDeclarator",
      id,
      init
    };
    const defs = NODE_FIELDS.VariableDeclarator;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function whileStatement(test, body) {
    const node2 = {
      type: "WhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.WhileStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function withStatement(object, body) {
    const node2 = {
      type: "WithStatement",
      object,
      body
    };
    const defs = NODE_FIELDS.WithStatement;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function assignmentPattern(left, right) {
    const node2 = {
      type: "AssignmentPattern",
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentPattern;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function arrayPattern(elements) {
    const node2 = {
      type: "ArrayPattern",
      elements
    };
    const defs = NODE_FIELDS.ArrayPattern;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function arrowFunctionExpression(params, body, async = false) {
    const node2 = {
      type: "ArrowFunctionExpression",
      params,
      body,
      async,
      expression: null
    };
    const defs = NODE_FIELDS.ArrowFunctionExpression;
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function classBody(body) {
    const node2 = {
      type: "ClassBody",
      body
    };
    const defs = NODE_FIELDS.ClassBody;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function classExpression(id = null, superClass = null, body, decorators = null) {
    const node2 = {
      type: "ClassExpression",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassExpression;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.superClass, node2, "superClass", superClass, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function classDeclaration(id = null, superClass = null, body, decorators = null) {
    const node2 = {
      type: "ClassDeclaration",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.superClass, node2, "superClass", superClass, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function exportAllDeclaration(source) {
    const node2 = {
      type: "ExportAllDeclaration",
      source
    };
    const defs = NODE_FIELDS.ExportAllDeclaration;
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function exportDefaultDeclaration(declaration) {
    const node2 = {
      type: "ExportDefaultDeclaration",
      declaration
    };
    const defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    return node2;
  }
  function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    const node2 = {
      type: "ExportNamedDeclaration",
      declaration,
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ExportNamedDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function exportSpecifier(local, exported) {
    const node2 = {
      type: "ExportSpecifier",
      local,
      exported
    };
    const defs = NODE_FIELDS.ExportSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function forOfStatement(left, right, body, _await = false) {
    const node2 = {
      type: "ForOfStatement",
      left,
      right,
      body,
      await: _await
    };
    const defs = NODE_FIELDS.ForOfStatement;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.await, node2, "await", _await);
    return node2;
  }
  function importDeclaration(specifiers, source) {
    const node2 = {
      type: "ImportDeclaration",
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ImportDeclaration;
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function importDefaultSpecifier(local) {
    const node2 = {
      type: "ImportDefaultSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    return node2;
  }
  function importNamespaceSpecifier(local) {
    const node2 = {
      type: "ImportNamespaceSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    return node2;
  }
  function importSpecifier(local, imported) {
    const node2 = {
      type: "ImportSpecifier",
      local,
      imported
    };
    const defs = NODE_FIELDS.ImportSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    validate2(defs.imported, node2, "imported", imported, 1);
    return node2;
  }
  function importExpression(source, options2 = null) {
    const node2 = {
      type: "ImportExpression",
      source,
      options: options2
    };
    const defs = NODE_FIELDS.ImportExpression;
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.options, node2, "options", options2, 1);
    return node2;
  }
  function metaProperty(meta, property) {
    const node2 = {
      type: "MetaProperty",
      meta,
      property
    };
    const defs = NODE_FIELDS.MetaProperty;
    validate2(defs.meta, node2, "meta", meta, 1);
    validate2(defs.property, node2, "property", property, 1);
    return node2;
  }
  function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    const node2 = {
      type: "ClassMethod",
      kind,
      key,
      params,
      body,
      computed,
      static: _static,
      generator,
      async
    };
    const defs = NODE_FIELDS.ClassMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function objectPattern(properties) {
    const node2 = {
      type: "ObjectPattern",
      properties
    };
    const defs = NODE_FIELDS.ObjectPattern;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function spreadElement(argument) {
    const node2 = {
      type: "SpreadElement",
      argument
    };
    const defs = NODE_FIELDS.SpreadElement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function _super() {
    return {
      type: "Super"
    };
  }
  function taggedTemplateExpression(tag, quasi) {
    const node2 = {
      type: "TaggedTemplateExpression",
      tag,
      quasi
    };
    const defs = NODE_FIELDS.TaggedTemplateExpression;
    validate2(defs.tag, node2, "tag", tag, 1);
    validate2(defs.quasi, node2, "quasi", quasi, 1);
    return node2;
  }
  function templateElement(value, tail = false) {
    const node2 = {
      type: "TemplateElement",
      value,
      tail
    };
    const defs = NODE_FIELDS.TemplateElement;
    validate2(defs.value, node2, "value", value);
    validate2(defs.tail, node2, "tail", tail);
    return node2;
  }
  function templateLiteral(quasis, expressions2) {
    const node2 = {
      type: "TemplateLiteral",
      quasis,
      expressions: expressions2
    };
    const defs = NODE_FIELDS.TemplateLiteral;
    validate2(defs.quasis, node2, "quasis", quasis, 1);
    validate2(defs.expressions, node2, "expressions", expressions2, 1);
    return node2;
  }
  function yieldExpression(argument = null, delegate = false) {
    const node2 = {
      type: "YieldExpression",
      argument,
      delegate
    };
    const defs = NODE_FIELDS.YieldExpression;
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.delegate, node2, "delegate", delegate);
    return node2;
  }
  function awaitExpression(argument) {
    const node2 = {
      type: "AwaitExpression",
      argument
    };
    const defs = NODE_FIELDS.AwaitExpression;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function _import() {
    return {
      type: "Import"
    };
  }
  function exportNamespaceSpecifier(exported) {
    const node2 = {
      type: "ExportNamespaceSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function optionalMemberExpression(object, property, computed = false, optional) {
    const node2 = {
      type: "OptionalMemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.OptionalMemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function optionalCallExpression(callee, _arguments, optional) {
    const node2 = {
      type: "OptionalCallExpression",
      callee,
      arguments: _arguments,
      optional
    };
    const defs = NODE_FIELDS.OptionalCallExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node2 = {
      type: "ClassProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node2 = {
      type: "ClassAccessorProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassAccessorProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    const node2 = {
      type: "ClassPrivateProperty",
      key,
      value,
      decorators,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classPrivateMethod(kind = "method", key, params, body, _static = false) {
    const node2 = {
      type: "ClassPrivateMethod",
      kind,
      key,
      params,
      body,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function privateName(id) {
    const node2 = {
      type: "PrivateName",
      id
    };
    const defs = NODE_FIELDS.PrivateName;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function staticBlock(body) {
    const node2 = {
      type: "StaticBlock",
      body
    };
    const defs = NODE_FIELDS.StaticBlock;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function importAttribute(key, value) {
    const node2 = {
      type: "ImportAttribute",
      key,
      value
    };
    const defs = NODE_FIELDS.ImportAttribute;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function anyTypeAnnotation() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function arrayTypeAnnotation(elementType) {
    const node2 = {
      type: "ArrayTypeAnnotation",
      elementType
    };
    const defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    return node2;
  }
  function booleanTypeAnnotation() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function booleanLiteralTypeAnnotation(value) {
    const node2 = {
      type: "BooleanLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function nullLiteralTypeAnnotation() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function classImplements(id, typeParameters = null) {
    const node2 = {
      type: "ClassImplements",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.ClassImplements;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function declareClass(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "DeclareClass",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareClass;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function declareFunction(id) {
    const node2 = {
      type: "DeclareFunction",
      id
    };
    const defs = NODE_FIELDS.DeclareFunction;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function declareInterface(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "DeclareInterface",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareInterface;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function declareModule(id, body, kind = null) {
    const node2 = {
      type: "DeclareModule",
      id,
      body,
      kind
    };
    const defs = NODE_FIELDS.DeclareModule;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.kind, node2, "kind", kind);
    return node2;
  }
  function declareModuleExports(typeAnnotation2) {
    const node2 = {
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.DeclareModuleExports;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function declareTypeAlias(id, typeParameters = null, right) {
    const node2 = {
      type: "DeclareTypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.DeclareTypeAlias;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function declareOpaqueType(id, typeParameters = null, supertype = null) {
    const node2 = {
      type: "DeclareOpaqueType",
      id,
      typeParameters,
      supertype
    };
    const defs = NODE_FIELDS.DeclareOpaqueType;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.supertype, node2, "supertype", supertype, 1);
    return node2;
  }
  function declareVariable(id) {
    const node2 = {
      type: "DeclareVariable",
      id
    };
    const defs = NODE_FIELDS.DeclareVariable;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
    const node2 = {
      type: "DeclareExportDeclaration",
      declaration,
      specifiers,
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    return node2;
  }
  function declareExportAllDeclaration(source, attributes = null) {
    const node2 = {
      type: "DeclareExportAllDeclaration",
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    return node2;
  }
  function declaredPredicate(value) {
    const node2 = {
      type: "DeclaredPredicate",
      value
    };
    const defs = NODE_FIELDS.DeclaredPredicate;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function existsTypeAnnotation() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    const node2 = {
      type: "FunctionTypeAnnotation",
      typeParameters,
      params,
      rest,
      returnType
    };
    const defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.rest, node2, "rest", rest, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function functionTypeParam(name = null, typeAnnotation2) {
    const node2 = {
      type: "FunctionTypeParam",
      name,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.FunctionTypeParam;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function genericTypeAnnotation(id, typeParameters = null) {
    const node2 = {
      type: "GenericTypeAnnotation",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.GenericTypeAnnotation;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function inferredPredicate() {
    return {
      type: "InferredPredicate"
    };
  }
  function interfaceExtends(id, typeParameters = null) {
    const node2 = {
      type: "InterfaceExtends",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.InterfaceExtends;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "InterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function interfaceTypeAnnotation(_extends = null, body) {
    const node2 = {
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function intersectionTypeAnnotation(types2) {
    const node2 = {
      type: "IntersectionTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function mixedTypeAnnotation() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function emptyTypeAnnotation() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function nullableTypeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.NullableTypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function numberLiteralTypeAnnotation(value) {
    const node2 = {
      type: "NumberLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function numberTypeAnnotation() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    const node2 = {
      type: "ObjectTypeAnnotation",
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact
    };
    const defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate2(defs.properties, node2, "properties", properties, 1);
    validate2(defs.indexers, node2, "indexers", indexers, 1);
    validate2(defs.callProperties, node2, "callProperties", callProperties, 1);
    validate2(defs.internalSlots, node2, "internalSlots", internalSlots, 1);
    validate2(defs.exact, node2, "exact", exact);
    return node2;
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    const node2 = {
      type: "ObjectTypeInternalSlot",
      id,
      value,
      optional,
      static: _static,
      method
    };
    const defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.optional, node2, "optional", optional);
    validate2(defs.static, node2, "static", _static);
    validate2(defs.method, node2, "method", method);
    return node2;
  }
  function objectTypeCallProperty(value) {
    const node2 = {
      type: "ObjectTypeCallProperty",
      value,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function objectTypeIndexer(id = null, key, value, variance2 = null) {
    const node2 = {
      type: "ObjectTypeIndexer",
      id,
      key,
      value,
      variance: variance2,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeIndexer;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function objectTypeProperty(key, value, variance2 = null) {
    const node2 = {
      type: "ObjectTypeProperty",
      key,
      value,
      variance: variance2,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function objectTypeSpreadProperty(argument) {
    const node2 = {
      type: "ObjectTypeSpreadProperty",
      argument
    };
    const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    const node2 = {
      type: "OpaqueType",
      id,
      typeParameters,
      supertype,
      impltype
    };
    const defs = NODE_FIELDS.OpaqueType;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.supertype, node2, "supertype", supertype, 1);
    validate2(defs.impltype, node2, "impltype", impltype, 1);
    return node2;
  }
  function qualifiedTypeIdentifier(id, qualification) {
    const node2 = {
      type: "QualifiedTypeIdentifier",
      id,
      qualification
    };
    const defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.qualification, node2, "qualification", qualification, 1);
    return node2;
  }
  function stringLiteralTypeAnnotation(value) {
    const node2 = {
      type: "StringLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function stringTypeAnnotation() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function symbolTypeAnnotation() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function thisTypeAnnotation() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function tupleTypeAnnotation(types2) {
    const node2 = {
      type: "TupleTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.TupleTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function typeofTypeAnnotation(argument) {
    const node2 = {
      type: "TypeofTypeAnnotation",
      argument
    };
    const defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function typeAlias(id, typeParameters = null, right) {
    const node2 = {
      type: "TypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.TypeAlias;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function typeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function typeCastExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TypeCastExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeCastExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function typeParameter(bound = null, _default = null, variance2 = null) {
    const node2 = {
      type: "TypeParameter",
      bound,
      default: _default,
      variance: variance2,
      name: null
    };
    const defs = NODE_FIELDS.TypeParameter;
    validate2(defs.bound, node2, "bound", bound, 1);
    validate2(defs.default, node2, "default", _default, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function typeParameterDeclaration(params) {
    const node2 = {
      type: "TypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TypeParameterDeclaration;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function typeParameterInstantiation(params) {
    const node2 = {
      type: "TypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TypeParameterInstantiation;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function unionTypeAnnotation(types2) {
    const node2 = {
      type: "UnionTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.UnionTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function variance(kind) {
    const node2 = {
      type: "Variance",
      kind
    };
    const defs = NODE_FIELDS.Variance;
    validate2(defs.kind, node2, "kind", kind);
    return node2;
  }
  function voidTypeAnnotation() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function enumDeclaration(id, body) {
    const node2 = {
      type: "EnumDeclaration",
      id,
      body
    };
    const defs = NODE_FIELDS.EnumDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function enumBooleanBody(members) {
    const node2 = {
      type: "EnumBooleanBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumBooleanBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumNumberBody(members) {
    const node2 = {
      type: "EnumNumberBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumNumberBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumStringBody(members) {
    const node2 = {
      type: "EnumStringBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumStringBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumSymbolBody(members) {
    const node2 = {
      type: "EnumSymbolBody",
      members,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumSymbolBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumBooleanMember(id) {
    const node2 = {
      type: "EnumBooleanMember",
      id,
      init: null
    };
    const defs = NODE_FIELDS.EnumBooleanMember;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function enumNumberMember(id, init) {
    const node2 = {
      type: "EnumNumberMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumNumberMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function enumStringMember(id, init) {
    const node2 = {
      type: "EnumStringMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumStringMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function enumDefaultedMember(id) {
    const node2 = {
      type: "EnumDefaultedMember",
      id
    };
    const defs = NODE_FIELDS.EnumDefaultedMember;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function indexedAccessType(objectType, indexType) {
    const node2 = {
      type: "IndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.IndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function optionalIndexedAccessType(objectType, indexType) {
    const node2 = {
      type: "OptionalIndexedAccessType",
      objectType,
      indexType,
      optional: null
    };
    const defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function jsxAttribute(name, value = null) {
    const node2 = {
      type: "JSXAttribute",
      name,
      value
    };
    const defs = NODE_FIELDS.JSXAttribute;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function jsxClosingElement(name) {
    const node2 = {
      type: "JSXClosingElement",
      name
    };
    const defs = NODE_FIELDS.JSXClosingElement;
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
    const node2 = {
      type: "JSXElement",
      openingElement,
      closingElement,
      children,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXElement;
    validate2(defs.openingElement, node2, "openingElement", openingElement, 1);
    validate2(defs.closingElement, node2, "closingElement", closingElement, 1);
    validate2(defs.children, node2, "children", children, 1);
    validate2(defs.selfClosing, node2, "selfClosing", selfClosing);
    return node2;
  }
  function jsxEmptyExpression() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function jsxExpressionContainer(expression) {
    const node2 = {
      type: "JSXExpressionContainer",
      expression
    };
    const defs = NODE_FIELDS.JSXExpressionContainer;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function jsxSpreadChild(expression) {
    const node2 = {
      type: "JSXSpreadChild",
      expression
    };
    const defs = NODE_FIELDS.JSXSpreadChild;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function jsxIdentifier(name) {
    const node2 = {
      type: "JSXIdentifier",
      name
    };
    const defs = NODE_FIELDS.JSXIdentifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function jsxMemberExpression(object, property) {
    const node2 = {
      type: "JSXMemberExpression",
      object,
      property
    };
    const defs = NODE_FIELDS.JSXMemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    return node2;
  }
  function jsxNamespacedName(namespace, name) {
    const node2 = {
      type: "JSXNamespacedName",
      namespace,
      name
    };
    const defs = NODE_FIELDS.JSXNamespacedName;
    validate2(defs.namespace, node2, "namespace", namespace, 1);
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function jsxOpeningElement(name, attributes, selfClosing = false) {
    const node2 = {
      type: "JSXOpeningElement",
      name,
      attributes,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXOpeningElement;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    validate2(defs.selfClosing, node2, "selfClosing", selfClosing);
    return node2;
  }
  function jsxSpreadAttribute(argument) {
    const node2 = {
      type: "JSXSpreadAttribute",
      argument
    };
    const defs = NODE_FIELDS.JSXSpreadAttribute;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function jsxText(value) {
    const node2 = {
      type: "JSXText",
      value
    };
    const defs = NODE_FIELDS.JSXText;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    const node2 = {
      type: "JSXFragment",
      openingFragment,
      closingFragment,
      children
    };
    const defs = NODE_FIELDS.JSXFragment;
    validate2(defs.openingFragment, node2, "openingFragment", openingFragment, 1);
    validate2(defs.closingFragment, node2, "closingFragment", closingFragment, 1);
    validate2(defs.children, node2, "children", children, 1);
    return node2;
  }
  function jsxOpeningFragment() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function jsxClosingFragment() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function noop() {
    return {
      type: "Noop"
    };
  }
  function placeholder(expectedNode, name) {
    const node2 = {
      type: "Placeholder",
      expectedNode,
      name
    };
    const defs = NODE_FIELDS.Placeholder;
    validate2(defs.expectedNode, node2, "expectedNode", expectedNode);
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function v8IntrinsicIdentifier(name) {
    const node2 = {
      type: "V8IntrinsicIdentifier",
      name
    };
    const defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function argumentPlaceholder() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function bindExpression(object, callee) {
    const node2 = {
      type: "BindExpression",
      object,
      callee
    };
    const defs = NODE_FIELDS.BindExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.callee, node2, "callee", callee, 1);
    return node2;
  }
  function decorator(expression) {
    const node2 = {
      type: "Decorator",
      expression
    };
    const defs = NODE_FIELDS.Decorator;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function doExpression(body, async = false) {
    const node2 = {
      type: "DoExpression",
      body,
      async
    };
    const defs = NODE_FIELDS.DoExpression;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function exportDefaultSpecifier(exported) {
    const node2 = {
      type: "ExportDefaultSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function recordExpression(properties) {
    const node2 = {
      type: "RecordExpression",
      properties
    };
    const defs = NODE_FIELDS.RecordExpression;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function tupleExpression(elements = []) {
    const node2 = {
      type: "TupleExpression",
      elements
    };
    const defs = NODE_FIELDS.TupleExpression;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function decimalLiteral(value) {
    const node2 = {
      type: "DecimalLiteral",
      value
    };
    const defs = NODE_FIELDS.DecimalLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function moduleExpression(body) {
    const node2 = {
      type: "ModuleExpression",
      body
    };
    const defs = NODE_FIELDS.ModuleExpression;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function topicReference() {
    return {
      type: "TopicReference"
    };
  }
  function pipelineTopicExpression(expression) {
    const node2 = {
      type: "PipelineTopicExpression",
      expression
    };
    const defs = NODE_FIELDS.PipelineTopicExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function pipelineBareFunction(callee) {
    const node2 = {
      type: "PipelineBareFunction",
      callee
    };
    const defs = NODE_FIELDS.PipelineBareFunction;
    validate2(defs.callee, node2, "callee", callee, 1);
    return node2;
  }
  function pipelinePrimaryTopicReference() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function voidPattern() {
    return {
      type: "VoidPattern"
    };
  }
  function tsParameterProperty(parameter) {
    const node2 = {
      type: "TSParameterProperty",
      parameter
    };
    const defs = NODE_FIELDS.TSParameterProperty;
    validate2(defs.parameter, node2, "parameter", parameter, 1);
    return node2;
  }
  function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    const node2 = {
      type: "TSDeclareFunction",
      id,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareFunction;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    const node2 = {
      type: "TSDeclareMethod",
      decorators,
      key,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareMethod;
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function tsQualifiedName(left, right) {
    const node2 = {
      type: "TSQualifiedName",
      left,
      right
    };
    const defs = NODE_FIELDS.TSQualifiedName;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSCallSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSConstructSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsPropertySignature(key, typeAnnotation2 = null) {
    const node2 = {
      type: "TSPropertySignature",
      key,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSPropertySignature;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSMethodSignature",
      key,
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2,
      kind: null
    };
    const defs = NODE_FIELDS.TSMethodSignature;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsIndexSignature(parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSIndexSignature",
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSIndexSignature;
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsAnyKeyword() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function tsBooleanKeyword() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function tsBigIntKeyword() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function tsIntrinsicKeyword() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function tsNeverKeyword() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function tsNullKeyword() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tsNumberKeyword() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function tsObjectKeyword() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function tsStringKeyword() {
    return {
      type: "TSStringKeyword"
    };
  }
  function tsSymbolKeyword() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function tsUndefinedKeyword() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function tsUnknownKeyword() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function tsVoidKeyword() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function tsThisType() {
    return {
      type: "TSThisType"
    };
  }
  function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSFunctionType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSFunctionType;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSConstructorType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructorType;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeReference(typeName, typeParameters = null) {
    const node2 = {
      type: "TSTypeReference",
      typeName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeReference;
    validate2(defs.typeName, node2, "typeName", typeName, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
    const node2 = {
      type: "TSTypePredicate",
      parameterName,
      typeAnnotation: typeAnnotation2,
      asserts
    };
    const defs = NODE_FIELDS.TSTypePredicate;
    validate2(defs.parameterName, node2, "parameterName", parameterName, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.asserts, node2, "asserts", asserts);
    return node2;
  }
  function tsTypeQuery(exprName, typeParameters = null) {
    const node2 = {
      type: "TSTypeQuery",
      exprName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeQuery;
    validate2(defs.exprName, node2, "exprName", exprName, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsTypeLiteral(members) {
    const node2 = {
      type: "TSTypeLiteral",
      members
    };
    const defs = NODE_FIELDS.TSTypeLiteral;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsArrayType(elementType) {
    const node2 = {
      type: "TSArrayType",
      elementType
    };
    const defs = NODE_FIELDS.TSArrayType;
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    return node2;
  }
  function tsTupleType(elementTypes) {
    const node2 = {
      type: "TSTupleType",
      elementTypes
    };
    const defs = NODE_FIELDS.TSTupleType;
    validate2(defs.elementTypes, node2, "elementTypes", elementTypes, 1);
    return node2;
  }
  function tsOptionalType(typeAnnotation2) {
    const node2 = {
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSOptionalType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsRestType(typeAnnotation2) {
    const node2 = {
      type: "TSRestType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSRestType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsNamedTupleMember(label, elementType, optional = false) {
    const node2 = {
      type: "TSNamedTupleMember",
      label,
      elementType,
      optional
    };
    const defs = NODE_FIELDS.TSNamedTupleMember;
    validate2(defs.label, node2, "label", label, 1);
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function tsUnionType(types2) {
    const node2 = {
      type: "TSUnionType",
      types: types2
    };
    const defs = NODE_FIELDS.TSUnionType;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsIntersectionType(types2) {
    const node2 = {
      type: "TSIntersectionType",
      types: types2
    };
    const defs = NODE_FIELDS.TSIntersectionType;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    const node2 = {
      type: "TSConditionalType",
      checkType,
      extendsType,
      trueType,
      falseType
    };
    const defs = NODE_FIELDS.TSConditionalType;
    validate2(defs.checkType, node2, "checkType", checkType, 1);
    validate2(defs.extendsType, node2, "extendsType", extendsType, 1);
    validate2(defs.trueType, node2, "trueType", trueType, 1);
    validate2(defs.falseType, node2, "falseType", falseType, 1);
    return node2;
  }
  function tsInferType(typeParameter2) {
    const node2 = {
      type: "TSInferType",
      typeParameter: typeParameter2
    };
    const defs = NODE_FIELDS.TSInferType;
    validate2(defs.typeParameter, node2, "typeParameter", typeParameter2, 1);
    return node2;
  }
  function tsParenthesizedType(typeAnnotation2) {
    const node2 = {
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSParenthesizedType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeOperator(typeAnnotation2, operator = "keyof") {
    const node2 = {
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation2,
      operator
    };
    const defs = NODE_FIELDS.TSTypeOperator;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.operator, node2, "operator", operator);
    return node2;
  }
  function tsIndexedAccessType(objectType, indexType) {
    const node2 = {
      type: "TSIndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.TSIndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
    const node2 = {
      type: "TSMappedType",
      typeParameter: typeParameter2,
      typeAnnotation: typeAnnotation2,
      nameType
    };
    const defs = NODE_FIELDS.TSMappedType;
    validate2(defs.typeParameter, node2, "typeParameter", typeParameter2, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.nameType, node2, "nameType", nameType, 1);
    return node2;
  }
  function tsTemplateLiteralType(quasis, types2) {
    const node2 = {
      type: "TSTemplateLiteralType",
      quasis,
      types: types2
    };
    const defs = NODE_FIELDS.TSTemplateLiteralType;
    validate2(defs.quasis, node2, "quasis", quasis, 1);
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsLiteralType(literal2) {
    const node2 = {
      type: "TSLiteralType",
      literal: literal2
    };
    const defs = NODE_FIELDS.TSLiteralType;
    validate2(defs.literal, node2, "literal", literal2, 1);
    return node2;
  }
  function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    const node2 = {
      type: "TSExpressionWithTypeArguments",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "TSInterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsInterfaceBody(body) {
    const node2 = {
      type: "TSInterfaceBody",
      body
    };
    const defs = NODE_FIELDS.TSInterfaceBody;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
    const node2 = {
      type: "TSTypeAliasDeclaration",
      id,
      typeParameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsInstantiationExpression(expression, typeParameters = null) {
    const node2 = {
      type: "TSInstantiationExpression",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSInstantiationExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsAsExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TSAsExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSAsExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsSatisfiesExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TSSatisfiesExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSSatisfiesExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeAssertion(typeAnnotation2, expression) {
    const node2 = {
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation2,
      expression
    };
    const defs = NODE_FIELDS.TSTypeAssertion;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsEnumBody(members) {
    const node2 = {
      type: "TSEnumBody",
      members
    };
    const defs = NODE_FIELDS.TSEnumBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsEnumDeclaration(id, members) {
    const node2 = {
      type: "TSEnumDeclaration",
      id,
      members
    };
    const defs = NODE_FIELDS.TSEnumDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsEnumMember(id, initializer = null) {
    const node2 = {
      type: "TSEnumMember",
      id,
      initializer
    };
    const defs = NODE_FIELDS.TSEnumMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.initializer, node2, "initializer", initializer, 1);
    return node2;
  }
  function tsModuleDeclaration(id, body) {
    const node2 = {
      type: "TSModuleDeclaration",
      id,
      body,
      kind: null
    };
    const defs = NODE_FIELDS.TSModuleDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsModuleBlock(body) {
    const node2 = {
      type: "TSModuleBlock",
      body
    };
    const defs = NODE_FIELDS.TSModuleBlock;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsImportType(argument, qualifier = null, typeParameters = null) {
    const node2 = {
      type: "TSImportType",
      argument,
      qualifier,
      typeParameters
    };
    const defs = NODE_FIELDS.TSImportType;
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.qualifier, node2, "qualifier", qualifier, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    const node2 = {
      type: "TSImportEqualsDeclaration",
      id,
      moduleReference,
      isExport: null
    };
    const defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.moduleReference, node2, "moduleReference", moduleReference, 1);
    return node2;
  }
  function tsExternalModuleReference(expression) {
    const node2 = {
      type: "TSExternalModuleReference",
      expression
    };
    const defs = NODE_FIELDS.TSExternalModuleReference;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsNonNullExpression(expression) {
    const node2 = {
      type: "TSNonNullExpression",
      expression
    };
    const defs = NODE_FIELDS.TSNonNullExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsExportAssignment(expression) {
    const node2 = {
      type: "TSExportAssignment",
      expression
    };
    const defs = NODE_FIELDS.TSExportAssignment;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsNamespaceExportDeclaration(id) {
    const node2 = {
      type: "TSNamespaceExportDeclaration",
      id
    };
    const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function tsTypeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeParameterInstantiation(params) {
    const node2 = {
      type: "TSTypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function tsTypeParameterDeclaration(params) {
    const node2 = {
      type: "TSTypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function tsTypeParameter(constraint = null, _default = null, name) {
    const node2 = {
      type: "TSTypeParameter",
      constraint,
      default: _default,
      name
    };
    const defs = NODE_FIELDS.TSTypeParameter;
    validate2(defs.constraint, node2, "constraint", constraint, 1);
    validate2(defs.default, node2, "default", _default, 1);
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function NumberLiteral(value) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
  }
  function RegexLiteral(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  }
  return lowercase;
}
var uppercase = {};
var hasRequiredUppercase;
function requireUppercase() {
  if (hasRequiredUppercase) return uppercase;
  hasRequiredUppercase = 1;
  Object.defineProperty(uppercase, "__esModule", {
    value: true
  });
  uppercase.JSXIdentifier = uppercase.JSXFragment = uppercase.JSXExpressionContainer = uppercase.JSXEmptyExpression = uppercase.JSXElement = uppercase.JSXClosingFragment = uppercase.JSXClosingElement = uppercase.JSXAttribute = uppercase.IntersectionTypeAnnotation = uppercase.InterpreterDirective = uppercase.InterfaceTypeAnnotation = uppercase.InterfaceExtends = uppercase.InterfaceDeclaration = uppercase.InferredPredicate = uppercase.IndexedAccessType = uppercase.ImportSpecifier = uppercase.ImportNamespaceSpecifier = uppercase.ImportExpression = uppercase.ImportDefaultSpecifier = uppercase.ImportDeclaration = uppercase.ImportAttribute = uppercase.Import = uppercase.IfStatement = uppercase.Identifier = uppercase.GenericTypeAnnotation = uppercase.FunctionTypeParam = uppercase.FunctionTypeAnnotation = uppercase.FunctionExpression = uppercase.FunctionDeclaration = uppercase.ForStatement = uppercase.ForOfStatement = uppercase.ForInStatement = uppercase.File = uppercase.ExpressionStatement = uppercase.ExportSpecifier = uppercase.ExportNamespaceSpecifier = uppercase.ExportNamedDeclaration = uppercase.ExportDefaultSpecifier = uppercase.ExportDefaultDeclaration = uppercase.ExportAllDeclaration = uppercase.ExistsTypeAnnotation = uppercase.EnumSymbolBody = uppercase.EnumStringMember = uppercase.EnumStringBody = uppercase.EnumNumberMember = uppercase.EnumNumberBody = uppercase.EnumDefaultedMember = uppercase.EnumDeclaration = uppercase.EnumBooleanMember = uppercase.EnumBooleanBody = uppercase.EmptyTypeAnnotation = uppercase.EmptyStatement = uppercase.DoWhileStatement = uppercase.DoExpression = uppercase.DirectiveLiteral = uppercase.Directive = uppercase.Decorator = uppercase.DeclaredPredicate = uppercase.DeclareVariable = uppercase.DeclareTypeAlias = uppercase.DeclareOpaqueType = uppercase.DeclareModuleExports = uppercase.DeclareModule = uppercase.DeclareInterface = uppercase.DeclareFunction = uppercase.DeclareExportDeclaration = uppercase.DeclareExportAllDeclaration = uppercase.DeclareClass = uppercase.DecimalLiteral = uppercase.DebuggerStatement = uppercase.ContinueStatement = uppercase.ConditionalExpression = uppercase.ClassProperty = uppercase.ClassPrivateProperty = uppercase.ClassPrivateMethod = uppercase.ClassMethod = uppercase.ClassImplements = uppercase.ClassExpression = uppercase.ClassDeclaration = uppercase.ClassBody = uppercase.ClassAccessorProperty = uppercase.CatchClause = uppercase.CallExpression = uppercase.BreakStatement = uppercase.BooleanTypeAnnotation = uppercase.BooleanLiteralTypeAnnotation = uppercase.BooleanLiteral = uppercase.BlockStatement = uppercase.BindExpression = uppercase.BinaryExpression = uppercase.BigIntLiteral = uppercase.AwaitExpression = uppercase.AssignmentPattern = uppercase.AssignmentExpression = uppercase.ArrowFunctionExpression = uppercase.ArrayTypeAnnotation = uppercase.ArrayPattern = uppercase.ArrayExpression = uppercase.ArgumentPlaceholder = uppercase.AnyTypeAnnotation = void 0;
  uppercase.TSNumberKeyword = uppercase.TSNullKeyword = uppercase.TSNonNullExpression = uppercase.TSNeverKeyword = uppercase.TSNamespaceExportDeclaration = uppercase.TSNamedTupleMember = uppercase.TSModuleDeclaration = uppercase.TSModuleBlock = uppercase.TSMethodSignature = uppercase.TSMappedType = uppercase.TSLiteralType = uppercase.TSIntrinsicKeyword = uppercase.TSIntersectionType = uppercase.TSInterfaceDeclaration = uppercase.TSInterfaceBody = uppercase.TSInstantiationExpression = uppercase.TSInferType = uppercase.TSIndexedAccessType = uppercase.TSIndexSignature = uppercase.TSImportType = uppercase.TSImportEqualsDeclaration = uppercase.TSFunctionType = uppercase.TSExternalModuleReference = uppercase.TSExpressionWithTypeArguments = uppercase.TSExportAssignment = uppercase.TSEnumMember = uppercase.TSEnumDeclaration = uppercase.TSEnumBody = uppercase.TSDeclareMethod = uppercase.TSDeclareFunction = uppercase.TSConstructorType = uppercase.TSConstructSignatureDeclaration = uppercase.TSConditionalType = uppercase.TSCallSignatureDeclaration = uppercase.TSBooleanKeyword = uppercase.TSBigIntKeyword = uppercase.TSAsExpression = uppercase.TSArrayType = uppercase.TSAnyKeyword = uppercase.SymbolTypeAnnotation = uppercase.SwitchStatement = uppercase.SwitchCase = uppercase.Super = uppercase.StringTypeAnnotation = uppercase.StringLiteralTypeAnnotation = uppercase.StringLiteral = uppercase.StaticBlock = uppercase.SpreadProperty = uppercase.SpreadElement = uppercase.SequenceExpression = uppercase.ReturnStatement = uppercase.RestProperty = uppercase.RestElement = uppercase.RegexLiteral = uppercase.RegExpLiteral = uppercase.RecordExpression = uppercase.QualifiedTypeIdentifier = uppercase.Program = uppercase.PrivateName = uppercase.Placeholder = uppercase.PipelineTopicExpression = uppercase.PipelinePrimaryTopicReference = uppercase.PipelineBareFunction = uppercase.ParenthesizedExpression = uppercase.OptionalMemberExpression = uppercase.OptionalIndexedAccessType = uppercase.OptionalCallExpression = uppercase.OpaqueType = uppercase.ObjectTypeSpreadProperty = uppercase.ObjectTypeProperty = uppercase.ObjectTypeInternalSlot = uppercase.ObjectTypeIndexer = uppercase.ObjectTypeCallProperty = uppercase.ObjectTypeAnnotation = uppercase.ObjectProperty = uppercase.ObjectPattern = uppercase.ObjectMethod = uppercase.ObjectExpression = uppercase.NumericLiteral = uppercase.NumberTypeAnnotation = uppercase.NumberLiteralTypeAnnotation = uppercase.NumberLiteral = uppercase.NullableTypeAnnotation = uppercase.NullLiteralTypeAnnotation = uppercase.NullLiteral = uppercase.Noop = uppercase.NewExpression = uppercase.ModuleExpression = uppercase.MixedTypeAnnotation = uppercase.MetaProperty = uppercase.MemberExpression = uppercase.LogicalExpression = uppercase.LabeledStatement = uppercase.JSXText = uppercase.JSXSpreadChild = uppercase.JSXSpreadAttribute = uppercase.JSXOpeningFragment = uppercase.JSXOpeningElement = uppercase.JSXNamespacedName = uppercase.JSXMemberExpression = void 0;
  uppercase.YieldExpression = uppercase.WithStatement = uppercase.WhileStatement = uppercase.VoidTypeAnnotation = uppercase.VoidPattern = uppercase.Variance = uppercase.VariableDeclarator = uppercase.VariableDeclaration = uppercase.V8IntrinsicIdentifier = uppercase.UpdateExpression = uppercase.UnionTypeAnnotation = uppercase.UnaryExpression = uppercase.TypeofTypeAnnotation = uppercase.TypeParameterInstantiation = uppercase.TypeParameterDeclaration = uppercase.TypeParameter = uppercase.TypeCastExpression = uppercase.TypeAnnotation = uppercase.TypeAlias = uppercase.TupleTypeAnnotation = uppercase.TupleExpression = uppercase.TryStatement = uppercase.TopicReference = uppercase.ThrowStatement = uppercase.ThisTypeAnnotation = uppercase.ThisExpression = uppercase.TemplateLiteral = uppercase.TemplateElement = uppercase.TaggedTemplateExpression = uppercase.TSVoidKeyword = uppercase.TSUnknownKeyword = uppercase.TSUnionType = uppercase.TSUndefinedKeyword = uppercase.TSTypeReference = uppercase.TSTypeQuery = uppercase.TSTypePredicate = uppercase.TSTypeParameterInstantiation = uppercase.TSTypeParameterDeclaration = uppercase.TSTypeParameter = uppercase.TSTypeOperator = uppercase.TSTypeLiteral = uppercase.TSTypeAssertion = uppercase.TSTypeAnnotation = uppercase.TSTypeAliasDeclaration = uppercase.TSTupleType = uppercase.TSThisType = uppercase.TSTemplateLiteralType = uppercase.TSSymbolKeyword = uppercase.TSStringKeyword = uppercase.TSSatisfiesExpression = uppercase.TSRestType = uppercase.TSQualifiedName = uppercase.TSPropertySignature = uppercase.TSParenthesizedType = uppercase.TSParameterProperty = uppercase.TSOptionalType = uppercase.TSObjectKeyword = void 0;
  var b2 = requireLowercase();
  requireDeprecationWarning();
  function alias(lowercase2) {
    {
      return b2[lowercase2];
    }
  }
  uppercase.ArrayExpression = alias("arrayExpression");
  uppercase.AssignmentExpression = alias("assignmentExpression");
  uppercase.BinaryExpression = alias("binaryExpression");
  uppercase.InterpreterDirective = alias("interpreterDirective");
  uppercase.Directive = alias("directive");
  uppercase.DirectiveLiteral = alias("directiveLiteral");
  uppercase.BlockStatement = alias("blockStatement");
  uppercase.BreakStatement = alias("breakStatement");
  uppercase.CallExpression = alias("callExpression");
  uppercase.CatchClause = alias("catchClause");
  uppercase.ConditionalExpression = alias("conditionalExpression");
  uppercase.ContinueStatement = alias("continueStatement");
  uppercase.DebuggerStatement = alias("debuggerStatement");
  uppercase.DoWhileStatement = alias("doWhileStatement");
  uppercase.EmptyStatement = alias("emptyStatement");
  uppercase.ExpressionStatement = alias("expressionStatement");
  uppercase.File = alias("file");
  uppercase.ForInStatement = alias("forInStatement");
  uppercase.ForStatement = alias("forStatement");
  uppercase.FunctionDeclaration = alias("functionDeclaration");
  uppercase.FunctionExpression = alias("functionExpression");
  uppercase.Identifier = alias("identifier");
  uppercase.IfStatement = alias("ifStatement");
  uppercase.LabeledStatement = alias("labeledStatement");
  uppercase.StringLiteral = alias("stringLiteral");
  uppercase.NumericLiteral = alias("numericLiteral");
  uppercase.NullLiteral = alias("nullLiteral");
  uppercase.BooleanLiteral = alias("booleanLiteral");
  uppercase.RegExpLiteral = alias("regExpLiteral");
  uppercase.LogicalExpression = alias("logicalExpression");
  uppercase.MemberExpression = alias("memberExpression");
  uppercase.NewExpression = alias("newExpression");
  uppercase.Program = alias("program");
  uppercase.ObjectExpression = alias("objectExpression");
  uppercase.ObjectMethod = alias("objectMethod");
  uppercase.ObjectProperty = alias("objectProperty");
  uppercase.RestElement = alias("restElement");
  uppercase.ReturnStatement = alias("returnStatement");
  uppercase.SequenceExpression = alias("sequenceExpression");
  uppercase.ParenthesizedExpression = alias("parenthesizedExpression");
  uppercase.SwitchCase = alias("switchCase");
  uppercase.SwitchStatement = alias("switchStatement");
  uppercase.ThisExpression = alias("thisExpression");
  uppercase.ThrowStatement = alias("throwStatement");
  uppercase.TryStatement = alias("tryStatement");
  uppercase.UnaryExpression = alias("unaryExpression");
  uppercase.UpdateExpression = alias("updateExpression");
  uppercase.VariableDeclaration = alias("variableDeclaration");
  uppercase.VariableDeclarator = alias("variableDeclarator");
  uppercase.WhileStatement = alias("whileStatement");
  uppercase.WithStatement = alias("withStatement");
  uppercase.AssignmentPattern = alias("assignmentPattern");
  uppercase.ArrayPattern = alias("arrayPattern");
  uppercase.ArrowFunctionExpression = alias("arrowFunctionExpression");
  uppercase.ClassBody = alias("classBody");
  uppercase.ClassExpression = alias("classExpression");
  uppercase.ClassDeclaration = alias("classDeclaration");
  uppercase.ExportAllDeclaration = alias("exportAllDeclaration");
  uppercase.ExportDefaultDeclaration = alias("exportDefaultDeclaration");
  uppercase.ExportNamedDeclaration = alias("exportNamedDeclaration");
  uppercase.ExportSpecifier = alias("exportSpecifier");
  uppercase.ForOfStatement = alias("forOfStatement");
  uppercase.ImportDeclaration = alias("importDeclaration");
  uppercase.ImportDefaultSpecifier = alias("importDefaultSpecifier");
  uppercase.ImportNamespaceSpecifier = alias("importNamespaceSpecifier");
  uppercase.ImportSpecifier = alias("importSpecifier");
  uppercase.ImportExpression = alias("importExpression");
  uppercase.MetaProperty = alias("metaProperty");
  uppercase.ClassMethod = alias("classMethod");
  uppercase.ObjectPattern = alias("objectPattern");
  uppercase.SpreadElement = alias("spreadElement");
  uppercase.Super = alias("super");
  uppercase.TaggedTemplateExpression = alias("taggedTemplateExpression");
  uppercase.TemplateElement = alias("templateElement");
  uppercase.TemplateLiteral = alias("templateLiteral");
  uppercase.YieldExpression = alias("yieldExpression");
  uppercase.AwaitExpression = alias("awaitExpression");
  uppercase.Import = alias("import");
  uppercase.BigIntLiteral = alias("bigIntLiteral");
  uppercase.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier");
  uppercase.OptionalMemberExpression = alias("optionalMemberExpression");
  uppercase.OptionalCallExpression = alias("optionalCallExpression");
  uppercase.ClassProperty = alias("classProperty");
  uppercase.ClassAccessorProperty = alias("classAccessorProperty");
  uppercase.ClassPrivateProperty = alias("classPrivateProperty");
  uppercase.ClassPrivateMethod = alias("classPrivateMethod");
  uppercase.PrivateName = alias("privateName");
  uppercase.StaticBlock = alias("staticBlock");
  uppercase.ImportAttribute = alias("importAttribute");
  uppercase.AnyTypeAnnotation = alias("anyTypeAnnotation");
  uppercase.ArrayTypeAnnotation = alias("arrayTypeAnnotation");
  uppercase.BooleanTypeAnnotation = alias("booleanTypeAnnotation");
  uppercase.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation");
  uppercase.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation");
  uppercase.ClassImplements = alias("classImplements");
  uppercase.DeclareClass = alias("declareClass");
  uppercase.DeclareFunction = alias("declareFunction");
  uppercase.DeclareInterface = alias("declareInterface");
  uppercase.DeclareModule = alias("declareModule");
  uppercase.DeclareModuleExports = alias("declareModuleExports");
  uppercase.DeclareTypeAlias = alias("declareTypeAlias");
  uppercase.DeclareOpaqueType = alias("declareOpaqueType");
  uppercase.DeclareVariable = alias("declareVariable");
  uppercase.DeclareExportDeclaration = alias("declareExportDeclaration");
  uppercase.DeclareExportAllDeclaration = alias("declareExportAllDeclaration");
  uppercase.DeclaredPredicate = alias("declaredPredicate");
  uppercase.ExistsTypeAnnotation = alias("existsTypeAnnotation");
  uppercase.FunctionTypeAnnotation = alias("functionTypeAnnotation");
  uppercase.FunctionTypeParam = alias("functionTypeParam");
  uppercase.GenericTypeAnnotation = alias("genericTypeAnnotation");
  uppercase.InferredPredicate = alias("inferredPredicate");
  uppercase.InterfaceExtends = alias("interfaceExtends");
  uppercase.InterfaceDeclaration = alias("interfaceDeclaration");
  uppercase.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation");
  uppercase.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation");
  uppercase.MixedTypeAnnotation = alias("mixedTypeAnnotation");
  uppercase.EmptyTypeAnnotation = alias("emptyTypeAnnotation");
  uppercase.NullableTypeAnnotation = alias("nullableTypeAnnotation");
  uppercase.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation");
  uppercase.NumberTypeAnnotation = alias("numberTypeAnnotation");
  uppercase.ObjectTypeAnnotation = alias("objectTypeAnnotation");
  uppercase.ObjectTypeInternalSlot = alias("objectTypeInternalSlot");
  uppercase.ObjectTypeCallProperty = alias("objectTypeCallProperty");
  uppercase.ObjectTypeIndexer = alias("objectTypeIndexer");
  uppercase.ObjectTypeProperty = alias("objectTypeProperty");
  uppercase.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty");
  uppercase.OpaqueType = alias("opaqueType");
  uppercase.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier");
  uppercase.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation");
  uppercase.StringTypeAnnotation = alias("stringTypeAnnotation");
  uppercase.SymbolTypeAnnotation = alias("symbolTypeAnnotation");
  uppercase.ThisTypeAnnotation = alias("thisTypeAnnotation");
  uppercase.TupleTypeAnnotation = alias("tupleTypeAnnotation");
  uppercase.TypeofTypeAnnotation = alias("typeofTypeAnnotation");
  uppercase.TypeAlias = alias("typeAlias");
  uppercase.TypeAnnotation = alias("typeAnnotation");
  uppercase.TypeCastExpression = alias("typeCastExpression");
  uppercase.TypeParameter = alias("typeParameter");
  uppercase.TypeParameterDeclaration = alias("typeParameterDeclaration");
  uppercase.TypeParameterInstantiation = alias("typeParameterInstantiation");
  uppercase.UnionTypeAnnotation = alias("unionTypeAnnotation");
  uppercase.Variance = alias("variance");
  uppercase.VoidTypeAnnotation = alias("voidTypeAnnotation");
  uppercase.EnumDeclaration = alias("enumDeclaration");
  uppercase.EnumBooleanBody = alias("enumBooleanBody");
  uppercase.EnumNumberBody = alias("enumNumberBody");
  uppercase.EnumStringBody = alias("enumStringBody");
  uppercase.EnumSymbolBody = alias("enumSymbolBody");
  uppercase.EnumBooleanMember = alias("enumBooleanMember");
  uppercase.EnumNumberMember = alias("enumNumberMember");
  uppercase.EnumStringMember = alias("enumStringMember");
  uppercase.EnumDefaultedMember = alias("enumDefaultedMember");
  uppercase.IndexedAccessType = alias("indexedAccessType");
  uppercase.OptionalIndexedAccessType = alias("optionalIndexedAccessType");
  uppercase.JSXAttribute = alias("jsxAttribute");
  uppercase.JSXClosingElement = alias("jsxClosingElement");
  uppercase.JSXElement = alias("jsxElement");
  uppercase.JSXEmptyExpression = alias("jsxEmptyExpression");
  uppercase.JSXExpressionContainer = alias("jsxExpressionContainer");
  uppercase.JSXSpreadChild = alias("jsxSpreadChild");
  uppercase.JSXIdentifier = alias("jsxIdentifier");
  uppercase.JSXMemberExpression = alias("jsxMemberExpression");
  uppercase.JSXNamespacedName = alias("jsxNamespacedName");
  uppercase.JSXOpeningElement = alias("jsxOpeningElement");
  uppercase.JSXSpreadAttribute = alias("jsxSpreadAttribute");
  uppercase.JSXText = alias("jsxText");
  uppercase.JSXFragment = alias("jsxFragment");
  uppercase.JSXOpeningFragment = alias("jsxOpeningFragment");
  uppercase.JSXClosingFragment = alias("jsxClosingFragment");
  uppercase.Noop = alias("noop");
  uppercase.Placeholder = alias("placeholder");
  uppercase.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier");
  uppercase.ArgumentPlaceholder = alias("argumentPlaceholder");
  uppercase.BindExpression = alias("bindExpression");
  uppercase.Decorator = alias("decorator");
  uppercase.DoExpression = alias("doExpression");
  uppercase.ExportDefaultSpecifier = alias("exportDefaultSpecifier");
  uppercase.RecordExpression = alias("recordExpression");
  uppercase.TupleExpression = alias("tupleExpression");
  uppercase.DecimalLiteral = alias("decimalLiteral");
  uppercase.ModuleExpression = alias("moduleExpression");
  uppercase.TopicReference = alias("topicReference");
  uppercase.PipelineTopicExpression = alias("pipelineTopicExpression");
  uppercase.PipelineBareFunction = alias("pipelineBareFunction");
  uppercase.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference");
  uppercase.VoidPattern = alias("voidPattern");
  uppercase.TSParameterProperty = alias("tsParameterProperty");
  uppercase.TSDeclareFunction = alias("tsDeclareFunction");
  uppercase.TSDeclareMethod = alias("tsDeclareMethod");
  uppercase.TSQualifiedName = alias("tsQualifiedName");
  uppercase.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration");
  uppercase.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration");
  uppercase.TSPropertySignature = alias("tsPropertySignature");
  uppercase.TSMethodSignature = alias("tsMethodSignature");
  uppercase.TSIndexSignature = alias("tsIndexSignature");
  uppercase.TSAnyKeyword = alias("tsAnyKeyword");
  uppercase.TSBooleanKeyword = alias("tsBooleanKeyword");
  uppercase.TSBigIntKeyword = alias("tsBigIntKeyword");
  uppercase.TSIntrinsicKeyword = alias("tsIntrinsicKeyword");
  uppercase.TSNeverKeyword = alias("tsNeverKeyword");
  uppercase.TSNullKeyword = alias("tsNullKeyword");
  uppercase.TSNumberKeyword = alias("tsNumberKeyword");
  uppercase.TSObjectKeyword = alias("tsObjectKeyword");
  uppercase.TSStringKeyword = alias("tsStringKeyword");
  uppercase.TSSymbolKeyword = alias("tsSymbolKeyword");
  uppercase.TSUndefinedKeyword = alias("tsUndefinedKeyword");
  uppercase.TSUnknownKeyword = alias("tsUnknownKeyword");
  uppercase.TSVoidKeyword = alias("tsVoidKeyword");
  uppercase.TSThisType = alias("tsThisType");
  uppercase.TSFunctionType = alias("tsFunctionType");
  uppercase.TSConstructorType = alias("tsConstructorType");
  uppercase.TSTypeReference = alias("tsTypeReference");
  uppercase.TSTypePredicate = alias("tsTypePredicate");
  uppercase.TSTypeQuery = alias("tsTypeQuery");
  uppercase.TSTypeLiteral = alias("tsTypeLiteral");
  uppercase.TSArrayType = alias("tsArrayType");
  uppercase.TSTupleType = alias("tsTupleType");
  uppercase.TSOptionalType = alias("tsOptionalType");
  uppercase.TSRestType = alias("tsRestType");
  uppercase.TSNamedTupleMember = alias("tsNamedTupleMember");
  uppercase.TSUnionType = alias("tsUnionType");
  uppercase.TSIntersectionType = alias("tsIntersectionType");
  uppercase.TSConditionalType = alias("tsConditionalType");
  uppercase.TSInferType = alias("tsInferType");
  uppercase.TSParenthesizedType = alias("tsParenthesizedType");
  uppercase.TSTypeOperator = alias("tsTypeOperator");
  uppercase.TSIndexedAccessType = alias("tsIndexedAccessType");
  uppercase.TSMappedType = alias("tsMappedType");
  uppercase.TSTemplateLiteralType = alias("tsTemplateLiteralType");
  uppercase.TSLiteralType = alias("tsLiteralType");
  uppercase.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments");
  uppercase.TSInterfaceDeclaration = alias("tsInterfaceDeclaration");
  uppercase.TSInterfaceBody = alias("tsInterfaceBody");
  uppercase.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration");
  uppercase.TSInstantiationExpression = alias("tsInstantiationExpression");
  uppercase.TSAsExpression = alias("tsAsExpression");
  uppercase.TSSatisfiesExpression = alias("tsSatisfiesExpression");
  uppercase.TSTypeAssertion = alias("tsTypeAssertion");
  uppercase.TSEnumBody = alias("tsEnumBody");
  uppercase.TSEnumDeclaration = alias("tsEnumDeclaration");
  uppercase.TSEnumMember = alias("tsEnumMember");
  uppercase.TSModuleDeclaration = alias("tsModuleDeclaration");
  uppercase.TSModuleBlock = alias("tsModuleBlock");
  uppercase.TSImportType = alias("tsImportType");
  uppercase.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration");
  uppercase.TSExternalModuleReference = alias("tsExternalModuleReference");
  uppercase.TSNonNullExpression = alias("tsNonNullExpression");
  uppercase.TSExportAssignment = alias("tsExportAssignment");
  uppercase.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration");
  uppercase.TSTypeAnnotation = alias("tsTypeAnnotation");
  uppercase.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation");
  uppercase.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration");
  uppercase.TSTypeParameter = alias("tsTypeParameter");
  uppercase.NumberLiteral = b2.numberLiteral;
  uppercase.RegexLiteral = b2.regexLiteral;
  uppercase.RestProperty = b2.restProperty;
  uppercase.SpreadProperty = b2.spreadProperty;
  return uppercase;
}
var hasRequiredGenerated$2;
function requireGenerated$2() {
  if (hasRequiredGenerated$2) return generated$2;
  hasRequiredGenerated$2 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _lowercase = requireLowercase();
    Object.keys(_lowercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _lowercase[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = requireUppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _uppercase[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  })(generated$2);
  return generated$2;
}
var hasRequiredCleanJSXElementLiteralChild;
function requireCleanJSXElementLiteralChild() {
  if (hasRequiredCleanJSXElementLiteralChild) return cleanJSXElementLiteralChild;
  hasRequiredCleanJSXElementLiteralChild = 1;
  Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    value: true
  });
  cleanJSXElementLiteralChild.default = cleanJSXElementLiteralChild$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$5();
  function cleanJSXElementLiteralChild$1(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) {
      if (/[^ \t]/.exec(lines[i])) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^ +/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/ +$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  }
  return cleanJSXElementLiteralChild;
}
var hasRequiredBuildChildren;
function requireBuildChildren() {
  if (hasRequiredBuildChildren) return buildChildren;
  hasRequiredBuildChildren = 1;
  Object.defineProperty(buildChildren, "__esModule", {
    value: true
  });
  buildChildren.default = buildChildren$1;
  var _index = requireGenerated$3();
  var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
  function buildChildren$1(node2) {
    const elements = [];
    for (let i = 0; i < node2.children.length; i++) {
      let child = node2.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }
    return elements;
  }
  return buildChildren;
}
var assertNode = {};
var isNode = {};
var hasRequiredIsNode;
function requireIsNode() {
  if (hasRequiredIsNode) return isNode;
  hasRequiredIsNode = 1;
  Object.defineProperty(isNode, "__esModule", {
    value: true
  });
  isNode.default = isNode$1;
  var _index = requireDefinitions();
  function isNode$1(node2) {
    return !!(node2 && _index.VISITOR_KEYS[node2.type]);
  }
  return isNode;
}
var hasRequiredAssertNode;
function requireAssertNode() {
  if (hasRequiredAssertNode) return assertNode;
  hasRequiredAssertNode = 1;
  Object.defineProperty(assertNode, "__esModule", {
    value: true
  });
  assertNode.default = assertNode$1;
  var _isNode = requireIsNode();
  function assertNode$1(node2) {
    if (!(0, _isNode.default)(node2)) {
      var _node$type;
      const type = (_node$type = node2 == null ? void 0 : node2.type) != null ? _node$type : JSON.stringify(node2);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }
  return assertNode;
}
var generated$1 = {};
var hasRequiredGenerated$1;
function requireGenerated$1() {
  if (hasRequiredGenerated$1) return generated$1;
  hasRequiredGenerated$1 = 1;
  Object.defineProperty(generated$1, "__esModule", {
    value: true
  });
  generated$1.assertAccessor = assertAccessor;
  generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
  generated$1.assertArrayExpression = assertArrayExpression;
  generated$1.assertArrayPattern = assertArrayPattern;
  generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
  generated$1.assertAssignmentExpression = assertAssignmentExpression;
  generated$1.assertAssignmentPattern = assertAssignmentPattern;
  generated$1.assertAwaitExpression = assertAwaitExpression;
  generated$1.assertBigIntLiteral = assertBigIntLiteral;
  generated$1.assertBinary = assertBinary;
  generated$1.assertBinaryExpression = assertBinaryExpression;
  generated$1.assertBindExpression = assertBindExpression;
  generated$1.assertBlock = assertBlock;
  generated$1.assertBlockParent = assertBlockParent;
  generated$1.assertBlockStatement = assertBlockStatement;
  generated$1.assertBooleanLiteral = assertBooleanLiteral;
  generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  generated$1.assertBreakStatement = assertBreakStatement;
  generated$1.assertCallExpression = assertCallExpression;
  generated$1.assertCatchClause = assertCatchClause;
  generated$1.assertClass = assertClass;
  generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
  generated$1.assertClassBody = assertClassBody;
  generated$1.assertClassDeclaration = assertClassDeclaration;
  generated$1.assertClassExpression = assertClassExpression;
  generated$1.assertClassImplements = assertClassImplements;
  generated$1.assertClassMethod = assertClassMethod;
  generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
  generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
  generated$1.assertClassProperty = assertClassProperty;
  generated$1.assertCompletionStatement = assertCompletionStatement;
  generated$1.assertConditional = assertConditional;
  generated$1.assertConditionalExpression = assertConditionalExpression;
  generated$1.assertContinueStatement = assertContinueStatement;
  generated$1.assertDebuggerStatement = assertDebuggerStatement;
  generated$1.assertDecimalLiteral = assertDecimalLiteral;
  generated$1.assertDeclaration = assertDeclaration;
  generated$1.assertDeclareClass = assertDeclareClass;
  generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  generated$1.assertDeclareFunction = assertDeclareFunction;
  generated$1.assertDeclareInterface = assertDeclareInterface;
  generated$1.assertDeclareModule = assertDeclareModule;
  generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
  generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
  generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
  generated$1.assertDeclareVariable = assertDeclareVariable;
  generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
  generated$1.assertDecorator = assertDecorator;
  generated$1.assertDirective = assertDirective;
  generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
  generated$1.assertDoExpression = assertDoExpression;
  generated$1.assertDoWhileStatement = assertDoWhileStatement;
  generated$1.assertEmptyStatement = assertEmptyStatement;
  generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  generated$1.assertEnumBody = assertEnumBody;
  generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
  generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
  generated$1.assertEnumDeclaration = assertEnumDeclaration;
  generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
  generated$1.assertEnumMember = assertEnumMember;
  generated$1.assertEnumNumberBody = assertEnumNumberBody;
  generated$1.assertEnumNumberMember = assertEnumNumberMember;
  generated$1.assertEnumStringBody = assertEnumStringBody;
  generated$1.assertEnumStringMember = assertEnumStringMember;
  generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
  generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
  generated$1.assertExportDeclaration = assertExportDeclaration;
  generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
  generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  generated$1.assertExportSpecifier = assertExportSpecifier;
  generated$1.assertExpression = assertExpression;
  generated$1.assertExpressionStatement = assertExpressionStatement;
  generated$1.assertExpressionWrapper = assertExpressionWrapper;
  generated$1.assertFile = assertFile;
  generated$1.assertFlow = assertFlow;
  generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  generated$1.assertFlowDeclaration = assertFlowDeclaration;
  generated$1.assertFlowPredicate = assertFlowPredicate;
  generated$1.assertFlowType = assertFlowType;
  generated$1.assertFor = assertFor;
  generated$1.assertForInStatement = assertForInStatement;
  generated$1.assertForOfStatement = assertForOfStatement;
  generated$1.assertForStatement = assertForStatement;
  generated$1.assertForXStatement = assertForXStatement;
  generated$1.assertFunction = assertFunction;
  generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
  generated$1.assertFunctionExpression = assertFunctionExpression;
  generated$1.assertFunctionParameter = assertFunctionParameter;
  generated$1.assertFunctionParent = assertFunctionParent;
  generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
  generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  generated$1.assertIdentifier = assertIdentifier;
  generated$1.assertIfStatement = assertIfStatement;
  generated$1.assertImmutable = assertImmutable;
  generated$1.assertImport = assertImport;
  generated$1.assertImportAttribute = assertImportAttribute;
  generated$1.assertImportDeclaration = assertImportDeclaration;
  generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  generated$1.assertImportExpression = assertImportExpression;
  generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  generated$1.assertImportSpecifier = assertImportSpecifier;
  generated$1.assertIndexedAccessType = assertIndexedAccessType;
  generated$1.assertInferredPredicate = assertInferredPredicate;
  generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
  generated$1.assertInterfaceExtends = assertInterfaceExtends;
  generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  generated$1.assertInterpreterDirective = assertInterpreterDirective;
  generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  generated$1.assertJSX = assertJSX;
  generated$1.assertJSXAttribute = assertJSXAttribute;
  generated$1.assertJSXClosingElement = assertJSXClosingElement;
  generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
  generated$1.assertJSXElement = assertJSXElement;
  generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
  generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
  generated$1.assertJSXFragment = assertJSXFragment;
  generated$1.assertJSXIdentifier = assertJSXIdentifier;
  generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
  generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
  generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
  generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
  generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
  generated$1.assertJSXText = assertJSXText;
  generated$1.assertLVal = assertLVal;
  generated$1.assertLabeledStatement = assertLabeledStatement;
  generated$1.assertLiteral = assertLiteral;
  generated$1.assertLogicalExpression = assertLogicalExpression;
  generated$1.assertLoop = assertLoop;
  generated$1.assertMemberExpression = assertMemberExpression;
  generated$1.assertMetaProperty = assertMetaProperty;
  generated$1.assertMethod = assertMethod;
  generated$1.assertMiscellaneous = assertMiscellaneous;
  generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  generated$1.assertModuleDeclaration = assertModuleDeclaration;
  generated$1.assertModuleExpression = assertModuleExpression;
  generated$1.assertModuleSpecifier = assertModuleSpecifier;
  generated$1.assertNewExpression = assertNewExpression;
  generated$1.assertNoop = assertNoop;
  generated$1.assertNullLiteral = assertNullLiteral;
  generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  generated$1.assertNumberLiteral = assertNumberLiteral;
  generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  generated$1.assertNumericLiteral = assertNumericLiteral;
  generated$1.assertObjectExpression = assertObjectExpression;
  generated$1.assertObjectMember = assertObjectMember;
  generated$1.assertObjectMethod = assertObjectMethod;
  generated$1.assertObjectPattern = assertObjectPattern;
  generated$1.assertObjectProperty = assertObjectProperty;
  generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
  generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
  generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  generated$1.assertOpaqueType = assertOpaqueType;
  generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
  generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
  generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
  generated$1.assertPattern = assertPattern;
  generated$1.assertPatternLike = assertPatternLike;
  generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
  generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
  generated$1.assertPlaceholder = assertPlaceholder;
  generated$1.assertPrivate = assertPrivate;
  generated$1.assertPrivateName = assertPrivateName;
  generated$1.assertProgram = assertProgram;
  generated$1.assertProperty = assertProperty;
  generated$1.assertPureish = assertPureish;
  generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  generated$1.assertRecordExpression = assertRecordExpression;
  generated$1.assertRegExpLiteral = assertRegExpLiteral;
  generated$1.assertRegexLiteral = assertRegexLiteral;
  generated$1.assertRestElement = assertRestElement;
  generated$1.assertRestProperty = assertRestProperty;
  generated$1.assertReturnStatement = assertReturnStatement;
  generated$1.assertScopable = assertScopable;
  generated$1.assertSequenceExpression = assertSequenceExpression;
  generated$1.assertSpreadElement = assertSpreadElement;
  generated$1.assertSpreadProperty = assertSpreadProperty;
  generated$1.assertStandardized = assertStandardized;
  generated$1.assertStatement = assertStatement;
  generated$1.assertStaticBlock = assertStaticBlock;
  generated$1.assertStringLiteral = assertStringLiteral;
  generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
  generated$1.assertSuper = assertSuper;
  generated$1.assertSwitchCase = assertSwitchCase;
  generated$1.assertSwitchStatement = assertSwitchStatement;
  generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
  generated$1.assertTSArrayType = assertTSArrayType;
  generated$1.assertTSAsExpression = assertTSAsExpression;
  generated$1.assertTSBaseType = assertTSBaseType;
  generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
  generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
  generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  generated$1.assertTSConditionalType = assertTSConditionalType;
  generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  generated$1.assertTSConstructorType = assertTSConstructorType;
  generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
  generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
  generated$1.assertTSEntityName = assertTSEntityName;
  generated$1.assertTSEnumBody = assertTSEnumBody;
  generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
  generated$1.assertTSEnumMember = assertTSEnumMember;
  generated$1.assertTSExportAssignment = assertTSExportAssignment;
  generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
  generated$1.assertTSFunctionType = assertTSFunctionType;
  generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  generated$1.assertTSImportType = assertTSImportType;
  generated$1.assertTSIndexSignature = assertTSIndexSignature;
  generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
  generated$1.assertTSInferType = assertTSInferType;
  generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
  generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
  generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  generated$1.assertTSIntersectionType = assertTSIntersectionType;
  generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  generated$1.assertTSLiteralType = assertTSLiteralType;
  generated$1.assertTSMappedType = assertTSMappedType;
  generated$1.assertTSMethodSignature = assertTSMethodSignature;
  generated$1.assertTSModuleBlock = assertTSModuleBlock;
  generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
  generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
  generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
  generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
  generated$1.assertTSNullKeyword = assertTSNullKeyword;
  generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
  generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
  generated$1.assertTSOptionalType = assertTSOptionalType;
  generated$1.assertTSParameterProperty = assertTSParameterProperty;
  generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
  generated$1.assertTSPropertySignature = assertTSPropertySignature;
  generated$1.assertTSQualifiedName = assertTSQualifiedName;
  generated$1.assertTSRestType = assertTSRestType;
  generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  generated$1.assertTSStringKeyword = assertTSStringKeyword;
  generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
  generated$1.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
  generated$1.assertTSThisType = assertTSThisType;
  generated$1.assertTSTupleType = assertTSTupleType;
  generated$1.assertTSType = assertTSType;
  generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
  generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
  generated$1.assertTSTypeElement = assertTSTypeElement;
  generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
  generated$1.assertTSTypeOperator = assertTSTypeOperator;
  generated$1.assertTSTypeParameter = assertTSTypeParameter;
  generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  generated$1.assertTSTypePredicate = assertTSTypePredicate;
  generated$1.assertTSTypeQuery = assertTSTypeQuery;
  generated$1.assertTSTypeReference = assertTSTypeReference;
  generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  generated$1.assertTSUnionType = assertTSUnionType;
  generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
  generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
  generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  generated$1.assertTemplateElement = assertTemplateElement;
  generated$1.assertTemplateLiteral = assertTemplateLiteral;
  generated$1.assertTerminatorless = assertTerminatorless;
  generated$1.assertThisExpression = assertThisExpression;
  generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
  generated$1.assertThrowStatement = assertThrowStatement;
  generated$1.assertTopicReference = assertTopicReference;
  generated$1.assertTryStatement = assertTryStatement;
  generated$1.assertTupleExpression = assertTupleExpression;
  generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  generated$1.assertTypeAlias = assertTypeAlias;
  generated$1.assertTypeAnnotation = assertTypeAnnotation;
  generated$1.assertTypeCastExpression = assertTypeCastExpression;
  generated$1.assertTypeParameter = assertTypeParameter;
  generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  generated$1.assertTypeScript = assertTypeScript;
  generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  generated$1.assertUnaryExpression = assertUnaryExpression;
  generated$1.assertUnaryLike = assertUnaryLike;
  generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  generated$1.assertUpdateExpression = assertUpdateExpression;
  generated$1.assertUserWhitespacable = assertUserWhitespacable;
  generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  generated$1.assertVariableDeclaration = assertVariableDeclaration;
  generated$1.assertVariableDeclarator = assertVariableDeclarator;
  generated$1.assertVariance = assertVariance;
  generated$1.assertVoidPattern = assertVoidPattern;
  generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  generated$1.assertWhile = assertWhile;
  generated$1.assertWhileStatement = assertWhileStatement;
  generated$1.assertWithStatement = assertWithStatement;
  generated$1.assertYieldExpression = assertYieldExpression;
  var _is = requireIs();
  var _deprecationWarning = requireDeprecationWarning();
  function assert2(type, node2, opts) {
    if (!(0, _is.default)(type, node2, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node2.type}".`);
    }
  }
  function assertArrayExpression(node2, opts) {
    assert2("ArrayExpression", node2, opts);
  }
  function assertAssignmentExpression(node2, opts) {
    assert2("AssignmentExpression", node2, opts);
  }
  function assertBinaryExpression(node2, opts) {
    assert2("BinaryExpression", node2, opts);
  }
  function assertInterpreterDirective(node2, opts) {
    assert2("InterpreterDirective", node2, opts);
  }
  function assertDirective(node2, opts) {
    assert2("Directive", node2, opts);
  }
  function assertDirectiveLiteral(node2, opts) {
    assert2("DirectiveLiteral", node2, opts);
  }
  function assertBlockStatement(node2, opts) {
    assert2("BlockStatement", node2, opts);
  }
  function assertBreakStatement(node2, opts) {
    assert2("BreakStatement", node2, opts);
  }
  function assertCallExpression(node2, opts) {
    assert2("CallExpression", node2, opts);
  }
  function assertCatchClause(node2, opts) {
    assert2("CatchClause", node2, opts);
  }
  function assertConditionalExpression(node2, opts) {
    assert2("ConditionalExpression", node2, opts);
  }
  function assertContinueStatement(node2, opts) {
    assert2("ContinueStatement", node2, opts);
  }
  function assertDebuggerStatement(node2, opts) {
    assert2("DebuggerStatement", node2, opts);
  }
  function assertDoWhileStatement(node2, opts) {
    assert2("DoWhileStatement", node2, opts);
  }
  function assertEmptyStatement(node2, opts) {
    assert2("EmptyStatement", node2, opts);
  }
  function assertExpressionStatement(node2, opts) {
    assert2("ExpressionStatement", node2, opts);
  }
  function assertFile(node2, opts) {
    assert2("File", node2, opts);
  }
  function assertForInStatement(node2, opts) {
    assert2("ForInStatement", node2, opts);
  }
  function assertForStatement(node2, opts) {
    assert2("ForStatement", node2, opts);
  }
  function assertFunctionDeclaration(node2, opts) {
    assert2("FunctionDeclaration", node2, opts);
  }
  function assertFunctionExpression(node2, opts) {
    assert2("FunctionExpression", node2, opts);
  }
  function assertIdentifier(node2, opts) {
    assert2("Identifier", node2, opts);
  }
  function assertIfStatement(node2, opts) {
    assert2("IfStatement", node2, opts);
  }
  function assertLabeledStatement(node2, opts) {
    assert2("LabeledStatement", node2, opts);
  }
  function assertStringLiteral(node2, opts) {
    assert2("StringLiteral", node2, opts);
  }
  function assertNumericLiteral(node2, opts) {
    assert2("NumericLiteral", node2, opts);
  }
  function assertNullLiteral(node2, opts) {
    assert2("NullLiteral", node2, opts);
  }
  function assertBooleanLiteral(node2, opts) {
    assert2("BooleanLiteral", node2, opts);
  }
  function assertRegExpLiteral(node2, opts) {
    assert2("RegExpLiteral", node2, opts);
  }
  function assertLogicalExpression(node2, opts) {
    assert2("LogicalExpression", node2, opts);
  }
  function assertMemberExpression(node2, opts) {
    assert2("MemberExpression", node2, opts);
  }
  function assertNewExpression(node2, opts) {
    assert2("NewExpression", node2, opts);
  }
  function assertProgram(node2, opts) {
    assert2("Program", node2, opts);
  }
  function assertObjectExpression(node2, opts) {
    assert2("ObjectExpression", node2, opts);
  }
  function assertObjectMethod(node2, opts) {
    assert2("ObjectMethod", node2, opts);
  }
  function assertObjectProperty(node2, opts) {
    assert2("ObjectProperty", node2, opts);
  }
  function assertRestElement(node2, opts) {
    assert2("RestElement", node2, opts);
  }
  function assertReturnStatement(node2, opts) {
    assert2("ReturnStatement", node2, opts);
  }
  function assertSequenceExpression(node2, opts) {
    assert2("SequenceExpression", node2, opts);
  }
  function assertParenthesizedExpression(node2, opts) {
    assert2("ParenthesizedExpression", node2, opts);
  }
  function assertSwitchCase(node2, opts) {
    assert2("SwitchCase", node2, opts);
  }
  function assertSwitchStatement(node2, opts) {
    assert2("SwitchStatement", node2, opts);
  }
  function assertThisExpression(node2, opts) {
    assert2("ThisExpression", node2, opts);
  }
  function assertThrowStatement(node2, opts) {
    assert2("ThrowStatement", node2, opts);
  }
  function assertTryStatement(node2, opts) {
    assert2("TryStatement", node2, opts);
  }
  function assertUnaryExpression(node2, opts) {
    assert2("UnaryExpression", node2, opts);
  }
  function assertUpdateExpression(node2, opts) {
    assert2("UpdateExpression", node2, opts);
  }
  function assertVariableDeclaration(node2, opts) {
    assert2("VariableDeclaration", node2, opts);
  }
  function assertVariableDeclarator(node2, opts) {
    assert2("VariableDeclarator", node2, opts);
  }
  function assertWhileStatement(node2, opts) {
    assert2("WhileStatement", node2, opts);
  }
  function assertWithStatement(node2, opts) {
    assert2("WithStatement", node2, opts);
  }
  function assertAssignmentPattern(node2, opts) {
    assert2("AssignmentPattern", node2, opts);
  }
  function assertArrayPattern(node2, opts) {
    assert2("ArrayPattern", node2, opts);
  }
  function assertArrowFunctionExpression(node2, opts) {
    assert2("ArrowFunctionExpression", node2, opts);
  }
  function assertClassBody(node2, opts) {
    assert2("ClassBody", node2, opts);
  }
  function assertClassExpression(node2, opts) {
    assert2("ClassExpression", node2, opts);
  }
  function assertClassDeclaration(node2, opts) {
    assert2("ClassDeclaration", node2, opts);
  }
  function assertExportAllDeclaration(node2, opts) {
    assert2("ExportAllDeclaration", node2, opts);
  }
  function assertExportDefaultDeclaration(node2, opts) {
    assert2("ExportDefaultDeclaration", node2, opts);
  }
  function assertExportNamedDeclaration(node2, opts) {
    assert2("ExportNamedDeclaration", node2, opts);
  }
  function assertExportSpecifier(node2, opts) {
    assert2("ExportSpecifier", node2, opts);
  }
  function assertForOfStatement(node2, opts) {
    assert2("ForOfStatement", node2, opts);
  }
  function assertImportDeclaration(node2, opts) {
    assert2("ImportDeclaration", node2, opts);
  }
  function assertImportDefaultSpecifier(node2, opts) {
    assert2("ImportDefaultSpecifier", node2, opts);
  }
  function assertImportNamespaceSpecifier(node2, opts) {
    assert2("ImportNamespaceSpecifier", node2, opts);
  }
  function assertImportSpecifier(node2, opts) {
    assert2("ImportSpecifier", node2, opts);
  }
  function assertImportExpression(node2, opts) {
    assert2("ImportExpression", node2, opts);
  }
  function assertMetaProperty(node2, opts) {
    assert2("MetaProperty", node2, opts);
  }
  function assertClassMethod(node2, opts) {
    assert2("ClassMethod", node2, opts);
  }
  function assertObjectPattern(node2, opts) {
    assert2("ObjectPattern", node2, opts);
  }
  function assertSpreadElement(node2, opts) {
    assert2("SpreadElement", node2, opts);
  }
  function assertSuper(node2, opts) {
    assert2("Super", node2, opts);
  }
  function assertTaggedTemplateExpression(node2, opts) {
    assert2("TaggedTemplateExpression", node2, opts);
  }
  function assertTemplateElement(node2, opts) {
    assert2("TemplateElement", node2, opts);
  }
  function assertTemplateLiteral(node2, opts) {
    assert2("TemplateLiteral", node2, opts);
  }
  function assertYieldExpression(node2, opts) {
    assert2("YieldExpression", node2, opts);
  }
  function assertAwaitExpression(node2, opts) {
    assert2("AwaitExpression", node2, opts);
  }
  function assertImport(node2, opts) {
    assert2("Import", node2, opts);
  }
  function assertBigIntLiteral(node2, opts) {
    assert2("BigIntLiteral", node2, opts);
  }
  function assertExportNamespaceSpecifier(node2, opts) {
    assert2("ExportNamespaceSpecifier", node2, opts);
  }
  function assertOptionalMemberExpression(node2, opts) {
    assert2("OptionalMemberExpression", node2, opts);
  }
  function assertOptionalCallExpression(node2, opts) {
    assert2("OptionalCallExpression", node2, opts);
  }
  function assertClassProperty(node2, opts) {
    assert2("ClassProperty", node2, opts);
  }
  function assertClassAccessorProperty(node2, opts) {
    assert2("ClassAccessorProperty", node2, opts);
  }
  function assertClassPrivateProperty(node2, opts) {
    assert2("ClassPrivateProperty", node2, opts);
  }
  function assertClassPrivateMethod(node2, opts) {
    assert2("ClassPrivateMethod", node2, opts);
  }
  function assertPrivateName(node2, opts) {
    assert2("PrivateName", node2, opts);
  }
  function assertStaticBlock(node2, opts) {
    assert2("StaticBlock", node2, opts);
  }
  function assertImportAttribute(node2, opts) {
    assert2("ImportAttribute", node2, opts);
  }
  function assertAnyTypeAnnotation(node2, opts) {
    assert2("AnyTypeAnnotation", node2, opts);
  }
  function assertArrayTypeAnnotation(node2, opts) {
    assert2("ArrayTypeAnnotation", node2, opts);
  }
  function assertBooleanTypeAnnotation(node2, opts) {
    assert2("BooleanTypeAnnotation", node2, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node2, opts) {
    assert2("BooleanLiteralTypeAnnotation", node2, opts);
  }
  function assertNullLiteralTypeAnnotation(node2, opts) {
    assert2("NullLiteralTypeAnnotation", node2, opts);
  }
  function assertClassImplements(node2, opts) {
    assert2("ClassImplements", node2, opts);
  }
  function assertDeclareClass(node2, opts) {
    assert2("DeclareClass", node2, opts);
  }
  function assertDeclareFunction(node2, opts) {
    assert2("DeclareFunction", node2, opts);
  }
  function assertDeclareInterface(node2, opts) {
    assert2("DeclareInterface", node2, opts);
  }
  function assertDeclareModule(node2, opts) {
    assert2("DeclareModule", node2, opts);
  }
  function assertDeclareModuleExports(node2, opts) {
    assert2("DeclareModuleExports", node2, opts);
  }
  function assertDeclareTypeAlias(node2, opts) {
    assert2("DeclareTypeAlias", node2, opts);
  }
  function assertDeclareOpaqueType(node2, opts) {
    assert2("DeclareOpaqueType", node2, opts);
  }
  function assertDeclareVariable(node2, opts) {
    assert2("DeclareVariable", node2, opts);
  }
  function assertDeclareExportDeclaration(node2, opts) {
    assert2("DeclareExportDeclaration", node2, opts);
  }
  function assertDeclareExportAllDeclaration(node2, opts) {
    assert2("DeclareExportAllDeclaration", node2, opts);
  }
  function assertDeclaredPredicate(node2, opts) {
    assert2("DeclaredPredicate", node2, opts);
  }
  function assertExistsTypeAnnotation(node2, opts) {
    assert2("ExistsTypeAnnotation", node2, opts);
  }
  function assertFunctionTypeAnnotation(node2, opts) {
    assert2("FunctionTypeAnnotation", node2, opts);
  }
  function assertFunctionTypeParam(node2, opts) {
    assert2("FunctionTypeParam", node2, opts);
  }
  function assertGenericTypeAnnotation(node2, opts) {
    assert2("GenericTypeAnnotation", node2, opts);
  }
  function assertInferredPredicate(node2, opts) {
    assert2("InferredPredicate", node2, opts);
  }
  function assertInterfaceExtends(node2, opts) {
    assert2("InterfaceExtends", node2, opts);
  }
  function assertInterfaceDeclaration(node2, opts) {
    assert2("InterfaceDeclaration", node2, opts);
  }
  function assertInterfaceTypeAnnotation(node2, opts) {
    assert2("InterfaceTypeAnnotation", node2, opts);
  }
  function assertIntersectionTypeAnnotation(node2, opts) {
    assert2("IntersectionTypeAnnotation", node2, opts);
  }
  function assertMixedTypeAnnotation(node2, opts) {
    assert2("MixedTypeAnnotation", node2, opts);
  }
  function assertEmptyTypeAnnotation(node2, opts) {
    assert2("EmptyTypeAnnotation", node2, opts);
  }
  function assertNullableTypeAnnotation(node2, opts) {
    assert2("NullableTypeAnnotation", node2, opts);
  }
  function assertNumberLiteralTypeAnnotation(node2, opts) {
    assert2("NumberLiteralTypeAnnotation", node2, opts);
  }
  function assertNumberTypeAnnotation(node2, opts) {
    assert2("NumberTypeAnnotation", node2, opts);
  }
  function assertObjectTypeAnnotation(node2, opts) {
    assert2("ObjectTypeAnnotation", node2, opts);
  }
  function assertObjectTypeInternalSlot(node2, opts) {
    assert2("ObjectTypeInternalSlot", node2, opts);
  }
  function assertObjectTypeCallProperty(node2, opts) {
    assert2("ObjectTypeCallProperty", node2, opts);
  }
  function assertObjectTypeIndexer(node2, opts) {
    assert2("ObjectTypeIndexer", node2, opts);
  }
  function assertObjectTypeProperty(node2, opts) {
    assert2("ObjectTypeProperty", node2, opts);
  }
  function assertObjectTypeSpreadProperty(node2, opts) {
    assert2("ObjectTypeSpreadProperty", node2, opts);
  }
  function assertOpaqueType(node2, opts) {
    assert2("OpaqueType", node2, opts);
  }
  function assertQualifiedTypeIdentifier(node2, opts) {
    assert2("QualifiedTypeIdentifier", node2, opts);
  }
  function assertStringLiteralTypeAnnotation(node2, opts) {
    assert2("StringLiteralTypeAnnotation", node2, opts);
  }
  function assertStringTypeAnnotation(node2, opts) {
    assert2("StringTypeAnnotation", node2, opts);
  }
  function assertSymbolTypeAnnotation(node2, opts) {
    assert2("SymbolTypeAnnotation", node2, opts);
  }
  function assertThisTypeAnnotation(node2, opts) {
    assert2("ThisTypeAnnotation", node2, opts);
  }
  function assertTupleTypeAnnotation(node2, opts) {
    assert2("TupleTypeAnnotation", node2, opts);
  }
  function assertTypeofTypeAnnotation(node2, opts) {
    assert2("TypeofTypeAnnotation", node2, opts);
  }
  function assertTypeAlias(node2, opts) {
    assert2("TypeAlias", node2, opts);
  }
  function assertTypeAnnotation(node2, opts) {
    assert2("TypeAnnotation", node2, opts);
  }
  function assertTypeCastExpression(node2, opts) {
    assert2("TypeCastExpression", node2, opts);
  }
  function assertTypeParameter(node2, opts) {
    assert2("TypeParameter", node2, opts);
  }
  function assertTypeParameterDeclaration(node2, opts) {
    assert2("TypeParameterDeclaration", node2, opts);
  }
  function assertTypeParameterInstantiation(node2, opts) {
    assert2("TypeParameterInstantiation", node2, opts);
  }
  function assertUnionTypeAnnotation(node2, opts) {
    assert2("UnionTypeAnnotation", node2, opts);
  }
  function assertVariance(node2, opts) {
    assert2("Variance", node2, opts);
  }
  function assertVoidTypeAnnotation(node2, opts) {
    assert2("VoidTypeAnnotation", node2, opts);
  }
  function assertEnumDeclaration(node2, opts) {
    assert2("EnumDeclaration", node2, opts);
  }
  function assertEnumBooleanBody(node2, opts) {
    assert2("EnumBooleanBody", node2, opts);
  }
  function assertEnumNumberBody(node2, opts) {
    assert2("EnumNumberBody", node2, opts);
  }
  function assertEnumStringBody(node2, opts) {
    assert2("EnumStringBody", node2, opts);
  }
  function assertEnumSymbolBody(node2, opts) {
    assert2("EnumSymbolBody", node2, opts);
  }
  function assertEnumBooleanMember(node2, opts) {
    assert2("EnumBooleanMember", node2, opts);
  }
  function assertEnumNumberMember(node2, opts) {
    assert2("EnumNumberMember", node2, opts);
  }
  function assertEnumStringMember(node2, opts) {
    assert2("EnumStringMember", node2, opts);
  }
  function assertEnumDefaultedMember(node2, opts) {
    assert2("EnumDefaultedMember", node2, opts);
  }
  function assertIndexedAccessType(node2, opts) {
    assert2("IndexedAccessType", node2, opts);
  }
  function assertOptionalIndexedAccessType(node2, opts) {
    assert2("OptionalIndexedAccessType", node2, opts);
  }
  function assertJSXAttribute(node2, opts) {
    assert2("JSXAttribute", node2, opts);
  }
  function assertJSXClosingElement(node2, opts) {
    assert2("JSXClosingElement", node2, opts);
  }
  function assertJSXElement(node2, opts) {
    assert2("JSXElement", node2, opts);
  }
  function assertJSXEmptyExpression(node2, opts) {
    assert2("JSXEmptyExpression", node2, opts);
  }
  function assertJSXExpressionContainer(node2, opts) {
    assert2("JSXExpressionContainer", node2, opts);
  }
  function assertJSXSpreadChild(node2, opts) {
    assert2("JSXSpreadChild", node2, opts);
  }
  function assertJSXIdentifier(node2, opts) {
    assert2("JSXIdentifier", node2, opts);
  }
  function assertJSXMemberExpression(node2, opts) {
    assert2("JSXMemberExpression", node2, opts);
  }
  function assertJSXNamespacedName(node2, opts) {
    assert2("JSXNamespacedName", node2, opts);
  }
  function assertJSXOpeningElement(node2, opts) {
    assert2("JSXOpeningElement", node2, opts);
  }
  function assertJSXSpreadAttribute(node2, opts) {
    assert2("JSXSpreadAttribute", node2, opts);
  }
  function assertJSXText(node2, opts) {
    assert2("JSXText", node2, opts);
  }
  function assertJSXFragment(node2, opts) {
    assert2("JSXFragment", node2, opts);
  }
  function assertJSXOpeningFragment(node2, opts) {
    assert2("JSXOpeningFragment", node2, opts);
  }
  function assertJSXClosingFragment(node2, opts) {
    assert2("JSXClosingFragment", node2, opts);
  }
  function assertNoop(node2, opts) {
    assert2("Noop", node2, opts);
  }
  function assertPlaceholder(node2, opts) {
    assert2("Placeholder", node2, opts);
  }
  function assertV8IntrinsicIdentifier(node2, opts) {
    assert2("V8IntrinsicIdentifier", node2, opts);
  }
  function assertArgumentPlaceholder(node2, opts) {
    assert2("ArgumentPlaceholder", node2, opts);
  }
  function assertBindExpression(node2, opts) {
    assert2("BindExpression", node2, opts);
  }
  function assertDecorator(node2, opts) {
    assert2("Decorator", node2, opts);
  }
  function assertDoExpression(node2, opts) {
    assert2("DoExpression", node2, opts);
  }
  function assertExportDefaultSpecifier(node2, opts) {
    assert2("ExportDefaultSpecifier", node2, opts);
  }
  function assertRecordExpression(node2, opts) {
    assert2("RecordExpression", node2, opts);
  }
  function assertTupleExpression(node2, opts) {
    assert2("TupleExpression", node2, opts);
  }
  function assertDecimalLiteral(node2, opts) {
    assert2("DecimalLiteral", node2, opts);
  }
  function assertModuleExpression(node2, opts) {
    assert2("ModuleExpression", node2, opts);
  }
  function assertTopicReference(node2, opts) {
    assert2("TopicReference", node2, opts);
  }
  function assertPipelineTopicExpression(node2, opts) {
    assert2("PipelineTopicExpression", node2, opts);
  }
  function assertPipelineBareFunction(node2, opts) {
    assert2("PipelineBareFunction", node2, opts);
  }
  function assertPipelinePrimaryTopicReference(node2, opts) {
    assert2("PipelinePrimaryTopicReference", node2, opts);
  }
  function assertVoidPattern(node2, opts) {
    assert2("VoidPattern", node2, opts);
  }
  function assertTSParameterProperty(node2, opts) {
    assert2("TSParameterProperty", node2, opts);
  }
  function assertTSDeclareFunction(node2, opts) {
    assert2("TSDeclareFunction", node2, opts);
  }
  function assertTSDeclareMethod(node2, opts) {
    assert2("TSDeclareMethod", node2, opts);
  }
  function assertTSQualifiedName(node2, opts) {
    assert2("TSQualifiedName", node2, opts);
  }
  function assertTSCallSignatureDeclaration(node2, opts) {
    assert2("TSCallSignatureDeclaration", node2, opts);
  }
  function assertTSConstructSignatureDeclaration(node2, opts) {
    assert2("TSConstructSignatureDeclaration", node2, opts);
  }
  function assertTSPropertySignature(node2, opts) {
    assert2("TSPropertySignature", node2, opts);
  }
  function assertTSMethodSignature(node2, opts) {
    assert2("TSMethodSignature", node2, opts);
  }
  function assertTSIndexSignature(node2, opts) {
    assert2("TSIndexSignature", node2, opts);
  }
  function assertTSAnyKeyword(node2, opts) {
    assert2("TSAnyKeyword", node2, opts);
  }
  function assertTSBooleanKeyword(node2, opts) {
    assert2("TSBooleanKeyword", node2, opts);
  }
  function assertTSBigIntKeyword(node2, opts) {
    assert2("TSBigIntKeyword", node2, opts);
  }
  function assertTSIntrinsicKeyword(node2, opts) {
    assert2("TSIntrinsicKeyword", node2, opts);
  }
  function assertTSNeverKeyword(node2, opts) {
    assert2("TSNeverKeyword", node2, opts);
  }
  function assertTSNullKeyword(node2, opts) {
    assert2("TSNullKeyword", node2, opts);
  }
  function assertTSNumberKeyword(node2, opts) {
    assert2("TSNumberKeyword", node2, opts);
  }
  function assertTSObjectKeyword(node2, opts) {
    assert2("TSObjectKeyword", node2, opts);
  }
  function assertTSStringKeyword(node2, opts) {
    assert2("TSStringKeyword", node2, opts);
  }
  function assertTSSymbolKeyword(node2, opts) {
    assert2("TSSymbolKeyword", node2, opts);
  }
  function assertTSUndefinedKeyword(node2, opts) {
    assert2("TSUndefinedKeyword", node2, opts);
  }
  function assertTSUnknownKeyword(node2, opts) {
    assert2("TSUnknownKeyword", node2, opts);
  }
  function assertTSVoidKeyword(node2, opts) {
    assert2("TSVoidKeyword", node2, opts);
  }
  function assertTSThisType(node2, opts) {
    assert2("TSThisType", node2, opts);
  }
  function assertTSFunctionType(node2, opts) {
    assert2("TSFunctionType", node2, opts);
  }
  function assertTSConstructorType(node2, opts) {
    assert2("TSConstructorType", node2, opts);
  }
  function assertTSTypeReference(node2, opts) {
    assert2("TSTypeReference", node2, opts);
  }
  function assertTSTypePredicate(node2, opts) {
    assert2("TSTypePredicate", node2, opts);
  }
  function assertTSTypeQuery(node2, opts) {
    assert2("TSTypeQuery", node2, opts);
  }
  function assertTSTypeLiteral(node2, opts) {
    assert2("TSTypeLiteral", node2, opts);
  }
  function assertTSArrayType(node2, opts) {
    assert2("TSArrayType", node2, opts);
  }
  function assertTSTupleType(node2, opts) {
    assert2("TSTupleType", node2, opts);
  }
  function assertTSOptionalType(node2, opts) {
    assert2("TSOptionalType", node2, opts);
  }
  function assertTSRestType(node2, opts) {
    assert2("TSRestType", node2, opts);
  }
  function assertTSNamedTupleMember(node2, opts) {
    assert2("TSNamedTupleMember", node2, opts);
  }
  function assertTSUnionType(node2, opts) {
    assert2("TSUnionType", node2, opts);
  }
  function assertTSIntersectionType(node2, opts) {
    assert2("TSIntersectionType", node2, opts);
  }
  function assertTSConditionalType(node2, opts) {
    assert2("TSConditionalType", node2, opts);
  }
  function assertTSInferType(node2, opts) {
    assert2("TSInferType", node2, opts);
  }
  function assertTSParenthesizedType(node2, opts) {
    assert2("TSParenthesizedType", node2, opts);
  }
  function assertTSTypeOperator(node2, opts) {
    assert2("TSTypeOperator", node2, opts);
  }
  function assertTSIndexedAccessType(node2, opts) {
    assert2("TSIndexedAccessType", node2, opts);
  }
  function assertTSMappedType(node2, opts) {
    assert2("TSMappedType", node2, opts);
  }
  function assertTSTemplateLiteralType(node2, opts) {
    assert2("TSTemplateLiteralType", node2, opts);
  }
  function assertTSLiteralType(node2, opts) {
    assert2("TSLiteralType", node2, opts);
  }
  function assertTSExpressionWithTypeArguments(node2, opts) {
    assert2("TSExpressionWithTypeArguments", node2, opts);
  }
  function assertTSInterfaceDeclaration(node2, opts) {
    assert2("TSInterfaceDeclaration", node2, opts);
  }
  function assertTSInterfaceBody(node2, opts) {
    assert2("TSInterfaceBody", node2, opts);
  }
  function assertTSTypeAliasDeclaration(node2, opts) {
    assert2("TSTypeAliasDeclaration", node2, opts);
  }
  function assertTSInstantiationExpression(node2, opts) {
    assert2("TSInstantiationExpression", node2, opts);
  }
  function assertTSAsExpression(node2, opts) {
    assert2("TSAsExpression", node2, opts);
  }
  function assertTSSatisfiesExpression(node2, opts) {
    assert2("TSSatisfiesExpression", node2, opts);
  }
  function assertTSTypeAssertion(node2, opts) {
    assert2("TSTypeAssertion", node2, opts);
  }
  function assertTSEnumBody(node2, opts) {
    assert2("TSEnumBody", node2, opts);
  }
  function assertTSEnumDeclaration(node2, opts) {
    assert2("TSEnumDeclaration", node2, opts);
  }
  function assertTSEnumMember(node2, opts) {
    assert2("TSEnumMember", node2, opts);
  }
  function assertTSModuleDeclaration(node2, opts) {
    assert2("TSModuleDeclaration", node2, opts);
  }
  function assertTSModuleBlock(node2, opts) {
    assert2("TSModuleBlock", node2, opts);
  }
  function assertTSImportType(node2, opts) {
    assert2("TSImportType", node2, opts);
  }
  function assertTSImportEqualsDeclaration(node2, opts) {
    assert2("TSImportEqualsDeclaration", node2, opts);
  }
  function assertTSExternalModuleReference(node2, opts) {
    assert2("TSExternalModuleReference", node2, opts);
  }
  function assertTSNonNullExpression(node2, opts) {
    assert2("TSNonNullExpression", node2, opts);
  }
  function assertTSExportAssignment(node2, opts) {
    assert2("TSExportAssignment", node2, opts);
  }
  function assertTSNamespaceExportDeclaration(node2, opts) {
    assert2("TSNamespaceExportDeclaration", node2, opts);
  }
  function assertTSTypeAnnotation(node2, opts) {
    assert2("TSTypeAnnotation", node2, opts);
  }
  function assertTSTypeParameterInstantiation(node2, opts) {
    assert2("TSTypeParameterInstantiation", node2, opts);
  }
  function assertTSTypeParameterDeclaration(node2, opts) {
    assert2("TSTypeParameterDeclaration", node2, opts);
  }
  function assertTSTypeParameter(node2, opts) {
    assert2("TSTypeParameter", node2, opts);
  }
  function assertStandardized(node2, opts) {
    assert2("Standardized", node2, opts);
  }
  function assertExpression(node2, opts) {
    assert2("Expression", node2, opts);
  }
  function assertBinary(node2, opts) {
    assert2("Binary", node2, opts);
  }
  function assertScopable(node2, opts) {
    assert2("Scopable", node2, opts);
  }
  function assertBlockParent(node2, opts) {
    assert2("BlockParent", node2, opts);
  }
  function assertBlock(node2, opts) {
    assert2("Block", node2, opts);
  }
  function assertStatement(node2, opts) {
    assert2("Statement", node2, opts);
  }
  function assertTerminatorless(node2, opts) {
    assert2("Terminatorless", node2, opts);
  }
  function assertCompletionStatement(node2, opts) {
    assert2("CompletionStatement", node2, opts);
  }
  function assertConditional(node2, opts) {
    assert2("Conditional", node2, opts);
  }
  function assertLoop(node2, opts) {
    assert2("Loop", node2, opts);
  }
  function assertWhile(node2, opts) {
    assert2("While", node2, opts);
  }
  function assertExpressionWrapper(node2, opts) {
    assert2("ExpressionWrapper", node2, opts);
  }
  function assertFor(node2, opts) {
    assert2("For", node2, opts);
  }
  function assertForXStatement(node2, opts) {
    assert2("ForXStatement", node2, opts);
  }
  function assertFunction(node2, opts) {
    assert2("Function", node2, opts);
  }
  function assertFunctionParent(node2, opts) {
    assert2("FunctionParent", node2, opts);
  }
  function assertPureish(node2, opts) {
    assert2("Pureish", node2, opts);
  }
  function assertDeclaration(node2, opts) {
    assert2("Declaration", node2, opts);
  }
  function assertFunctionParameter(node2, opts) {
    assert2("FunctionParameter", node2, opts);
  }
  function assertPatternLike(node2, opts) {
    assert2("PatternLike", node2, opts);
  }
  function assertLVal(node2, opts) {
    assert2("LVal", node2, opts);
  }
  function assertTSEntityName(node2, opts) {
    assert2("TSEntityName", node2, opts);
  }
  function assertLiteral(node2, opts) {
    assert2("Literal", node2, opts);
  }
  function assertImmutable(node2, opts) {
    assert2("Immutable", node2, opts);
  }
  function assertUserWhitespacable(node2, opts) {
    assert2("UserWhitespacable", node2, opts);
  }
  function assertMethod(node2, opts) {
    assert2("Method", node2, opts);
  }
  function assertObjectMember(node2, opts) {
    assert2("ObjectMember", node2, opts);
  }
  function assertProperty(node2, opts) {
    assert2("Property", node2, opts);
  }
  function assertUnaryLike(node2, opts) {
    assert2("UnaryLike", node2, opts);
  }
  function assertPattern(node2, opts) {
    assert2("Pattern", node2, opts);
  }
  function assertClass(node2, opts) {
    assert2("Class", node2, opts);
  }
  function assertImportOrExportDeclaration(node2, opts) {
    assert2("ImportOrExportDeclaration", node2, opts);
  }
  function assertExportDeclaration(node2, opts) {
    assert2("ExportDeclaration", node2, opts);
  }
  function assertModuleSpecifier(node2, opts) {
    assert2("ModuleSpecifier", node2, opts);
  }
  function assertAccessor(node2, opts) {
    assert2("Accessor", node2, opts);
  }
  function assertPrivate(node2, opts) {
    assert2("Private", node2, opts);
  }
  function assertFlow(node2, opts) {
    assert2("Flow", node2, opts);
  }
  function assertFlowType(node2, opts) {
    assert2("FlowType", node2, opts);
  }
  function assertFlowBaseAnnotation(node2, opts) {
    assert2("FlowBaseAnnotation", node2, opts);
  }
  function assertFlowDeclaration(node2, opts) {
    assert2("FlowDeclaration", node2, opts);
  }
  function assertFlowPredicate(node2, opts) {
    assert2("FlowPredicate", node2, opts);
  }
  function assertEnumBody(node2, opts) {
    assert2("EnumBody", node2, opts);
  }
  function assertEnumMember(node2, opts) {
    assert2("EnumMember", node2, opts);
  }
  function assertJSX(node2, opts) {
    assert2("JSX", node2, opts);
  }
  function assertMiscellaneous(node2, opts) {
    assert2("Miscellaneous", node2, opts);
  }
  function assertTypeScript(node2, opts) {
    assert2("TypeScript", node2, opts);
  }
  function assertTSTypeElement(node2, opts) {
    assert2("TSTypeElement", node2, opts);
  }
  function assertTSType(node2, opts) {
    assert2("TSType", node2, opts);
  }
  function assertTSBaseType(node2, opts) {
    assert2("TSBaseType", node2, opts);
  }
  function assertNumberLiteral(node2, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert2("NumberLiteral", node2, opts);
  }
  function assertRegexLiteral(node2, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert2("RegexLiteral", node2, opts);
  }
  function assertRestProperty(node2, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert2("RestProperty", node2, opts);
  }
  function assertSpreadProperty(node2, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert2("SpreadProperty", node2, opts);
  }
  function assertModuleDeclaration(node2, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert2("ModuleDeclaration", node2, opts);
  }
  return generated$1;
}
var createTypeAnnotationBasedOnTypeof = {};
var hasRequiredCreateTypeAnnotationBasedOnTypeof;
function requireCreateTypeAnnotationBasedOnTypeof() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof) return createTypeAnnotationBasedOnTypeof;
  hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;
  Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
    value: true
  });
  createTypeAnnotationBasedOnTypeof.default = void 0;
  var _index = requireGenerated$2();
  createTypeAnnotationBasedOnTypeof.default = createTypeAnnotationBasedOnTypeof$1;
  function createTypeAnnotationBasedOnTypeof$1(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
  return createTypeAnnotationBasedOnTypeof;
}
var createFlowUnionType = {};
var removeTypeDuplicates$1 = {};
var hasRequiredRemoveTypeDuplicates$1;
function requireRemoveTypeDuplicates$1() {
  if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
  hasRequiredRemoveTypeDuplicates$1 = 1;
  Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
    value: true
  });
  removeTypeDuplicates$1.default = removeTypeDuplicates2;
  var _index = requireGenerated$3();
  function getQualifiedName(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.id.name}.${getQualifiedName(node2.qualification)}`;
  }
  function removeTypeDuplicates2(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = /* @__PURE__ */ new Map();
    const bases = /* @__PURE__ */ new Map();
    const typeGroups = /* @__PURE__ */ new Set();
    const types2 = [];
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2) continue;
      if (types2.includes(node2)) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node2)) {
        return [node2];
      }
      if ((0, _index.isFlowBaseAnnotation)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node2)) {
        const name = getQualifiedName(node2.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node2.typeParameters) {
              existing.typeParameters.params.push(...node2.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates2(existing.typeParameters.params);
            }
          } else {
            existing = node2.typeParameters;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types2.push(node2);
    }
    for (const [, baseType] of bases) {
      types2.push(baseType);
    }
    for (const [, genericName] of generics) {
      types2.push(genericName);
    }
    return types2;
  }
  return removeTypeDuplicates$1;
}
var hasRequiredCreateFlowUnionType;
function requireCreateFlowUnionType() {
  if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
  hasRequiredCreateFlowUnionType = 1;
  Object.defineProperty(createFlowUnionType, "__esModule", {
    value: true
  });
  createFlowUnionType.default = createFlowUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
  function createFlowUnionType$1(types2) {
    const flattened = (0, _removeTypeDuplicates.default)(types2);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  }
  return createFlowUnionType;
}
var createTSUnionType = {};
var removeTypeDuplicates = {};
var hasRequiredRemoveTypeDuplicates;
function requireRemoveTypeDuplicates() {
  if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
  hasRequiredRemoveTypeDuplicates = 1;
  Object.defineProperty(removeTypeDuplicates, "__esModule", {
    value: true
  });
  removeTypeDuplicates.default = removeTypeDuplicates$12;
  var _index = requireGenerated$3();
  function getQualifiedName(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : (0, _index.isThisExpression)(node2) ? "this" : `${node2.right.name}.${getQualifiedName(node2.left)}`;
  }
  function removeTypeDuplicates$12(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = /* @__PURE__ */ new Map();
    const bases = /* @__PURE__ */ new Map();
    const typeGroups = /* @__PURE__ */ new Set();
    const types2 = [];
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2) continue;
      if (types2.includes(node2)) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node2)) {
        return [node2];
      }
      if ((0, _index.isTSBaseType)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isTSUnionType)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      const typeArgumentsKey = "typeParameters";
      if ((0, _index.isTSTypeReference)(node2) && node2[typeArgumentsKey]) {
        const typeArguments = node2[typeArgumentsKey];
        const name = getQualifiedName(node2.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          const existingTypeArguments = existing[typeArgumentsKey];
          if (existingTypeArguments) {
            existingTypeArguments.params.push(...typeArguments.params);
            existingTypeArguments.params = removeTypeDuplicates$12(existingTypeArguments.params);
          } else {
            existing = typeArguments;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types2.push(node2);
    }
    for (const [, baseType] of bases) {
      types2.push(baseType);
    }
    for (const [, genericName] of generics) {
      types2.push(genericName);
    }
    return types2;
  }
  return removeTypeDuplicates;
}
var hasRequiredCreateTSUnionType;
function requireCreateTSUnionType() {
  if (hasRequiredCreateTSUnionType) return createTSUnionType;
  hasRequiredCreateTSUnionType = 1;
  Object.defineProperty(createTSUnionType, "__esModule", {
    value: true
  });
  createTSUnionType.default = createTSUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates();
  var _index2 = requireGenerated$3();
  function createTSUnionType$1(typeAnnotations) {
    const types2 = typeAnnotations.map((type) => {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types2);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  }
  return createTSUnionType;
}
var productions = {};
var hasRequiredProductions;
function requireProductions() {
  if (hasRequiredProductions) return productions;
  hasRequiredProductions = 1;
  Object.defineProperty(productions, "__esModule", {
    value: true
  });
  productions.buildUndefinedNode = buildUndefinedNode;
  var _index = requireGenerated$2();
  function buildUndefinedNode() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  }
  return productions;
}
var cloneNode = {};
var hasRequiredCloneNode;
function requireCloneNode() {
  if (hasRequiredCloneNode) return cloneNode;
  hasRequiredCloneNode = 1;
  Object.defineProperty(cloneNode, "__esModule", {
    value: true
  });
  cloneNode.default = cloneNode$1;
  var _index = requireDefinitions();
  var _index2 = requireGenerated$3();
  const {
    hasOwn
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node2) => cloneIfNode(node2, deep, withoutLoc, commentsCache));
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode$1(node2, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node2, deep, withoutLoc, /* @__PURE__ */ new Map());
  }
  function cloneNodeInternal(node2, deep = true, withoutLoc = false, commentsCache) {
    if (!node2) return node2;
    const {
      type
    } = node2;
    const newNode = {
      type: node2.type
    };
    if ((0, _index2.isIdentifier)(node2)) {
      newNode.name = node2.name;
      if (hasOwn(node2, "optional") && typeof node2.optional === "boolean") {
        newNode.optional = node2.optional;
      }
      if (hasOwn(node2, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache) : node2.typeAnnotation;
      }
      if (hasOwn(node2, "decorators")) {
        newNode.decorators = deep ? cloneIfNodeOrArray(node2.decorators, true, withoutLoc, commentsCache) : node2.decorators;
      }
    } else if (!hasOwn(_index.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_index.NODE_FIELDS[type])) {
        if (hasOwn(node2, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node2) && field === "comments" ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node2[field];
          }
        }
      }
    }
    if (hasOwn(node2, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node2.loc;
      }
    }
    if (hasOwn(node2, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "extra")) {
      newNode.extra = Object.assign({}, node2.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments2, deep, withoutLoc, commentsCache) {
    if (!comments2 || !deep) {
      return comments2;
    }
    return comments2.map((comment) => {
      const cache2 = commentsCache.get(comment);
      if (cache2) return cache2;
      const {
        type,
        value,
        loc
      } = comment;
      const ret = {
        type,
        value,
        loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }
  return cloneNode;
}
var clone = {};
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  Object.defineProperty(clone, "__esModule", {
    value: true
  });
  clone.default = clone$1;
  var _cloneNode = requireCloneNode();
  function clone$1(node2) {
    return (0, _cloneNode.default)(node2, false);
  }
  return clone;
}
var cloneDeep = {};
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep;
  hasRequiredCloneDeep = 1;
  Object.defineProperty(cloneDeep, "__esModule", {
    value: true
  });
  cloneDeep.default = cloneDeep$1;
  var _cloneNode = requireCloneNode();
  function cloneDeep$1(node2) {
    return (0, _cloneNode.default)(node2);
  }
  return cloneDeep;
}
var cloneDeepWithoutLoc = {};
var hasRequiredCloneDeepWithoutLoc;
function requireCloneDeepWithoutLoc() {
  if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
  hasRequiredCloneDeepWithoutLoc = 1;
  Object.defineProperty(cloneDeepWithoutLoc, "__esModule", {
    value: true
  });
  cloneDeepWithoutLoc.default = cloneDeepWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneDeepWithoutLoc$1(node2) {
    return (0, _cloneNode.default)(node2, true, true);
  }
  return cloneDeepWithoutLoc;
}
var cloneWithoutLoc = {};
var hasRequiredCloneWithoutLoc;
function requireCloneWithoutLoc() {
  if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
  hasRequiredCloneWithoutLoc = 1;
  Object.defineProperty(cloneWithoutLoc, "__esModule", {
    value: true
  });
  cloneWithoutLoc.default = cloneWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneWithoutLoc$1(node2) {
    return (0, _cloneNode.default)(node2, false, true);
  }
  return cloneWithoutLoc;
}
var addComment = {};
var addComments = {};
var hasRequiredAddComments;
function requireAddComments() {
  if (hasRequiredAddComments) return addComments;
  hasRequiredAddComments = 1;
  Object.defineProperty(addComments, "__esModule", {
    value: true
  });
  addComments.default = addComments$1;
  function addComments$1(node2, type, comments2) {
    if (!comments2 || !node2) return node2;
    const key = `${type}Comments`;
    if (node2[key]) {
      if (type === "leading") {
        node2[key] = comments2.concat(node2[key]);
      } else {
        node2[key].push(...comments2);
      }
    } else {
      node2[key] = comments2;
    }
    return node2;
  }
  return addComments;
}
var hasRequiredAddComment;
function requireAddComment() {
  if (hasRequiredAddComment) return addComment;
  hasRequiredAddComment = 1;
  Object.defineProperty(addComment, "__esModule", {
    value: true
  });
  addComment.default = addComment$1;
  var _addComments = requireAddComments();
  function addComment$1(node2, type, content, line) {
    return (0, _addComments.default)(node2, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }
  return addComment;
}
var inheritInnerComments = {};
var inherit = {};
var hasRequiredInherit;
function requireInherit() {
  if (hasRequiredInherit) return inherit;
  hasRequiredInherit = 1;
  Object.defineProperty(inherit, "__esModule", {
    value: true
  });
  inherit.default = inherit$1;
  function inherit$1(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }
  return inherit;
}
var hasRequiredInheritInnerComments;
function requireInheritInnerComments() {
  if (hasRequiredInheritInnerComments) return inheritInnerComments;
  hasRequiredInheritInnerComments = 1;
  Object.defineProperty(inheritInnerComments, "__esModule", {
    value: true
  });
  inheritInnerComments.default = inheritInnerComments$1;
  var _inherit = requireInherit();
  function inheritInnerComments$1(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  }
  return inheritInnerComments;
}
var inheritLeadingComments = {};
var hasRequiredInheritLeadingComments;
function requireInheritLeadingComments() {
  if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
  hasRequiredInheritLeadingComments = 1;
  Object.defineProperty(inheritLeadingComments, "__esModule", {
    value: true
  });
  inheritLeadingComments.default = inheritLeadingComments$1;
  var _inherit = requireInherit();
  function inheritLeadingComments$1(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  }
  return inheritLeadingComments;
}
var inheritsComments = {};
var inheritTrailingComments = {};
var hasRequiredInheritTrailingComments;
function requireInheritTrailingComments() {
  if (hasRequiredInheritTrailingComments) return inheritTrailingComments;
  hasRequiredInheritTrailingComments = 1;
  Object.defineProperty(inheritTrailingComments, "__esModule", {
    value: true
  });
  inheritTrailingComments.default = inheritTrailingComments$1;
  var _inherit = requireInherit();
  function inheritTrailingComments$1(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  }
  return inheritTrailingComments;
}
var hasRequiredInheritsComments;
function requireInheritsComments() {
  if (hasRequiredInheritsComments) return inheritsComments;
  hasRequiredInheritsComments = 1;
  Object.defineProperty(inheritsComments, "__esModule", {
    value: true
  });
  inheritsComments.default = inheritsComments$1;
  var _inheritTrailingComments = requireInheritTrailingComments();
  var _inheritLeadingComments = requireInheritLeadingComments();
  var _inheritInnerComments = requireInheritInnerComments();
  function inheritsComments$1(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }
  return inheritsComments;
}
var removeComments = {};
var hasRequiredRemoveComments;
function requireRemoveComments() {
  if (hasRequiredRemoveComments) return removeComments;
  hasRequiredRemoveComments = 1;
  Object.defineProperty(removeComments, "__esModule", {
    value: true
  });
  removeComments.default = removeComments$1;
  var _index = requireConstants();
  function removeComments$1(node2) {
    _index.COMMENT_KEYS.forEach((key) => {
      node2[key] = null;
    });
    return node2;
  }
  return removeComments;
}
var generated = {};
var hasRequiredGenerated;
function requireGenerated() {
  if (hasRequiredGenerated) return generated;
  hasRequiredGenerated = 1;
  Object.defineProperty(generated, "__esModule", {
    value: true
  });
  generated.WHILE_TYPES = generated.USERWHITESPACABLE_TYPES = generated.UNARYLIKE_TYPES = generated.TYPESCRIPT_TYPES = generated.TSTYPE_TYPES = generated.TSTYPEELEMENT_TYPES = generated.TSENTITYNAME_TYPES = generated.TSBASETYPE_TYPES = generated.TERMINATORLESS_TYPES = generated.STATEMENT_TYPES = generated.STANDARDIZED_TYPES = generated.SCOPABLE_TYPES = generated.PUREISH_TYPES = generated.PROPERTY_TYPES = generated.PRIVATE_TYPES = generated.PATTERN_TYPES = generated.PATTERNLIKE_TYPES = generated.OBJECTMEMBER_TYPES = generated.MODULESPECIFIER_TYPES = generated.MODULEDECLARATION_TYPES = generated.MISCELLANEOUS_TYPES = generated.METHOD_TYPES = generated.LVAL_TYPES = generated.LOOP_TYPES = generated.LITERAL_TYPES = generated.JSX_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = generated.IMMUTABLE_TYPES = generated.FUNCTION_TYPES = generated.FUNCTIONPARENT_TYPES = generated.FUNCTIONPARAMETER_TYPES = generated.FOR_TYPES = generated.FORXSTATEMENT_TYPES = generated.FLOW_TYPES = generated.FLOWTYPE_TYPES = generated.FLOWPREDICATE_TYPES = generated.FLOWDECLARATION_TYPES = generated.FLOWBASEANNOTATION_TYPES = generated.EXPRESSION_TYPES = generated.EXPRESSIONWRAPPER_TYPES = generated.EXPORTDECLARATION_TYPES = generated.ENUMMEMBER_TYPES = generated.ENUMBODY_TYPES = generated.DECLARATION_TYPES = generated.CONDITIONAL_TYPES = generated.COMPLETIONSTATEMENT_TYPES = generated.CLASS_TYPES = generated.BLOCK_TYPES = generated.BLOCKPARENT_TYPES = generated.BINARY_TYPES = generated.ACCESSOR_TYPES = void 0;
  var _index = requireDefinitions();
  generated.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  generated.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  generated.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  generated.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  generated.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  generated.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  generated.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  generated.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  generated.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  generated.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  generated.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  generated.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  generated.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  generated.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  generated.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  generated.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  generated.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  generated.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  generated.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  generated.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParameter"];
  generated.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  generated.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  generated.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  generated.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  generated.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  generated.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  generated.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  generated.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  generated.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  generated.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  generated.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  generated.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  const IMPORTOREXPORTDECLARATION_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  generated.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  generated.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  generated.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  generated.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  generated.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  generated.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  generated.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  generated.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  generated.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  generated.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  generated.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  generated.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  generated.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  generated.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  generated.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  generated.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  generated.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  generated.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  return generated;
}
var ensureBlock = {};
var toBlock = {};
var hasRequiredToBlock;
function requireToBlock() {
  if (hasRequiredToBlock) return toBlock;
  hasRequiredToBlock = 1;
  Object.defineProperty(toBlock, "__esModule", {
    value: true
  });
  toBlock.default = toBlock$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toBlock$1(node2, parent) {
    if ((0, _index.isBlockStatement)(node2)) {
      return node2;
    }
    let blockNodes = [];
    if ((0, _index.isEmptyStatement)(node2)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node2)) {
        if ((0, _index.isFunction)(parent)) {
          node2 = (0, _index2.returnStatement)(node2);
        } else {
          node2 = (0, _index2.expressionStatement)(node2);
        }
      }
      blockNodes = [node2];
    }
    return (0, _index2.blockStatement)(blockNodes);
  }
  return toBlock;
}
var hasRequiredEnsureBlock;
function requireEnsureBlock() {
  if (hasRequiredEnsureBlock) return ensureBlock;
  hasRequiredEnsureBlock = 1;
  Object.defineProperty(ensureBlock, "__esModule", {
    value: true
  });
  ensureBlock.default = ensureBlock$1;
  var _toBlock = requireToBlock();
  function ensureBlock$1(node2, key = "body") {
    const result = (0, _toBlock.default)(node2[key], node2);
    node2[key] = result;
    return result;
  }
  return ensureBlock;
}
var toBindingIdentifierName = {};
var toIdentifier = {};
var hasRequiredToIdentifier;
function requireToIdentifier() {
  if (hasRequiredToIdentifier) return toIdentifier;
  hasRequiredToIdentifier = 1;
  Object.defineProperty(toIdentifier, "__esModule", {
    value: true
  });
  toIdentifier.default = toIdentifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$7();
  function toIdentifier$1(input) {
    input = input + "";
    let name = "";
    for (const c2 of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c2.codePointAt(0)) ? c2 : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c2) {
      return c2 ? c2.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  }
  return toIdentifier;
}
var hasRequiredToBindingIdentifierName;
function requireToBindingIdentifierName() {
  if (hasRequiredToBindingIdentifierName) return toBindingIdentifierName;
  hasRequiredToBindingIdentifierName = 1;
  Object.defineProperty(toBindingIdentifierName, "__esModule", {
    value: true
  });
  toBindingIdentifierName.default = toBindingIdentifierName$1;
  var _toIdentifier = requireToIdentifier();
  function toBindingIdentifierName$1(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }
  return toBindingIdentifierName;
}
var toComputedKey = {};
var hasRequiredToComputedKey;
function requireToComputedKey() {
  if (hasRequiredToComputedKey) return toComputedKey;
  hasRequiredToComputedKey = 1;
  Object.defineProperty(toComputedKey, "__esModule", {
    value: true
  });
  toComputedKey.default = toComputedKey$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toComputedKey$1(node2, key = node2.key || node2.property) {
    if (!node2.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
    return key;
  }
  return toComputedKey;
}
var toExpression = {};
var hasRequiredToExpression;
function requireToExpression() {
  if (hasRequiredToExpression) return toExpression;
  hasRequiredToExpression = 1;
  Object.defineProperty(toExpression, "__esModule", {
    value: true
  });
  toExpression.default = void 0;
  var _index = requireGenerated$3();
  toExpression.default = toExpression$1;
  function toExpression$1(node2) {
    if ((0, _index.isExpressionStatement)(node2)) {
      node2 = node2.expression;
    }
    if ((0, _index.isExpression)(node2)) {
      return node2;
    }
    if ((0, _index.isClass)(node2)) {
      node2.type = "ClassExpression";
      node2.abstract = false;
    } else if ((0, _index.isFunction)(node2)) {
      node2.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node2)) {
      throw new Error(`cannot turn ${node2.type} to an expression`);
    }
    return node2;
  }
  return toExpression;
}
var toKeyAlias = {};
var removePropertiesDeep = {};
var traverseFast = {};
var hasRequiredTraverseFast;
function requireTraverseFast() {
  if (hasRequiredTraverseFast) return traverseFast;
  hasRequiredTraverseFast = 1;
  Object.defineProperty(traverseFast, "__esModule", {
    value: true
  });
  traverseFast.default = traverseFast$1;
  var _index = requireDefinitions();
  const _skip = Symbol();
  const _stop = Symbol();
  function traverseFast$1(node2, enter, opts) {
    if (!node2) return false;
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys) return false;
    opts = opts || {};
    const ret = enter(node2, opts);
    if (ret !== void 0) {
      switch (ret) {
        case _skip:
          return false;
        case _stop:
          return true;
      }
    }
    for (const key of keys) {
      const subNode = node2[key];
      if (!subNode) continue;
      if (Array.isArray(subNode)) {
        for (const node3 of subNode) {
          if (traverseFast$1(node3, enter, opts)) return true;
        }
      } else {
        if (traverseFast$1(subNode, enter, opts)) return true;
      }
    }
    return false;
  }
  traverseFast$1.skip = _skip;
  traverseFast$1.stop = _stop;
  return traverseFast;
}
var removeProperties = {};
var hasRequiredRemoveProperties;
function requireRemoveProperties() {
  if (hasRequiredRemoveProperties) return removeProperties;
  hasRequiredRemoveProperties = 1;
  Object.defineProperty(removeProperties, "__esModule", {
    value: true
  });
  removeProperties.default = removeProperties$1;
  var _index = requireConstants();
  const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  const CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
  function removeProperties$1(node2, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node2[key] != null) node2[key] = void 0;
    }
    for (const key of Object.keys(node2)) {
      if (key[0] === "_" && node2[key] != null) node2[key] = void 0;
    }
    const symbols = Object.getOwnPropertySymbols(node2);
    for (const sym of symbols) {
      node2[sym] = null;
    }
  }
  return removeProperties;
}
var hasRequiredRemovePropertiesDeep;
function requireRemovePropertiesDeep() {
  if (hasRequiredRemovePropertiesDeep) return removePropertiesDeep;
  hasRequiredRemovePropertiesDeep = 1;
  Object.defineProperty(removePropertiesDeep, "__esModule", {
    value: true
  });
  removePropertiesDeep.default = removePropertiesDeep$1;
  var _traverseFast = requireTraverseFast();
  var _removeProperties = requireRemoveProperties();
  function removePropertiesDeep$1(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }
  return removePropertiesDeep;
}
var hasRequiredToKeyAlias;
function requireToKeyAlias() {
  if (hasRequiredToKeyAlias) return toKeyAlias;
  hasRequiredToKeyAlias = 1;
  Object.defineProperty(toKeyAlias, "__esModule", {
    value: true
  });
  toKeyAlias.default = toKeyAlias$1;
  var _index = requireGenerated$3();
  var _cloneNode = requireCloneNode();
  var _removePropertiesDeep = requireRemovePropertiesDeep();
  function toKeyAlias$1(node2, key = node2.key) {
    let alias;
    if (node2.kind === "method") {
      return toKeyAlias$1.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    }
    if (node2.computed) {
      alias = `[${alias}]`;
    }
    if (node2.static) {
      alias = `static:${alias}`;
    }
    return alias;
  }
  toKeyAlias$1.uid = 0;
  toKeyAlias$1.increment = function() {
    if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias$1.uid = 0;
    } else {
      return toKeyAlias$1.uid++;
    }
  };
  return toKeyAlias;
}
var toStatement = {};
var hasRequiredToStatement;
function requireToStatement() {
  if (hasRequiredToStatement) return toStatement;
  hasRequiredToStatement = 1;
  Object.defineProperty(toStatement, "__esModule", {
    value: true
  });
  toStatement.default = void 0;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  toStatement.default = toStatement$1;
  function toStatement$1(node2, ignore) {
    if ((0, _index.isStatement)(node2)) {
      return node2;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _index.isClass)(node2)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node2)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node2)) {
      return (0, _index2.expressionStatement)(node2);
    }
    if (mustHaveId && !node2.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node2.type} to a statement`);
      }
    }
    node2.type = newType;
    return node2;
  }
  return toStatement;
}
var valueToNode = {};
var hasRequiredValueToNode;
function requireValueToNode() {
  if (hasRequiredValueToNode) return valueToNode;
  hasRequiredValueToNode = 1;
  Object.defineProperty(valueToNode, "__esModule", {
    value: true
  });
  valueToNode.default = void 0;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _index = requireGenerated$2();
  valueToNode.default = valueToNode$1;
  const objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode$1(value) {
    if (value === void 0) {
      return (0, _index.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _index.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _index.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _index.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (typeof value === "bigint") {
      if (value < 0) {
        return (0, _index.unaryExpression)("-", (0, _index.bigIntLiteral)(-value));
      } else {
        return (0, _index.bigIntLiteral)(value);
      }
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = /\/([a-z]*)$/.exec(value.toString())[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _index.arrayExpression)(value.map(valueToNode$1));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey, computed = false;
        if ((0, _isValidIdentifier.default)(key)) {
          if (key === "__proto__") {
            computed = true;
            nodeKey = (0, _index.stringLiteral)(key);
          } else {
            nodeKey = (0, _index.identifier)(key);
          }
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode$1(value[key]), computed));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode;
}
var appendToMemberExpression = {};
var hasRequiredAppendToMemberExpression;
function requireAppendToMemberExpression() {
  if (hasRequiredAppendToMemberExpression) return appendToMemberExpression;
  hasRequiredAppendToMemberExpression = 1;
  Object.defineProperty(appendToMemberExpression, "__esModule", {
    value: true
  });
  appendToMemberExpression.default = appendToMemberExpression$1;
  var _index = requireGenerated$2();
  function appendToMemberExpression$1(member, append, computed = false) {
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }
  return appendToMemberExpression;
}
var inherits = {};
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits;
  hasRequiredInherits = 1;
  Object.defineProperty(inherits, "__esModule", {
    value: true
  });
  inherits.default = inherits$1;
  var _index = requireConstants();
  var _inheritsComments = requireInheritsComments();
  function inherits$1(child, parent) {
    if (!child || !parent) return child;
    for (const key of _index.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _index.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  }
  return inherits;
}
var prependToMemberExpression = {};
var hasRequiredPrependToMemberExpression;
function requirePrependToMemberExpression() {
  if (hasRequiredPrependToMemberExpression) return prependToMemberExpression;
  hasRequiredPrependToMemberExpression = 1;
  Object.defineProperty(prependToMemberExpression, "__esModule", {
    value: true
  });
  prependToMemberExpression.default = prependToMemberExpression$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$5();
  function prependToMemberExpression$1(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  }
  return prependToMemberExpression;
}
var getAssignmentIdentifiers = {};
var hasRequiredGetAssignmentIdentifiers;
function requireGetAssignmentIdentifiers() {
  if (hasRequiredGetAssignmentIdentifiers) return getAssignmentIdentifiers;
  hasRequiredGetAssignmentIdentifiers = 1;
  Object.defineProperty(getAssignmentIdentifiers, "__esModule", {
    value: true
  });
  getAssignmentIdentifiers.default = getAssignmentIdentifiers$1;
  function getAssignmentIdentifiers$1(node2) {
    const search = [].concat(node2);
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.pop();
      if (!id) continue;
      switch (id.type) {
        case "ArrayPattern":
          search.push(...id.elements);
          break;
        case "AssignmentExpression":
        case "AssignmentPattern":
        case "ForInStatement":
        case "ForOfStatement":
          search.push(id.left);
          break;
        case "ObjectPattern":
          search.push(...id.properties);
          break;
        case "ObjectProperty":
          search.push(id.value);
          break;
        case "RestElement":
        case "UpdateExpression":
          search.push(id.argument);
          break;
        case "UnaryExpression":
          if (id.operator === "delete") {
            search.push(id.argument);
          }
          break;
        case "Identifier":
          ids[id.name] = id;
          break;
      }
    }
    return ids;
  }
  return getAssignmentIdentifiers;
}
var getBindingIdentifiers = {};
var hasRequiredGetBindingIdentifiers;
function requireGetBindingIdentifiers() {
  if (hasRequiredGetBindingIdentifiers) return getBindingIdentifiers;
  hasRequiredGetBindingIdentifiers = 1;
  Object.defineProperty(getBindingIdentifiers, "__esModule", {
    value: true
  });
  getBindingIdentifiers.default = getBindingIdentifiers$1;
  var _index = requireGenerated$3();
  function getBindingIdentifiers$1(node2, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node2);
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
        continue;
      }
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      const keys2 = getBindingIdentifiers$1.keys[id.type];
      if (keys2) {
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          const nodes = id[key];
          if (nodes) {
            if (Array.isArray(nodes)) {
              search.push(...nodes);
            } else {
              search.push(nodes);
            }
          }
        }
      }
    }
    return ids;
  }
  const keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  getBindingIdentifiers$1.keys = keys;
  return getBindingIdentifiers;
}
var getOuterBindingIdentifiers = {};
var hasRequiredGetOuterBindingIdentifiers;
function requireGetOuterBindingIdentifiers() {
  if (hasRequiredGetOuterBindingIdentifiers) return getOuterBindingIdentifiers;
  hasRequiredGetOuterBindingIdentifiers = 1;
  Object.defineProperty(getOuterBindingIdentifiers, "__esModule", {
    value: true
  });
  getOuterBindingIdentifiers.default = void 0;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  getOuterBindingIdentifiers.default = getOuterBindingIdentifiers$1;
  function getOuterBindingIdentifiers$1(node2, duplicates) {
    return (0, _getBindingIdentifiers.default)(node2, duplicates, true);
  }
  return getOuterBindingIdentifiers;
}
var getFunctionName = {};
var hasRequiredGetFunctionName;
function requireGetFunctionName() {
  if (hasRequiredGetFunctionName) return getFunctionName;
  hasRequiredGetFunctionName = 1;
  Object.defineProperty(getFunctionName, "__esModule", {
    value: true
  });
  getFunctionName.default = getFunctionName$1;
  var _index = requireGenerated$3();
  function getNameFromLiteralId(id) {
    if ((0, _index.isNullLiteral)(id)) {
      return "null";
    }
    if ((0, _index.isRegExpLiteral)(id)) {
      return `/${id.pattern}/${id.flags}`;
    }
    if ((0, _index.isTemplateLiteral)(id)) {
      return id.quasis.map((quasi) => quasi.value.raw).join("");
    }
    if (id.value !== void 0) {
      return String(id.value);
    }
    return null;
  }
  function getObjectMemberKey(node2) {
    if (!node2.computed || (0, _index.isLiteral)(node2.key)) {
      return node2.key;
    }
  }
  function getFunctionName$1(node2, parent) {
    if ("id" in node2 && node2.id) {
      return {
        name: node2.id.name,
        originalNode: node2.id
      };
    }
    let prefix = "";
    let id;
    if ((0, _index.isObjectProperty)(parent, {
      value: node2
    })) {
      id = getObjectMemberKey(parent);
    } else if ((0, _index.isObjectMethod)(node2) || (0, _index.isClassMethod)(node2)) {
      id = getObjectMemberKey(node2);
      if (node2.kind === "get") prefix = "get ";
      else if (node2.kind === "set") prefix = "set ";
    } else if ((0, _index.isVariableDeclarator)(parent, {
      init: node2
    })) {
      id = parent.id;
    } else if ((0, _index.isAssignmentExpression)(parent, {
      operator: "=",
      right: node2
    })) {
      id = parent.left;
    }
    if (!id) return null;
    const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
    if (name == null) return null;
    return {
      name: prefix + name,
      originalNode: id
    };
  }
  return getFunctionName;
}
var traverse$1 = {};
var hasRequiredTraverse;
function requireTraverse() {
  if (hasRequiredTraverse) return traverse$1;
  hasRequiredTraverse = 1;
  Object.defineProperty(traverse$1, "__esModule", {
    value: true
  });
  traverse$1.default = traverse2;
  var _index = requireDefinitions();
  function traverse2(node2, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node2, enter, exit, state, []);
  }
  function traverseSimpleImpl(node2, enter, exit, state, ancestors) {
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys) return;
    if (enter) enter(node2, ancestors, state);
    for (const key of keys) {
      const subNode = node2[key];
      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node2,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node2,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit) exit(node2, ancestors, state);
  }
  return traverse$1;
}
var isBinding = {};
var hasRequiredIsBinding;
function requireIsBinding() {
  if (hasRequiredIsBinding) return isBinding;
  hasRequiredIsBinding = 1;
  Object.defineProperty(isBinding, "__esModule", {
    value: true
  });
  isBinding.default = isBinding$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  function isBinding$1(node2, parent, grandparent) {
    if (grandparent && node2.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.includes(node2)) return true;
        } else {
          if (val === node2) return true;
        }
      }
    }
    return false;
  }
  return isBinding;
}
var isBlockScoped = {};
var isLet = {};
var hasRequiredIsLet;
function requireIsLet() {
  if (hasRequiredIsLet) return isLet;
  hasRequiredIsLet = 1;
  Object.defineProperty(isLet, "__esModule", {
    value: true
  });
  isLet.default = isLet$1;
  var _index = requireGenerated$3();
  {
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  }
  function isLet$1(node2) {
    {
      return (0, _index.isVariableDeclaration)(node2) && (node2.kind !== "var" || node2[BLOCK_SCOPED_SYMBOL]);
    }
  }
  return isLet;
}
var hasRequiredIsBlockScoped;
function requireIsBlockScoped() {
  if (hasRequiredIsBlockScoped) return isBlockScoped;
  hasRequiredIsBlockScoped = 1;
  Object.defineProperty(isBlockScoped, "__esModule", {
    value: true
  });
  isBlockScoped.default = isBlockScoped$1;
  var _index = requireGenerated$3();
  var _isLet = requireIsLet();
  function isBlockScoped$1(node2) {
    return (0, _index.isFunctionDeclaration)(node2) || (0, _index.isClassDeclaration)(node2) || (0, _isLet.default)(node2);
  }
  return isBlockScoped;
}
var isImmutable = {};
var hasRequiredIsImmutable;
function requireIsImmutable() {
  if (hasRequiredIsImmutable) return isImmutable;
  hasRequiredIsImmutable = 1;
  Object.defineProperty(isImmutable, "__esModule", {
    value: true
  });
  isImmutable.default = isImmutable$1;
  var _isType = requireIsType();
  var _index = requireGenerated$3();
  function isImmutable$1(node2) {
    if ((0, _isType.default)(node2.type, "Immutable")) return true;
    if ((0, _index.isIdentifier)(node2)) {
      if (node2.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
  return isImmutable;
}
var isNodesEquivalent = {};
var hasRequiredIsNodesEquivalent;
function requireIsNodesEquivalent() {
  if (hasRequiredIsNodesEquivalent) return isNodesEquivalent;
  hasRequiredIsNodesEquivalent = 1;
  Object.defineProperty(isNodesEquivalent, "__esModule", {
    value: true
  });
  isNodesEquivalent.default = isNodesEquivalent$1;
  var _index = requireDefinitions();
  function isNodesEquivalent$1(a2, b2) {
    if (typeof a2 !== "object" || typeof b2 !== "object" || a2 == null || b2 == null) {
      return a2 === b2;
    }
    if (a2.type !== b2.type) {
      return false;
    }
    const fields = Object.keys(_index.NODE_FIELDS[a2.type] || a2.type);
    const visitorKeys = _index.VISITOR_KEYS[a2.type];
    for (const field of fields) {
      const val_a = a2[field];
      const val_b = b2[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0; i < val_a.length; i++) {
          if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent$1(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }
  return isNodesEquivalent;
}
var isReferenced = {};
var hasRequiredIsReferenced;
function requireIsReferenced() {
  if (hasRequiredIsReferenced) return isReferenced;
  hasRequiredIsReferenced = 1;
  Object.defineProperty(isReferenced, "__esModule", {
    value: true
  });
  isReferenced.default = isReferenced$1;
  function isReferenced$1(node2, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node2) {
          return !!parent.computed;
        }
        return parent.object === node2;
      case "JSXMemberExpression":
        return parent.object === node2;
      case "VariableDeclarator":
        return parent.init === node2;
      case "ArrowFunctionExpression":
        return parent.body === node2;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node2;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node2;
      case "AssignmentExpression":
        return parent.right === node2;
      case "AssignmentPattern":
        return parent.right === node2;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node2;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node2;
      case "TSEnumMember":
        return parent.id !== node2;
      case "TSPropertySignature":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }
  return isReferenced;
}
var isScope = {};
var hasRequiredIsScope;
function requireIsScope() {
  if (hasRequiredIsScope) return isScope;
  hasRequiredIsScope = 1;
  Object.defineProperty(isScope, "__esModule", {
    value: true
  });
  isScope.default = isScope$1;
  var _index = requireGenerated$3();
  function isScope$1(node2, parent) {
    if ((0, _index.isBlockStatement)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node2);
  }
  return isScope;
}
var isSpecifierDefault = {};
var hasRequiredIsSpecifierDefault;
function requireIsSpecifierDefault() {
  if (hasRequiredIsSpecifierDefault) return isSpecifierDefault;
  hasRequiredIsSpecifierDefault = 1;
  Object.defineProperty(isSpecifierDefault, "__esModule", {
    value: true
  });
  isSpecifierDefault.default = isSpecifierDefault$1;
  var _index = requireGenerated$3();
  function isSpecifierDefault$1(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  }
  return isSpecifierDefault;
}
var isValidES3Identifier = {};
var hasRequiredIsValidES3Identifier;
function requireIsValidES3Identifier() {
  if (hasRequiredIsValidES3Identifier) return isValidES3Identifier;
  hasRequiredIsValidES3Identifier = 1;
  Object.defineProperty(isValidES3Identifier, "__esModule", {
    value: true
  });
  isValidES3Identifier.default = isValidES3Identifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier$1(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }
  return isValidES3Identifier;
}
var isVar = {};
var hasRequiredIsVar;
function requireIsVar() {
  if (hasRequiredIsVar) return isVar;
  hasRequiredIsVar = 1;
  Object.defineProperty(isVar, "__esModule", {
    value: true
  });
  isVar.default = isVar$1;
  var _index = requireGenerated$3();
  {
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  }
  function isVar$1(node2) {
    {
      return (0, _index.isVariableDeclaration)(node2, {
        kind: "var"
      }) && !node2[BLOCK_SCOPED_SYMBOL];
    }
  }
  return isVar;
}
var toSequenceExpression = {};
var gatherSequenceExpressions = {};
var hasRequiredGatherSequenceExpressions;
function requireGatherSequenceExpressions() {
  if (hasRequiredGatherSequenceExpressions) return gatherSequenceExpressions;
  hasRequiredGatherSequenceExpressions = 1;
  Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    value: true
  });
  gatherSequenceExpressions.default = gatherSequenceExpressions$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  var _productions = requireProductions();
  var _cloneNode = requireCloneNode();
  function gatherSequenceExpressions$1(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!(0, _index.isEmptyStatement)(node2)) {
        ensureLastUndefined = false;
      }
      if ((0, _index.isExpression)(node2)) {
        exprs.push(node2);
      } else if ((0, _index.isExpressionStatement)(node2)) {
        exprs.push(node2.expression);
      } else if ((0, _index.isVariableDeclaration)(node2)) {
        if (node2.kind !== "var") return;
        for (const declar of node2.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node2.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }
          if (declar.init) {
            exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _index.isIfStatement)(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions$1([node2.consequent], declars) : (0, _productions.buildUndefinedNode)();
        const alternate = node2.alternate ? gatherSequenceExpressions$1([node2.alternate], declars) : (0, _productions.buildUndefinedNode)();
        if (!consequent || !alternate) return;
        exprs.push((0, _index2.conditionalExpression)(node2.test, consequent, alternate));
      } else if ((0, _index.isBlockStatement)(node2)) {
        const body = gatherSequenceExpressions$1(node2.body, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _index.isEmptyStatement)(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push((0, _productions.buildUndefinedNode)());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  }
  return gatherSequenceExpressions;
}
var hasRequiredToSequenceExpression;
function requireToSequenceExpression() {
  if (hasRequiredToSequenceExpression) return toSequenceExpression;
  hasRequiredToSequenceExpression = 1;
  Object.defineProperty(toSequenceExpression, "__esModule", {
    value: true
  });
  toSequenceExpression.default = toSequenceExpression$1;
  var _gatherSequenceExpressions = requireGatherSequenceExpressions();
  function toSequenceExpression$1(nodes, scope2) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
    if (!result) return;
    for (const declar of declars) {
      scope2.push(declar);
    }
    return result;
  }
  return toSequenceExpression;
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$6;
  hasRequiredLib$5 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports$1, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports$1, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports$1, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports$1, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports$1, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports$1, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports$1, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports$1, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports$1, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports$1, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports$1, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports$1, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports$1, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports$1, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "getFunctionName", {
      enumerable: true,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports$1, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports$1, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports$1, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports$1, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports$1, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports$1, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports$1, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports$1, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports$1, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports$1, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports$1, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports$1, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports$1, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports$1, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports$1, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports$1, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports$1, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports$1, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports$1, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports$1, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports$1, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports$1, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports$1.react = void 0;
    Object.defineProperty(exports$1, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports$1, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports$1, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports$1, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports$1, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports$1, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports$1, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports$1, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports$1, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports$1, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports$1, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports$1, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports$1, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports$1, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports$1, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports$1, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = requireIsReactComponent();
    var _isCompatTag = requireIsCompatTag();
    var _buildChildren = requireBuildChildren();
    var _assertNode = requireAssertNode();
    var _index = requireGenerated$1();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = requireCreateTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = requireCreateFlowUnionType();
    var _createTSUnionType = requireCreateTSUnionType();
    var _productions = requireProductions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _productions[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = requireGenerated$2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index2[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = requireCloneNode();
    var _clone = requireClone();
    var _cloneDeep = requireCloneDeep();
    var _cloneDeepWithoutLoc = requireCloneDeepWithoutLoc();
    var _cloneWithoutLoc = requireCloneWithoutLoc();
    var _addComment = requireAddComment();
    var _addComments = requireAddComments();
    var _inheritInnerComments = requireInheritInnerComments();
    var _inheritLeadingComments = requireInheritLeadingComments();
    var _inheritsComments = requireInheritsComments();
    var _inheritTrailingComments = requireInheritTrailingComments();
    var _removeComments = requireRemoveComments();
    var _index3 = requireGenerated();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index3[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = requireConstants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index4[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = requireEnsureBlock();
    var _toBindingIdentifierName = requireToBindingIdentifierName();
    var _toBlock = requireToBlock();
    var _toComputedKey = requireToComputedKey();
    var _toExpression = requireToExpression();
    var _toIdentifier = requireToIdentifier();
    var _toKeyAlias = requireToKeyAlias();
    var _toStatement = requireToStatement();
    var _valueToNode = requireValueToNode();
    var _index5 = requireDefinitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index5[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = requireAppendToMemberExpression();
    var _inherits = requireInherits();
    var _prependToMemberExpression = requirePrependToMemberExpression();
    var _removeProperties = requireRemoveProperties();
    var _removePropertiesDeep = requireRemovePropertiesDeep();
    var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    var _getAssignmentIdentifiers = requireGetAssignmentIdentifiers();
    var _getBindingIdentifiers = requireGetBindingIdentifiers();
    var _getOuterBindingIdentifiers = requireGetOuterBindingIdentifiers();
    var _getFunctionName = requireGetFunctionName();
    var _traverse = requireTraverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _traverse[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = requireTraverseFast();
    var _shallowEqual = requireShallowEqual();
    var _is = requireIs();
    var _isBinding = requireIsBinding();
    var _isBlockScoped = requireIsBlockScoped();
    var _isImmutable = requireIsImmutable();
    var _isLet = requireIsLet();
    var _isNode = requireIsNode();
    var _isNodesEquivalent = requireIsNodesEquivalent();
    var _isPlaceholderType = requireIsPlaceholderType();
    var _isReferenced = requireIsReferenced();
    var _isScope = requireIsScope();
    var _isSpecifierDefault = requireIsSpecifierDefault();
    var _isType = requireIsType();
    var _isValidES3Identifier = requireIsValidES3Identifier();
    var _isValidIdentifier = requireIsValidIdentifier();
    var _isVar = requireIsVar();
    var _matchesPattern = requireMatchesPattern();
    var _validate = requireValidate();
    var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    var _index6 = requireGenerated$3();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index6[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = requireDeprecationWarning();
    var _toSequenceExpression = requireToSequenceExpression();
    exports$1.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    {
      exports$1.toSequenceExpression = _toSequenceExpression.default;
    }
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  })(lib$6);
  return lib$6;
}
var visitors = {};
var virtualTypesValidator = {};
var hasRequiredVirtualTypesValidator;
function requireVirtualTypesValidator() {
  if (hasRequiredVirtualTypesValidator) return virtualTypesValidator;
  hasRequiredVirtualTypesValidator = 1;
  Object.defineProperty(virtualTypesValidator, "__esModule", {
    value: true
  });
  virtualTypesValidator.isBindingIdentifier = isBindingIdentifier;
  virtualTypesValidator.isBlockScoped = isBlockScoped2;
  virtualTypesValidator.isExpression = isExpression;
  virtualTypesValidator.isFlow = isFlow;
  virtualTypesValidator.isForAwaitStatement = isForAwaitStatement;
  virtualTypesValidator.isGenerated = isGenerated;
  virtualTypesValidator.isPure = isPure;
  virtualTypesValidator.isReferenced = isReferenced2;
  virtualTypesValidator.isReferencedIdentifier = isReferencedIdentifier;
  virtualTypesValidator.isReferencedMemberExpression = isReferencedMemberExpression;
  virtualTypesValidator.isRestProperty = isRestProperty;
  virtualTypesValidator.isScope = isScope2;
  virtualTypesValidator.isSpreadProperty = isSpreadProperty;
  virtualTypesValidator.isStatement = isStatement;
  virtualTypesValidator.isUser = isUser;
  virtualTypesValidator.isVar = isVar2;
  var _t2 = requireLib$5();
  const {
    isBinding: isBinding2,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement,
    isForXStatement,
    isIdentifier,
    isImportDeclaration,
    isImportSpecifier,
    isJSXIdentifier,
    isJSXMemberExpression,
    isMemberExpression,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration,
    react,
    isForOfStatement
  } = _t2;
  const {
    isCompatTag: isCompatTag2
  } = react;
  function isReferencedIdentifier(opts) {
    const {
      node: node2,
      parent
    } = this;
    if (isIdentifier(node2, opts)) {
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    } else if (isJSXIdentifier(node2, opts)) {
      if (!isJSXMemberExpression(parent) && isCompatTag2(node2.name)) return false;
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    } else {
      return false;
    }
  }
  function isReferencedMemberExpression() {
    const {
      node: node2,
      parent
    } = this;
    return isMemberExpression(node2) && nodeIsReferenced(node2, parent);
  }
  function isBindingIdentifier() {
    const {
      node: node2,
      parent
    } = this;
    const grandparent = this.parentPath.parent;
    return isIdentifier(node2) && isBinding2(node2, parent, grandparent);
  }
  function isStatement() {
    const {
      node: node2,
      parent
    } = this;
    if (nodeIsStatement(node2)) {
      if (isVariableDeclaration(node2)) {
        if (isForXStatement(parent, {
          left: node2
        })) return false;
        if (isForStatement(parent, {
          init: node2
        })) return false;
      }
      return true;
    } else {
      return false;
    }
  }
  function isExpression() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  }
  function isScope2() {
    return nodeIsScope(this.node, this.parent);
  }
  function isReferenced2() {
    return nodeIsReferenced(this.node, this.parent);
  }
  function isBlockScoped2() {
    return nodeIsBlockScoped(this.node);
  }
  function isVar2() {
    return nodeIsVar(this.node);
  }
  function isUser() {
    var _this$node;
    return !!((_this$node = this.node) != null && _this$node.loc);
  }
  function isGenerated() {
    return !this.isUser();
  }
  function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  }
  function isFlow() {
    const {
      node: node2
    } = this;
    if (nodeIsFlow(node2)) {
      return true;
    } else if (isImportDeclaration(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else if (isExportDeclaration(node2)) {
      return node2.exportKind === "type";
    } else if (isImportSpecifier(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else {
      return false;
    }
  }
  function isRestProperty() {
    var _this$parentPath;
    return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
  }
  function isSpreadProperty() {
    var _this$parentPath2;
    return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
  }
  function isForAwaitStatement() {
    return isForOfStatement(this.node, {
      await: true
    });
  }
  {
    virtualTypesValidator.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    virtualTypesValidator.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
  return virtualTypesValidator;
}
var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors) return visitors;
  hasRequiredVisitors = 1;
  Object.defineProperty(visitors, "__esModule", {
    value: true
  });
  visitors.environmentVisitor = environmentVisitor;
  visitors.explode = explode$1;
  visitors.isExplodedVisitor = isExplodedVisitor;
  visitors.merge = merge;
  visitors.verify = verify$1;
  var virtualTypes2 = requireVirtualTypes();
  var virtualTypesValidators = requireVirtualTypesValidator();
  var _t2 = requireLib$5();
  var _context = requireContext();
  const {
    DEPRECATED_KEYS,
    DEPRECATED_ALIASES,
    FLIPPED_ALIAS_KEYS,
    TYPES,
    __internal__deprecationWarning: deprecationWarning2
  } = _t2;
  function isVirtualType(type) {
    return type in virtualTypes2;
  }
  function isExplodedVisitor(visitor) {
    return visitor == null ? void 0 : visitor._exploded;
  }
  function explode$1(visitor) {
    if (isExplodedVisitor(visitor)) return visitor;
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const parts = nodeType.split("|");
      if (parts.length === 1) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const part of parts) {
        visitor[part] = fns;
      }
    }
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      if (!isVirtualType(nodeType)) continue;
      const fns = visitor[nodeType];
      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(nodeType, fns[type]);
      }
      delete visitor[nodeType];
      const types2 = virtualTypes2[nodeType];
      if (types2 !== null) {
        for (const type of types2) {
          var _visitor$type;
          (_visitor$type = visitor[type]) != null ? _visitor$type : visitor[type] = {};
          mergePair(visitor[type], fns);
        }
      } else {
        mergePair(visitor, fns);
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      let aliases = FLIPPED_ALIAS_KEYS[nodeType];
      if (nodeType in DEPRECATED_KEYS) {
        const deprecatedKey = DEPRECATED_KEYS[nodeType];
        deprecationWarning2(nodeType, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (nodeType in DEPRECATED_ALIASES) {
        const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
        deprecationWarning2(nodeType, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
      }
      if (!aliases) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const alias of aliases) {
        const existing = visitor[alias];
        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      ensureCallbackArrays(visitor[nodeType]);
    }
    return visitor;
  }
  function verify$1(visitor) {
    if (visitor._verified) return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    }
    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType)) continue;
      if (!TYPES.includes(nodeType)) {
        throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.28.5"}`);
      }
      const visitors2 = visitor[nodeType];
      if (typeof visitors2 === "object") {
        for (const visitorKey of Object.keys(visitors2)) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors2[visitorKey]);
          } else {
            throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path2, val) {
    const fns = [].concat(val);
    for (const fn2 of fns) {
      if (typeof fn2 !== "function") {
        throw new TypeError(`Non-function found defined in ${path2} with type ${typeof fn2}`);
      }
    }
  }
  function merge(visitors2, states = [], wrapper) {
    const mergedVisitor = {
      _verified: true,
      _exploded: true
    };
    {
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: false
      });
      Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: false
      });
    }
    for (let i = 0; i < visitors2.length; i++) {
      const visitor = explode$1(visitors2[i]);
      const state = states[i];
      let topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (const key of Object.keys(visitor)) {
        if (shouldIgnoreKey(key)) continue;
        let typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    for (const phase of ["enter", "exit"]) {
      let fns = oldVisitor[phase];
      if (!Array.isArray(fns)) continue;
      fns = fns.map(function(fn2) {
        let newFn = fn2;
        if (state) {
          newFn = function(path2) {
            fn2.call(state, path2, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
        }
        if (newFn !== fn2) {
          newFn.toString = () => fn2.toString();
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key)) continue;
      const fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }
  function wrapCheck(nodeType, fn2) {
    const fnKey = `is${nodeType}`;
    const validator = virtualTypesValidators[fnKey];
    const newFn = function(path2) {
      if (validator.call(path2)) {
        return fn2.apply(this, arguments);
      }
    };
    newFn.toString = () => fn2.toString();
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  }
  function mergePair(dest, src) {
    for (const phase of ["enter", "exit"]) {
      if (!src[phase]) continue;
      dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
  }
  const _environmentVisitor = {
    FunctionParent(path2) {
      if (path2.isArrowFunctionExpression()) return;
      path2.skip();
      if (path2.isMethod()) {
        if (!path2.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path2);
        } else {
          path2.requeueComputedKeyAndDecorators();
        }
      }
    },
    Property(path2) {
      if (path2.isObjectProperty()) return;
      path2.skip();
      if (!path2.requeueComputedKeyAndDecorators) {
        _context.requeueComputedKeyAndDecorators.call(path2);
      } else {
        path2.requeueComputedKeyAndDecorators();
      }
    }
  };
  function environmentVisitor(visitor) {
    return merge([_environmentVisitor, visitor]);
  }
  return visitors;
}
var hasRequiredRenamer;
function requireRenamer() {
  if (hasRequiredRenamer) return renamer;
  hasRequiredRenamer = 1;
  Object.defineProperty(renamer, "__esModule", {
    value: true
  });
  renamer.default = void 0;
  var t = requireLib$5();
  var _t2 = t;
  var _traverseNode = requireTraverseNode();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    getAssignmentIdentifiers: getAssignmentIdentifiers2
  } = _t2;
  const renameVisitor = {
    ReferencedIdentifier({
      node: node2
    }, state) {
      if (node2.name === state.oldName) {
        node2.name = state.newName;
      }
    },
    Scope(path2, state) {
      if (!path2.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path2.skip();
        if (path2.isMethod()) {
          if (!path2.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path2);
          } else {
            path2.requeueComputedKeyAndDecorators();
          }
        }
      }
    },
    ObjectProperty({
      node: node2,
      scope: scope2
    }, state) {
      const {
        name
      } = node2.key;
      if (node2.shorthand && (name === state.oldName || name === state.newName) && scope2.getBindingIdentifier(name) === state.binding.identifier) {
        node2.shorthand = false;
        {
          var _node$extra;
          if ((_node$extra = node2.extra) != null && _node$extra.shorthand) node2.extra.shorthand = false;
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(path2, state) {
      if (path2.isVariableDeclaration()) return;
      const ids = path2.isAssignmentExpression() ? getAssignmentIdentifiers2(path2.node) : path2.getOuterBindingIdentifiers();
      for (const name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };
  class Renamer {
    constructor(binding2, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding2;
    }
    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;
      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }
      if (maybeExportDeclar.isExportDefaultDeclaration()) {
        const {
          declaration
        } = maybeExportDeclar.node;
        if (t.isDeclaration(declaration) && !declaration.id) {
          return;
        }
      }
      if (maybeExportDeclar.isExportAllDeclaration()) {
        return;
      }
      maybeExportDeclar.splitExportDeclaration();
    }
    maybeConvertFromClassFunctionDeclaration(path2) {
      return path2;
    }
    maybeConvertFromClassFunctionExpression(path2) {
      return path2;
    }
    rename() {
      const {
        binding: binding2,
        oldName,
        newName
      } = this;
      const {
        scope: scope2,
        path: path2
      } = binding2;
      const parentDeclar = path2.find((path3) => path3.isDeclaration() || path3.isFunctionExpression() || path3.isClassExpression());
      if (parentDeclar) {
        const bindingIds = parentDeclar.getOuterBindingIdentifiers();
        if (bindingIds[oldName] === binding2.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }
      const blockToTraverse = arguments[0] || scope2.block;
      const skipKeys = {
        discriminant: true
      };
      if (t.isMethod(blockToTraverse)) {
        if (blockToTraverse.computed) {
          skipKeys.key = true;
        }
        if (!t.isObjectMethod(blockToTraverse)) {
          skipKeys.decorators = true;
        }
      }
      (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope2, this, scope2.path, skipKeys);
      if (!arguments[0]) {
        scope2.removeOwnBinding(oldName);
        scope2.bindings[newName] = binding2;
        this.binding.identifier.name = newName;
      }
      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(path2);
        this.maybeConvertFromClassFunctionExpression(path2);
      }
    }
  }
  renamer.default = Renamer;
  return renamer;
}
var traverseForScope = {};
var hasRequiredTraverseForScope;
function requireTraverseForScope() {
  if (hasRequiredTraverseForScope) return traverseForScope;
  hasRequiredTraverseForScope = 1;
  Object.defineProperty(traverseForScope, "__esModule", {
    value: true
  });
  traverseForScope.default = traverseForScope$1;
  var _t2 = requireLib$5();
  var _index = requireLib();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    VISITOR_KEYS
  } = _t2;
  function traverseForScope$1(path2, visitors2, state) {
    const exploded = (0, _visitors.explode)(visitors2);
    if (exploded.enter || exploded.exit) {
      throw new Error("Should not be used with enter/exit visitors.");
    }
    _traverse(path2.parentPath, path2.parent, path2.node, path2.container, path2.key, path2.listKey, path2.hub, path2);
    function _traverse(parentPath, parent, node2, container, key, listKey, hub2, inPath) {
      if (!node2) {
        return;
      }
      const path3 = inPath || _index.NodePath.get({
        hub: hub2,
        parentPath,
        parent,
        container,
        listKey,
        key
      });
      _context.setScope.call(path3);
      const visitor = exploded[node2.type];
      if (visitor) {
        if (visitor.enter) {
          for (const visit of visitor.enter) {
            visit.call(state, path3, state);
          }
        }
        if (visitor.exit) {
          for (const visit of visitor.exit) {
            visit.call(state, path3, state);
          }
        }
      }
      if (path3.shouldSkip) {
        return;
      }
      const keys = VISITOR_KEYS[node2.type];
      if (!(keys != null && keys.length)) {
        return;
      }
      for (const key2 of keys) {
        const prop = node2[key2];
        if (!prop) continue;
        if (Array.isArray(prop)) {
          for (let i = 0; i < prop.length; i++) {
            const value = prop[i];
            _traverse(path3, node2, value, prop, i, key2);
          }
        } else {
          _traverse(path3, node2, prop, node2, key2, null);
        }
      }
    }
  }
  return traverseForScope;
}
var binding = {};
var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding) return binding;
  hasRequiredBinding = 1;
  Object.defineProperty(binding, "__esModule", {
    value: true
  });
  binding.default = void 0;
  class Binding {
    constructor({
      identifier: identifier2,
      scope: scope2,
      path: path2,
      kind
    }) {
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier2;
      this.scope = scope2;
      this.path = path2;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isInitInLoop(path2)) {
        this.reassign(path2);
      }
      this.clearValue();
    }
    deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }
    setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    }
    clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }
    reassign(path2) {
      this.constant = false;
      if (this.constantViolations.includes(path2)) {
        return;
      }
      this.constantViolations.push(path2);
    }
    reference(path2) {
      if (this.referencePaths.includes(path2)) {
        return;
      }
      this.referenced = true;
      this.references++;
      this.referencePaths.push(path2);
    }
    dereference() {
      this.references--;
      this.referenced = !!this.references;
    }
  }
  binding.default = Binding;
  function isInitInLoop(path2) {
    const isFunctionDeclarationOrHasInit = !path2.isVariableDeclarator() || path2.node.init;
    for (let {
      parentPath,
      key
    } = path2; parentPath; {
      parentPath,
      key
    } = parentPath) {
      if (parentPath.isFunctionParent()) return false;
      if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop()) {
        return true;
      }
    }
    return false;
  }
  return binding;
}
var cache = {};
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  Object.defineProperty(cache, "__esModule", {
    value: true
  });
  cache.clear = clear;
  cache.clearPath = clearPath;
  cache.clearScope = clearScope;
  cache.getCachedPaths = getCachedPaths;
  cache.getOrCreateCachedPaths = getOrCreateCachedPaths;
  cache.scope = cache.path = void 0;
  let pathsCache = cache.path = /* @__PURE__ */ new WeakMap();
  cache.scope = /* @__PURE__ */ new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    cache.path = pathsCache = /* @__PURE__ */ new WeakMap();
  }
  function clearScope() {
    cache.scope = /* @__PURE__ */ new WeakMap();
  }
  function getCachedPaths(path2) {
    const {
      parent,
      parentPath
    } = path2;
    return pathsCache.get(parent);
  }
  function getOrCreateCachedPaths(node2, parentPath) {
    let paths = pathsCache.get(node2);
    if (!paths) pathsCache.set(node2, paths = /* @__PURE__ */ new Map());
    return paths;
  }
  return cache;
}
const require$$6 = [
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "eval",
  "globalThis",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "undefined",
  "unescape"
];
const require$$7 = [
  "AggregateError",
  "Array",
  "ArrayBuffer",
  "Atomics",
  "BigInt",
  "BigInt64Array",
  "BigUint64Array",
  "Boolean",
  "DataView",
  "Date",
  "Error",
  "EvalError",
  "FinalizationRegistry",
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Function",
  "Infinity",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Intl",
  "Iterator",
  "JSON",
  "Map",
  "Math",
  "NaN",
  "Number",
  "Object",
  "Promise",
  "Proxy",
  "RangeError",
  "ReferenceError",
  "Reflect",
  "RegExp",
  "Set",
  "SharedArrayBuffer",
  "String",
  "Symbol",
  "SyntaxError",
  "TypeError",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "URIError",
  "WeakMap",
  "WeakRef",
  "WeakSet"
];
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  Object.defineProperty(scope, "__esModule", {
    value: true
  });
  scope.default = void 0;
  var _renamer = requireRenamer();
  var _index = requireLib();
  requireTraverseForScope();
  var _binding = requireBinding();
  var _t2 = requireLib$5();
  var t = _t2;
  var _cache = requireCache();
  const globalsBuiltinLower = require$$6, globalsBuiltinUpper = require$$7;
  const {
    assignmentExpression,
    callExpression,
    cloneNode: cloneNode2,
    getBindingIdentifiers: getBindingIdentifiers2,
    identifier: identifier2,
    isArrayExpression,
    isBinary,
    isCallExpression,
    isClass,
    isClassBody,
    isClassDeclaration,
    isExportAllDeclaration,
    isExportDefaultDeclaration,
    isExportNamedDeclaration,
    isFunctionDeclaration,
    isIdentifier,
    isImportDeclaration,
    isLiteral,
    isMemberExpression,
    isMethod,
    isModuleSpecifier,
    isNullLiteral,
    isObjectExpression,
    isProperty,
    isPureish,
    isRegExpLiteral,
    isSuper,
    isTaggedTemplateExpression,
    isTemplateLiteral,
    isThisExpression,
    isUnaryExpression,
    isVariableDeclaration,
    expressionStatement,
    matchesPattern: matchesPattern2,
    memberExpression,
    numericLiteral,
    toIdentifier: toIdentifier2,
    variableDeclaration,
    variableDeclarator,
    isRecordExpression,
    isTupleExpression,
    isObjectProperty,
    isTopicReference,
    isMetaProperty,
    isPrivateName,
    isExportDeclaration,
    buildUndefinedNode,
    sequenceExpression
  } = _t2;
  function gatherNodeParts(node2, parts) {
    switch (node2 == null ? void 0 : node2.type) {
      default:
        if (isImportDeclaration(node2) || isExportDeclaration(node2)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node2) || isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && node2.source) {
            gatherNodeParts(node2.source, parts);
          } else if ((isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && (_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
            for (const e of node2.specifiers) gatherNodeParts(e, parts);
          } else if ((isExportDefaultDeclaration(node2) || isExportNamedDeclaration(node2)) && node2.declaration) {
            gatherNodeParts(node2.declaration, parts);
          }
        } else if (isModuleSpecifier(node2)) {
          gatherNodeParts(node2.local, parts);
        } else if (isLiteral(node2) && !isNullLiteral(node2) && !isRegExpLiteral(node2) && !isTemplateLiteral(node2)) {
          parts.push(node2.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node2.object, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node2.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node2.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const e of node2.properties) {
          gatherNodeParts(e, parts);
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node2.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node2.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
      case "ImportExpression":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node2.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node2.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node2.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node2.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node2.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node2.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node2.meta, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node2.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node2.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node2.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node2.namespace, parts);
        gatherNodeParts(node2.name, parts);
        break;
    }
  }
  function resetScope(scope2) {
    {
      scope2.references = /* @__PURE__ */ Object.create(null);
      scope2.uids = /* @__PURE__ */ Object.create(null);
    }
    scope2.bindings = /* @__PURE__ */ Object.create(null);
    scope2.globals = /* @__PURE__ */ Object.create(null);
  }
  function isAnonymousFunctionExpression(path2) {
    return path2.isFunctionExpression() && !path2.node.id || path2.isArrowFunctionExpression();
  }
  {
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
  const collectorVisitor = {
    ForStatement(path2) {
      const declar = path2.get("init");
      if (declar.isVar()) {
        const {
          scope: scope2
        } = path2;
        const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration(path2) {
      if (path2.isBlockScoped()) return;
      if (path2.isImportDeclaration()) return;
      if (path2.isExportDeclaration()) return;
      const parent = path2.scope.getFunctionParent() || path2.scope.getProgramParent();
      parent.registerDeclaration(path2);
    },
    ImportDeclaration(path2) {
      const parent = path2.scope.getBlockParent();
      parent.registerDeclaration(path2);
    },
    TSImportEqualsDeclaration(path2) {
      const parent = path2.scope.getBlockParent();
      parent.registerDeclaration(path2);
    },
    ReferencedIdentifier(path2, state) {
      if (t.isTSQualifiedName(path2.parent) && path2.parent.right === path2.node) {
        return;
      }
      if (path2.parentPath.isTSImportEqualsDeclaration()) return;
      state.references.push(path2);
    },
    ForXStatement(path2, state) {
      const left = path2.get("left");
      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path2);
      } else if (left.isVar()) {
        const {
          scope: scope2
        } = path2;
        const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
        parentScope.registerBinding("var", left);
      }
    },
    ExportDeclaration: {
      exit(path2) {
        const {
          node: node2,
          scope: scope2
        } = path2;
        if (isExportAllDeclaration(node2)) return;
        const declar = node2.declaration;
        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id) return;
          const binding2 = scope2.getBinding(id.name);
          binding2 == null || binding2.reference(path2);
        } else if (isVariableDeclaration(declar)) {
          for (const decl of declar.declarations) {
            for (const name of Object.keys(getBindingIdentifiers2(decl))) {
              const binding2 = scope2.getBinding(name);
              binding2 == null || binding2.reference(path2);
            }
          }
        }
      }
    },
    LabeledStatement(path2) {
      path2.scope.getBlockParent().registerDeclaration(path2);
    },
    AssignmentExpression(path2, state) {
      state.assignments.push(path2);
    },
    UpdateExpression(path2, state) {
      state.constantViolations.push(path2);
    },
    UnaryExpression(path2, state) {
      if (path2.node.operator === "delete") {
        state.constantViolations.push(path2);
      }
    },
    BlockScoped(path2) {
      let scope2 = path2.scope;
      if (scope2.path === path2) scope2 = scope2.parent;
      const parent = scope2.getBlockParent();
      parent.registerDeclaration(path2);
      if (path2.isClassDeclaration() && path2.node.id) {
        const id = path2.node.id;
        const name = id.name;
        path2.scope.bindings[name] = path2.scope.parent.getBinding(name);
      }
    },
    CatchClause(path2) {
      path2.scope.registerBinding("let", path2);
    },
    Function(path2) {
      const params = path2.get("params");
      for (const param of params) {
        path2.scope.registerBinding("param", param);
      }
      if (path2.isFunctionExpression() && path2.node.id && !path2.node.id[NOT_LOCAL_BINDING]) {
        path2.scope.registerBinding("local", path2.get("id"), path2);
      }
    },
    ClassExpression(path2) {
      if (path2.node.id && !path2.node.id[NOT_LOCAL_BINDING]) {
        path2.scope.registerBinding("local", path2.get("id"), path2);
      }
    },
    TSTypeAnnotation(path2) {
      path2.skip();
    }
  };
  let scopeVisitor;
  let uid = 0;
  class Scope {
    constructor(path2) {
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.inited = void 0;
      this.labels = void 0;
      this.bindings = void 0;
      this.referencesSet = void 0;
      this.globals = void 0;
      this.uidsSet = void 0;
      this.data = void 0;
      this.crawling = void 0;
      const {
        node: node2
      } = path2;
      const cached = _cache.scope.get(node2);
      if ((cached == null ? void 0 : cached.path) === path2) {
        return cached;
      }
      _cache.scope.set(node2, this);
      this.uid = uid++;
      this.block = node2;
      this.path = path2;
      this.labels = /* @__PURE__ */ new Map();
      this.inited = false;
      {
        Object.defineProperties(this, {
          references: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ Object.create(null)
          },
          uids: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ Object.create(null)
          }
        });
      }
    }
    get parent() {
      var _parent;
      let parent, path2 = this.path;
      do {
        var _path;
        const shouldSkip = path2.key === "key" || path2.listKey === "decorators";
        path2 = path2.parentPath;
        if (shouldSkip && path2.isMethod()) path2 = path2.parentPath;
        if ((_path = path2) != null && _path.isScope()) parent = path2;
      } while (path2 && !parent);
      return (_parent = parent) == null ? void 0 : _parent.scope;
    }
    get references() {
      throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
    }
    get uids() {
      throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
    }
    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      this.push({
        id
      });
      return cloneNode2(id);
    }
    generateUidIdentifier(name) {
      return identifier2(this.generateUid(name));
    }
    generateUid(name = "temp") {
      name = toIdentifier2(name).replace(/^_+/, "").replace(/\d+$/g, "");
      let uid2;
      let i = 0;
      do {
        uid2 = `_${name}`;
        if (i >= 11) uid2 += i - 1;
        else if (i >= 9) uid2 += i - 9;
        else if (i >= 1) uid2 += i + 1;
        i++;
      } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
      const program = this.getProgramParent();
      {
        program.references[uid2] = true;
        program.uids[uid2] = true;
      }
      return uid2;
    }
    generateUidBasedOnNode(node2, defaultName) {
      const parts = [];
      gatherNodeParts(node2, parts);
      let id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(node2, defaultName) {
      return identifier2(this.generateUidBasedOnNode(node2, defaultName));
    }
    isStatic(node2) {
      if (isThisExpression(node2) || isSuper(node2) || isTopicReference(node2)) {
        return true;
      }
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (binding2) {
          return binding2.constant;
        } else {
          return this.hasBinding(node2.name);
        }
      }
      return false;
    }
    maybeGenerateMemoised(node2, dontPush) {
      if (this.isStatic(node2)) {
        return null;
      } else {
        const id = this.generateUidIdentifierBasedOnNode(node2);
        if (!dontPush) {
          this.push({
            id
          });
          return cloneNode2(id);
        }
        return id;
      }
    }
    checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
      if (duplicate) {
        throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
    }
    rename(oldName, newName) {
      const binding2 = this.getBinding(oldName);
      if (binding2) {
        newName || (newName = this.generateUidIdentifier(oldName).name);
        const renamer2 = new _renamer.default(binding2, oldName, newName);
        {
          renamer2.rename(arguments[2]);
        }
      }
    }
    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope2 = this;
      do {
        console.log("#", scope2.block.type);
        for (const name of Object.keys(scope2.bindings)) {
          const binding2 = scope2.bindings[name];
          console.log(" -", name, {
            constant: binding2.constant,
            references: binding2.references,
            violations: binding2.constantViolations.length,
            kind: binding2.kind
          });
        }
      } while (scope2 = scope2.parent);
      console.log(sep);
    }
    hasLabel(name) {
      return !!this.getLabel(name);
    }
    getLabel(name) {
      return this.labels.get(name);
    }
    registerLabel(path2) {
      this.labels.set(path2.node.label.name, path2);
    }
    registerDeclaration(path2) {
      if (path2.isLabeledStatement()) {
        this.registerLabel(path2);
      } else if (path2.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path2.get("id"), path2);
      } else if (path2.isVariableDeclaration()) {
        const declarations = path2.get("declarations");
        const {
          kind
        } = path2.node;
        for (const declar of declarations) {
          this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        }
      } else if (path2.isClassDeclaration()) {
        if (path2.node.declare) return;
        this.registerBinding("let", path2);
      } else if (path2.isImportDeclaration()) {
        const isTypeDeclaration = path2.node.importKind === "type" || path2.node.importKind === "typeof";
        const specifiers = path2.get("specifiers");
        for (const specifier of specifiers) {
          const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
          this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
        }
      } else if (path2.isExportDeclaration()) {
        const declar = path2.get("declaration");
        if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
          this.registerDeclaration(declar);
        }
      } else {
        this.registerBinding("unknown", path2);
      }
    }
    buildUndefinedNode() {
      return buildUndefinedNode();
    }
    registerConstantViolation(path2) {
      const ids = path2.getAssignmentIdentifiers();
      for (const name of Object.keys(ids)) {
        var _this$getBinding;
        (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path2);
      }
    }
    registerBinding(kind, path2, bindingPath = path2) {
      if (!kind) throw new ReferenceError("no `kind`");
      if (path2.isVariableDeclaration()) {
        const declarators = path2.get("declarations");
        for (const declar of declarators) {
          this.registerBinding(kind, declar);
        }
        return;
      }
      const parent = this.getProgramParent();
      const ids = path2.getOuterBindingIdentifiers(true);
      for (const name of Object.keys(ids)) {
        {
          parent.references[name] = true;
        }
        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          if (local) {
            local.reassign(bindingPath);
          } else {
            this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }
    }
    addGlobal(node2) {
      this.globals[node2.name] = node2;
    }
    hasUid(name) {
      {
        let scope2 = this;
        do {
          if (scope2.uids[name]) return true;
        } while (scope2 = scope2.parent);
        return false;
      }
    }
    hasGlobal(name) {
      let scope2 = this;
      do {
        if (scope2.globals[name]) return true;
      } while (scope2 = scope2.parent);
      return false;
    }
    hasReference(name) {
      {
        return !!this.getProgramParent().references[name];
      }
    }
    isPure(node2, constantsOnly) {
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (!binding2) return false;
        if (constantsOnly) return binding2.constant;
        return true;
      } else if (isThisExpression(node2) || isMetaProperty(node2) || isTopicReference(node2) || isPrivateName(node2)) {
        return true;
      } else if (isClass(node2)) {
        var _node$decorators;
        if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
          return false;
        }
        if (((_node$decorators = node2.decorators) == null ? void 0 : _node$decorators.length) > 0) {
          return false;
        }
        return this.isPure(node2.body, constantsOnly);
      } else if (isClassBody(node2)) {
        for (const method of node2.body) {
          if (!this.isPure(method, constantsOnly)) return false;
        }
        return true;
      } else if (isBinary(node2)) {
        return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly);
      } else if (isArrayExpression(node2) || isTupleExpression(node2)) {
        for (const elem of node2.elements) {
          if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
        }
        return true;
      } else if (isObjectExpression(node2) || isRecordExpression(node2)) {
        for (const prop of node2.properties) {
          if (!this.isPure(prop, constantsOnly)) return false;
        }
        return true;
      } else if (isMethod(node2)) {
        var _node$decorators2;
        if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false;
        if (((_node$decorators2 = node2.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
          return false;
        }
        return true;
      } else if (isProperty(node2)) {
        var _node$decorators3;
        if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false;
        if (((_node$decorators3 = node2.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
          return false;
        }
        if (isObjectProperty(node2) || node2.static) {
          if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
            return false;
          }
        }
        return true;
      } else if (isUnaryExpression(node2)) {
        return this.isPure(node2.argument, constantsOnly);
      } else if (isTemplateLiteral(node2)) {
        for (const expression of node2.expressions) {
          if (!this.isPure(expression, constantsOnly)) return false;
        }
        return true;
      } else if (isTaggedTemplateExpression(node2)) {
        return matchesPattern2(node2.tag, "String.raw") && !this.hasBinding("String", {
          noGlobals: true
        }) && this.isPure(node2.quasi, constantsOnly);
      } else if (isMemberExpression(node2)) {
        return !node2.computed && isIdentifier(node2.object) && node2.object.name === "Symbol" && isIdentifier(node2.property) && node2.property.name !== "for" && !this.hasBinding("Symbol", {
          noGlobals: true
        });
      } else if (isCallExpression(node2)) {
        return matchesPattern2(node2.callee, "Symbol.for") && !this.hasBinding("Symbol", {
          noGlobals: true
        }) && node2.arguments.length === 1 && t.isStringLiteral(node2.arguments[0]);
      } else {
        return isPureish(node2);
      }
    }
    setData(key, val) {
      return this.data[key] = val;
    }
    getData(key) {
      let scope2 = this;
      do {
        const data = scope2.data[key];
        if (data != null) return data;
      } while (scope2 = scope2.parent);
    }
    removeData(key) {
      let scope2 = this;
      do {
        const data = scope2.data[key];
        if (data != null) scope2.data[key] = null;
      } while (scope2 = scope2.parent);
    }
    init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }
    crawl() {
      const path2 = this.path;
      resetScope(this);
      this.data = /* @__PURE__ */ Object.create(null);
      let scope2 = this;
      do {
        if (scope2.crawling) return;
        if (scope2.path.isProgram()) {
          break;
        }
      } while (scope2 = scope2.parent);
      const programParent = scope2;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
        Scope(path3) {
          resetScope(path3.scope);
        }
      }, collectorVisitor]));
      if (path2.type !== "Program") {
        const typeVisitors = scopeVisitor[path2.type];
        if (typeVisitors) {
          for (const visit of typeVisitors.enter) {
            visit.call(state, path2, state);
          }
        }
      }
      {
        path2.traverse(scopeVisitor, state);
      }
      this.crawling = false;
      for (const path3 of state.assignments) {
        const ids = path3.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          if (path3.scope.getBinding(name)) continue;
          programParent.addGlobal(ids[name]);
        }
        path3.scope.registerConstantViolation(path3);
      }
      for (const ref of state.references) {
        const binding2 = ref.scope.getBinding(ref.node.name);
        if (binding2) {
          binding2.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }
      for (const path3 of state.constantViolations) {
        path3.scope.registerConstantViolation(path3);
      }
    }
    push(opts) {
      let path2 = this.path;
      if (path2.isPattern()) {
        path2 = this.getPatternParent().path;
      } else if (!path2.isBlockStatement() && !path2.isProgram()) {
        path2 = this.getBlockParent().path;
      }
      if (path2.isSwitchStatement()) {
        path2 = (this.getFunctionParent() || this.getProgramParent()).path;
      }
      const {
        init,
        unique,
        kind = "var",
        id
      } = opts;
      if (!init && !unique && (kind === "var" || kind === "let") && isAnonymousFunctionExpression(path2) && isCallExpression(path2.parent, {
        callee: path2.node
      }) && path2.parent.arguments.length <= path2.node.params.length && isIdentifier(id)) {
        path2.pushContainer("params", id);
        path2.scope.registerBinding("param", path2.get("params")[path2.node.params.length - 1]);
        return;
      }
      if (path2.isLoop() || path2.isCatchClause() || path2.isFunction()) {
        path2.ensureBlock();
        path2 = path2.get("body");
      }
      const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      const dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path2.getData(dataKey);
      if (!declarPath) {
        const declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;
        [declarPath] = path2.unshiftContainer("body", [declar]);
        if (!unique) path2.setData(dataKey, declarPath);
      }
      const declarator = variableDeclarator(id, init);
      const len = declarPath.node.declarations.push(declarator);
      path2.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    }
    getProgramParent() {
      let scope2 = this;
      do {
        if (scope2.path.isProgram()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let scope2 = this;
      do {
        if (scope2.path.isFunctionParent()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      return null;
    }
    getBlockParent() {
      let scope2 = this;
      do {
        if (scope2.path.isBlockParent()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let scope2 = this;
      do {
        if (!scope2.path.isPattern()) {
          return scope2.getBlockParent();
        }
      } while (scope2 = scope2.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const ids = /* @__PURE__ */ Object.create(null);
      let scope2 = this;
      do {
        for (const key of Object.keys(scope2.bindings)) {
          if (key in ids === false) {
            ids[key] = scope2.bindings[key];
          }
        }
        scope2 = scope2.parent;
      } while (scope2);
      return ids;
    }
    bindingIdentifierEquals(name, node2) {
      return this.getBindingIdentifier(name) === node2;
    }
    getBinding(name) {
      let scope2 = this;
      let previousPath;
      do {
        const binding2 = scope2.getOwnBinding(name);
        if (binding2) {
          var _previousPath;
          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding2.kind !== "param" && binding2.kind !== "local") ;
          else {
            return binding2;
          }
        } else if (!binding2 && name === "arguments" && scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
          break;
        }
        previousPath = scope2.path;
      } while (scope2 = scope2.parent);
    }
    getOwnBinding(name) {
      return this.bindings[name];
    }
    getBindingIdentifier(name) {
      var _this$getBinding2;
      return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
    }
    getOwnBindingIdentifier(name) {
      const binding2 = this.bindings[name];
      return binding2 == null ? void 0 : binding2.identifier;
    }
    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
    hasBinding(name, opts) {
      if (!name) return false;
      let noGlobals;
      let noUids;
      let upToScope;
      if (typeof opts === "object") {
        noGlobals = opts.noGlobals;
        noUids = opts.noUids;
        upToScope = opts.upToScope;
      } else if (typeof opts === "boolean") {
        noGlobals = opts;
      }
      let scope2 = this;
      do {
        if (upToScope === scope2) {
          break;
        }
        if (scope2.hasOwnBinding(name)) {
          return true;
        }
      } while (scope2 = scope2.parent);
      if (!noUids && this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    }
    parentHasBinding(name, opts) {
      var _this$parent;
      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
    }
    moveBindingTo(name, scope2) {
      const info = this.getBinding(name);
      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope2;
        scope2.bindings[name] = info;
      }
    }
    removeOwnBinding(name) {
      delete this.bindings[name];
    }
    removeBinding(name) {
      var _this$getBinding3;
      (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
      {
        let scope2 = this;
        do {
          if (scope2.uids[name]) {
            scope2.uids[name] = false;
          }
        } while (scope2 = scope2.parent);
      }
    }
    hoistVariables(emit = (id) => this.push({
      id
    })) {
      this.crawl();
      const seen = /* @__PURE__ */ new Set();
      for (const name of Object.keys(this.bindings)) {
        const binding2 = this.bindings[name];
        if (!binding2) continue;
        const {
          path: path2
        } = binding2;
        if (!path2.isVariableDeclarator()) continue;
        const {
          parent,
          parentPath
        } = path2;
        if (parent.kind !== "var" || seen.has(parent)) continue;
        seen.add(path2.parent);
        let firstId;
        const init = [];
        for (const decl of parent.declarations) {
          firstId != null ? firstId : firstId = decl.id;
          if (decl.init) {
            init.push(assignmentExpression("=", decl.id, decl.init));
          }
          const ids = Object.keys(getBindingIdentifiers2(decl, false, true, true));
          for (const name2 of ids) {
            emit(identifier2(name2), decl.init != null);
          }
        }
        if (parentPath.parentPath.isForXStatement({
          left: parent
        })) {
          parentPath.replaceWith(firstId);
        } else if (init.length === 0) {
          parentPath.remove();
        } else {
          const expr = init.length === 1 ? init[0] : sequenceExpression(init);
          if (parentPath.parentPath.isForStatement({
            init: parent
          })) {
            parentPath.replaceWith(expr);
          } else {
            parentPath.replaceWith(expressionStatement(expr));
          }
        }
      }
    }
  }
  scope.default = Scope;
  Scope.globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  {
    Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };
    Scope.prototype.traverse = function(node2, opts, state) {
      (0, _index.default)(node2, opts, this, state, this.path);
    };
    Scope.prototype._generateUid = function _generateUid(name, i) {
      let id = name;
      if (i > 1) id += i;
      return `_${id}`;
    };
    Scope.prototype.toArray = function toArray(node2, i, arrayLikeIsIterable) {
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (binding2 != null && binding2.constant && binding2.path.isGenericType("Array")) {
          return node2;
        }
      }
      if (isArrayExpression(node2)) {
        return node2;
      }
      if (isIdentifier(node2, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier2("Array"), identifier2("prototype")), identifier2("slice")), identifier2("call")), [node2]);
      }
      let helperName;
      const args = [node2];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression(this.path.hub.addHelper(helperName), args);
    };
    Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
      const ids = /* @__PURE__ */ Object.create(null);
      for (const kind of kinds) {
        let scope2 = this;
        do {
          for (const name of Object.keys(scope2.bindings)) {
            const binding2 = scope2.bindings[name];
            if (binding2.kind === kind) ids[name] = binding2;
          }
          scope2 = scope2.parent;
        } while (scope2);
      }
      return ids;
    };
    Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.hub;
        }
      }
    });
  }
  return scope;
}
var lib$3 = {};
var sourceMap = {};
var genMapping_umd$1 = { exports: {} };
var sourcemapCodec_umd$1 = { exports: {} };
var sourcemapCodec_umd = sourcemapCodec_umd$1.exports;
var hasRequiredSourcemapCodec_umd;
function requireSourcemapCodec_umd() {
  if (hasRequiredSourcemapCodec_umd) return sourcemapCodec_umd$1.exports;
  hasRequiredSourcemapCodec_umd = 1;
  (function(module2, exports$1) {
    (function(global2, factory) {
      {
        factory(module2);
        module2.exports = def(module2);
      }
      function def(m2) {
        return "default" in m2.exports ? m2.exports.default : m2.exports;
      }
    })(sourcemapCodec_umd, function(module3) {
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to2, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to2, key) && key !== except)
              __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to2;
      };
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var sourcemap_codec_exports = {};
      __export(sourcemap_codec_exports, {
        decode: () => decode,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      });
      module3.exports = __toCommonJS(sourcemap_codec_exports);
      var comma = ",".charCodeAt(0);
      var semicolon = ";".charCodeAt(0);
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var intToChar = new Uint8Array(64);
      var charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c2 = reader.next();
          integer = charToInt[c2];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder2, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0) clamped |= 32;
          builder2.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max) return false;
        return reader.peek() !== comma;
      }
      var bufLength = 1024 * 16;
      var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      var StringWriter = class {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v2) {
          const { buffer: buffer2 } = this;
          buffer2[this.pos++] = v2;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer2);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer: buffer2, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer2.subarray(0, pos)) : out;
        }
      };
      var StringReader = class {
        constructor(buffer2) {
          this.pos = 0;
          this.buffer = buffer2;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer: buffer2, pos } = this;
          const idx = buffer2.indexOf(char, pos);
          return idx === -1 ? buffer2.length : idx;
        }
      };
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope2 = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope2.vars = vars;
          scopes.push(scope2);
          stack.push(scope2);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope2 = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope2;
        if (index > 0) writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope2.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope2.length === 6) encodeInteger(writer, scope2[5], 0);
        for (const v2 of vars) {
          encodeInteger(writer, v2, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l2, 1: c2 } = next;
          if (l2 > endLine || l2 === endLine && c2 >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(
                reader,
                definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0
              );
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(
                reader,
                sameSource && prevLine === callsiteLine ? callsiteColumn : 0
              );
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope: isScope2,
          callsite,
          bindings
        } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope2 ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding2 of bindings) {
            if (binding2.length > 1) encodeInteger(writer, -binding2.length, 0);
            const expression = binding2[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding2.length; i++) {
              const expRange = binding2[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l2, 1: c2 } = next;
          if (l2 > endLine || l2 === endLine && c2 >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted) sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a2, b2) {
        return a2[0] - b2[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) writer.write(semicolon);
          if (line.length === 0) continue;
          let genColumn = 0;
          for (let j2 = 0; j2 < line.length; j2++) {
            const segment = line[j2];
            if (j2 > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
    });
  })(sourcemapCodec_umd$1);
  return sourcemapCodec_umd$1.exports;
}
var traceMapping_umd$1 = { exports: {} };
var resolveUri_umd$1 = { exports: {} };
var resolveUri_umd = resolveUri_umd$1.exports;
var hasRequiredResolveUri_umd;
function requireResolveUri_umd() {
  if (hasRequiredResolveUri_umd) return resolveUri_umd$1.exports;
  hasRequiredResolveUri_umd = 1;
  (function(module2, exports$1) {
    (function(global2, factory) {
      module2.exports = factory();
    })(resolveUri_umd, function() {
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path2 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path2) ? path2 : "/" + path2, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path2, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path2,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path2) {
        if (path2.endsWith("/.."))
          return path2;
        const index = path2.lastIndexOf("/");
        return path2.slice(0, index + 1);
      }
      function mergePaths(url, base2) {
        normalizePath(base2, base2.type);
        if (url.path === "/") {
          url.path = base2.path;
        } else {
          url.path = stripPathFilename(base2.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path2 = "";
        for (let i = 1; i < pointer; i++) {
          path2 += "/" + pieces[i];
        }
        if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
          path2 += "/";
        }
        url.path = path2;
      }
      function resolve(input, base2) {
        if (!input && !base2)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base2 && inputType !== 7) {
          const baseUrl = parseUrl(base2);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path2 = url.path.slice(1);
            if (!path2)
              return queryHash || ".";
            if (isRelative(base2 || input) && !isRelative(path2)) {
              return "./" + path2 + queryHash;
            }
            return path2 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  })(resolveUri_umd$1);
  return resolveUri_umd$1.exports;
}
var traceMapping_umd = traceMapping_umd$1.exports;
var hasRequiredTraceMapping_umd;
function requireTraceMapping_umd() {
  if (hasRequiredTraceMapping_umd) return traceMapping_umd$1.exports;
  hasRequiredTraceMapping_umd = 1;
  (function(module2, exports$1) {
    (function(global2, factory) {
      {
        factory(module2, requireResolveUri_umd(), requireSourcemapCodec_umd());
        module2.exports = def(module2);
      }
      function def(m2) {
        return "default" in m2.exports ? m2.exports.default : m2.exports;
      }
    })(traceMapping_umd, function(module3, require_resolveURI, require_sourcemapCodec) {
      var __create = Object.create;
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to2, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to2, key) && key !== except)
              __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to2;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS({
        "umd:@jridgewell/sourcemap-codec"(exports$12, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_resolve_uri = __commonJS({
        "umd:@jridgewell/resolve-uri"(exports$12, module22) {
          module22.exports = require_resolveURI;
        }
      });
      var trace_mapping_exports = {};
      __export(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      });
      module3.exports = __toCommonJS(trace_mapping_exports);
      var import_sourcemap_codec = __toESM(require_sourcemap_codec());
      var import_resolve_uri = __toESM(require_resolve_uri());
      function stripFilename(path2) {
        if (!path2) return "";
        const index = path2.lastIndexOf("/");
        return path2.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        const from = stripFilename(mapUrl);
        const prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        if (!owned) mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j2 = 1; j2 < line.length; j2++) {
          if (line[j2][COLUMN] < line[j2 - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a2, b2) {
        return a2[COLUMN] - b2[COLUMN];
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(() => []);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const source = sources[sourceIndex2];
            const segs = source[sourceLine] || (source[sourceLine] = []);
            segs.push([sourceColumn, i, seg[COLUMN]]);
          }
        }
        for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          for (let j2 = 0; j2 < source.length; j2++) {
            const line = source[j2];
            if (line) line.sort(sortComparator);
          }
        }
        return sources;
      }
      var found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function parse2(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        const parsed = parse2(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(
          parsed,
          mapUrl,
          mappings,
          sources,
          sourcesContent,
          names,
          ignoreList,
          0,
          0,
          Infinity,
          Infinity
        );
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl2 = stopLine;
          let sc2 = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl2 = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl2 === stopLine) {
              sc2 = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl2 < stopLine) {
              sc2 = columnOffset + nextOffset.column;
            }
          }
          addSection(
            map,
            mapUrl,
            mappings,
            sources,
            sourcesContent,
            names,
            ignoreList,
            lineOffset + offset.line,
            columnOffset + offset.column,
            sl2,
            sc2
          );
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse2(input);
        if ("sections" in parsed) return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents) append(sourcesContent, contents);
        else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);
        if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine) return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(
              seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]
            );
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++) arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++) arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = class {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo) return map;
          const parsed = parse2(map);
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
          } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a2, _b;
        return (_b = (_a2 = cast(map))._encoded) != null ? _b : _a2._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a2;
        return (_a2 = cast(map))._decoded || (_a2._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          GREATEST_LOWER_BOUND
        );
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          bias || GREATEST_LOWER_BOUND
        );
        if (index === -1) return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(
          resolvedSources[segment[SOURCES_INDEX]],
          segment[SOURCE_LINE] + 1,
          segment[SOURCE_COLUMN],
          segment.length === 5 ? names[segment[NAMES_INDEX]] : null
        );
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1) index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null) return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null) return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone2(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone2(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone2(map, encodedMappings(map));
      }
      function clone2(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND) min++;
        if (min === -1 || min === segments.length) return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found) min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a2, _b;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
        const bySourceMemos = (_a2 = cast(map))._bySourceMemos || (_a2._bySourceMemos = sources.map(memoizedState));
        const generated2 = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));
        const segments = generated2[sourceIndex2][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        const memo = bySourceMemos[sourceIndex2];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    });
  })(traceMapping_umd$1);
  return traceMapping_umd$1.exports;
}
var genMapping_umd = genMapping_umd$1.exports;
var hasRequiredGenMapping_umd;
function requireGenMapping_umd() {
  if (hasRequiredGenMapping_umd) return genMapping_umd$1.exports;
  hasRequiredGenMapping_umd = 1;
  (function(module2, exports$1) {
    (function(global2, factory) {
      {
        factory(module2, requireSourcemapCodec_umd(), requireTraceMapping_umd());
        module2.exports = def(module2);
      }
      function def(m2) {
        return "default" in m2.exports ? m2.exports.default : m2.exports;
      }
    })(genMapping_umd, function(module3, require_sourcemapCodec, require_traceMapping) {
      var __create = Object.create;
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to2, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to2, key) && key !== except)
              __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to2;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS({
        "umd:@jridgewell/sourcemap-codec"(exports$12, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_trace_mapping = __commonJS({
        "umd:@jridgewell/trace-mapping"(exports$12, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var gen_mapping_exports = {};
      __export(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      });
      module3.exports = __toCommonJS(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0) return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key);
        return indexes[key] = length - 1;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0) return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k2 = array[i];
          array[i - 1] = k2;
          indexes[k2]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      var import_sourcemap_codec = __toESM(require_sourcemap_codec());
      var import_trace_mapping = __toESM(require_trace_mapping());
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      var GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray();
          this._sources = new SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(
          false,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name,
          content
        );
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(
          true,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name,
          content
        );
      };
      var maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        if (index === sourcesContent.length) sourcesContent[index] = null;
        if (ignore) put(ignoreList, index);
        else remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
          // _generatedRanges: generatedRanges,
        } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          // originalScopes,
          // generatedRanges,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
          // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
          mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        const map = new import_trace_mapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
        if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            const generated2 = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated: generated2, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
          // _originalScopes: originalScopes,
        } = cast2(map);
        const line = getIndex(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index)) return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = put(sources, source);
        const namesIndex = name ? put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(
          line,
          index,
          name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
        );
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++) {
          arr[i] = [];
        }
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN]) break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0) break;
        }
        if (len < length) mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++) put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0) return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0) return false;
        const prev = line[index - 1];
        if (prev.length === 1) return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated: generated2, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(
            skipable,
            map,
            generated2.line - 1,
            generated2.column,
            null,
            null,
            null,
            null,
            null
          );
        }
        return addSegmentInternal(
          skipable,
          map,
          generated2.line - 1,
          generated2.column,
          source,
          original.line - 1,
          original.column,
          name,
          content
        );
      }
    });
  })(genMapping_umd$1);
  return genMapping_umd$1.exports;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  Object.defineProperty(sourceMap, "__esModule", {
    value: true
  });
  sourceMap.default = void 0;
  var _genMapping = requireGenMapping_umd();
  var _traceMapping = requireTraceMapping_umd();
  class SourceMap {
    constructor(opts, code) {
      var _opts$sourceFileName;
      this._map = void 0;
      this._rawMappings = void 0;
      this._sourceFileName = void 0;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = null;
      const map = this._map = new _genMapping.GenMapping({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = void 0;
      if (opts.inputSourceMap) {
        this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
        const resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (let i = 0; i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
      } else if (typeof code === "object") {
        for (const sourceFileName of Object.keys(code)) {
          (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    get() {
      return (0, _genMapping.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, _genMapping.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
    }
    mark(generated2, line, column, identifierName, identifierNamePos, filename) {
      var _originalMapping;
      this._rawMappings = void 0;
      let originalMapping;
      if (line != null) {
        if (this._inputMap) {
          originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
            line,
            column
          });
          if (!originalMapping.name && identifierNamePos) {
            const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
            if (originalIdentifierMapping.name) {
              identifierName = originalIdentifierMapping.name;
            }
          }
        } else {
          originalMapping = {
            name: null,
            source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            line,
            column
          };
        }
      }
      (0, _genMapping.maybeAddMapping)(this._map, {
        name: identifierName,
        generated: generated2,
        source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
        original: originalMapping
      });
    }
  }
  sourceMap.default = SourceMap;
  return sourceMap;
}
var printer$2 = {};
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", {
    value: true
  });
  buffer.default = void 0;
  class Buffer2 {
    constructor(map, indentChar) {
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      };
      this._map = map;
      this._indentChar = indentChar;
      for (let i = 0; i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    _allocQueue() {
      const queue = this._queue;
      for (let i = 0; i < 16; i++) {
        queue.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
      }
    }
    _pushQueue(char, repeat, line, column, filename) {
      const cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      const item = this._queue[cursor];
      item.char = char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const map = this._map;
      const result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? void 0 : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          const resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value) {
          Object.defineProperty(result, "map", {
            value,
            writable: true
          });
        },
        get rawMappings() {
          const mappings = map == null ? void 0 : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value,
            writable: true
          });
        }
      };
      return result;
    }
    append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    }
    appendChar(char) {
      this._flush();
      this._appendChar(char, 1, this._sourcePosition);
    }
    queue(char) {
      if (char === 10) {
        while (this._queueCursor !== 0) {
          const char2 = this._queue[this._queueCursor - 1].char;
          if (char2 !== 32 && char2 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      const sourcePosition = this._sourcePosition;
      this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    queueIndentation(repeat) {
      if (repeat === 0) return;
      this._pushQueue(-1, repeat, void 0, void 0, void 0);
    }
    _flush() {
      const queueCursor = this._queueCursor;
      const queue = this._queue;
      for (let i = 0; i < queueCursor; i++) {
        const item = queue[i];
        this._appendChar(item.char, item.repeat, item);
      }
      this._queueCursor = 0;
    }
    _appendChar(char, repeat, sourcePos) {
      this._last = char;
      if (char === -1) {
        const fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== void 0) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
      }
      if (char !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
    }
    _append(str, sourcePos, maybeNewline) {
      const len = str.length;
      const position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      const {
        column,
        identifierName,
        identifierNamePos,
        filename
      } = sourcePos;
      let line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
      let i = str.indexOf("\n");
      let last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== void 0) {
          this._mark(++line, 0, void 0, void 0, filename);
        }
        i = str.indexOf("\n", last);
      }
      position.column += len - last;
    }
    _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    removeTrailingNewline() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
        this._queueCursor--;
      }
    }
    removeLastSemicolon() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
        this._queueCursor--;
      }
    }
    getLastChar() {
      const queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    getNewlineCount() {
      const queueCursor = this._queueCursor;
      let count = 0;
      if (queueCursor === 0) return this._last === 10 ? 1 : 0;
      for (let i = queueCursor - 1; i >= 0; i--) {
        if (this._queue[i].char !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    endsWithCharAndNewline() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        const lastCp = queue[queueCursor - 1].char;
        if (lastCp !== 10) return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2].char;
        } else {
          return this._last;
        }
      }
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      const identifierName = loc.identifierName;
      const sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
      this.source("end", loc);
    }
    source(prop, loc) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, 0);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, columnOffset);
    }
    _normalizePosition(prop, loc, columnOffset) {
      const pos = loc[prop];
      const target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    }
    getCurrentColumn() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      let lastIndex = -1;
      let len = 0;
      for (let i = 0; i < queueCursor; i++) {
        const item = queue[i];
        if (item.char === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    getCurrentLine() {
      let count = 0;
      const queue = this._queue;
      for (let i = 0; i < this._queueCursor; i++) {
        if (queue[i].char === 10) {
          count++;
        }
      }
      return this._position.line + count;
    }
  }
  buffer.default = Buffer2;
  return buffer;
}
var node = {};
var whitespace = {};
var hasRequiredWhitespace;
function requireWhitespace() {
  if (hasRequiredWhitespace) return whitespace;
  hasRequiredWhitespace = 1;
  Object.defineProperty(whitespace, "__esModule", {
    value: true
  });
  whitespace.nodes = void 0;
  var _t2 = requireLib$5();
  const {
    FLIPPED_ALIAS_KEYS,
    isArrayExpression,
    isAssignmentExpression,
    isBinary,
    isBlockStatement,
    isCallExpression,
    isFunction,
    isIdentifier,
    isLiteral,
    isMemberExpression,
    isObjectExpression,
    isOptionalCallExpression,
    isOptionalMemberExpression,
    isStringLiteral
  } = _t2;
  function crawlInternal(node2, state) {
    if (!node2) return state;
    if (isMemberExpression(node2) || isOptionalMemberExpression(node2)) {
      crawlInternal(node2.object, state);
      if (node2.computed) crawlInternal(node2.property, state);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      crawlInternal(node2.left, state);
      crawlInternal(node2.right, state);
    } else if (isCallExpression(node2) || isOptionalCallExpression(node2)) {
      state.hasCall = true;
      crawlInternal(node2.callee, state);
    } else if (isFunction(node2)) {
      state.hasFunction = true;
    } else if (isIdentifier(node2)) {
      state.hasHelper = state.hasHelper || node2.callee && isHelper(node2.callee);
    }
    return state;
  }
  function crawl(node2) {
    return crawlInternal(node2, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function isHelper(node2) {
    if (!node2) return false;
    if (isMemberExpression(node2)) {
      return isHelper(node2.object) || isHelper(node2.property);
    } else if (isIdentifier(node2)) {
      return node2.name === "require" || node2.name.charCodeAt(0) === 95;
    } else if (isCallExpression(node2)) {
      return isHelper(node2.callee);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      return isIdentifier(node2.left) && isHelper(node2.left) || isHelper(node2.right);
    } else {
      return false;
    }
  }
  function isType2(node2) {
    return isLiteral(node2) || isObjectExpression(node2) || isArrayExpression(node2) || isIdentifier(node2) || isMemberExpression(node2);
  }
  const nodes = whitespace.nodes = {
    AssignmentExpression(node2) {
      const state = crawl(node2.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
      return 0;
    },
    SwitchCase(node2, parent) {
      return (!!node2.consequent.length || parent.cases[0] === node2 ? 1 : 0) | (!node2.consequent.length && parent.cases[parent.cases.length - 1] === node2 ? 2 : 0);
    },
    LogicalExpression(node2) {
      if (isFunction(node2.left) || isFunction(node2.right)) {
        return 2;
      }
      return 0;
    },
    Literal(node2) {
      if (isStringLiteral(node2) && node2.value === "use strict") {
        return 2;
      }
      return 0;
    },
    CallExpression(node2) {
      if (isFunction(node2.callee) || isHelper(node2)) {
        return 1 | 2;
      }
      return 0;
    },
    OptionalCallExpression(node2) {
      if (isFunction(node2.callee)) {
        return 1 | 2;
      }
      return 0;
    },
    VariableDeclaration(node2) {
      for (let i = 0; i < node2.declarations.length; i++) {
        const declar = node2.declarations[i];
        let enabled = isHelper(declar.id) && !isType2(declar.init);
        if (!enabled && declar.init) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
      return 0;
    },
    IfStatement(node2) {
      if (isBlockStatement(node2.consequent)) {
        return 1 | 2;
      }
      return 0;
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node2, parent) {
    if (parent.properties[0] === node2) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeCallProperty = function(node2, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node2 && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeIndexer = function(node2, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node2 && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeInternalSlot = function(node2, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node2 && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
    return 0;
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
      const ret = amounts ? 1 | 2 : 0;
      nodes[type2] = () => ret;
    });
  });
  return whitespace;
}
var parentheses = {};
var hasRequiredParentheses;
function requireParentheses() {
  if (hasRequiredParentheses) return parentheses;
  hasRequiredParentheses = 1;
  Object.defineProperty(parentheses, "__esModule", {
    value: true
  });
  parentheses.AssignmentExpression = AssignmentExpression;
  parentheses.Binary = Binary;
  parentheses.BinaryExpression = BinaryExpression;
  parentheses.ClassExpression = ClassExpression;
  parentheses.ArrowFunctionExpression = parentheses.ConditionalExpression = ConditionalExpression;
  parentheses.DoExpression = DoExpression;
  parentheses.FunctionExpression = FunctionExpression;
  parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
  parentheses.Identifier = Identifier;
  parentheses.LogicalExpression = LogicalExpression;
  parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
  parentheses.ObjectExpression = ObjectExpression;
  parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
  parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression;
  parentheses.SequenceExpression = SequenceExpression;
  parentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;
  parentheses.TSConditionalType = TSConditionalType;
  parentheses.TSConstructorType = parentheses.TSFunctionType = TSFunctionType;
  parentheses.TSInferType = TSInferType;
  parentheses.TSInstantiationExpression = TSInstantiationExpression;
  parentheses.TSIntersectionType = TSIntersectionType;
  parentheses.UnaryLike = parentheses.TSTypeAssertion = UnaryLike;
  parentheses.TSTypeOperator = TSTypeOperator;
  parentheses.TSUnionType = TSUnionType;
  parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
  parentheses.UpdateExpression = UpdateExpression;
  parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression;
  var _t2 = requireLib$5();
  var _index = requireNode();
  const {
    isArrayTypeAnnotation,
    isBinaryExpression,
    isCallExpression,
    isForOfStatement,
    isIndexedAccessType,
    isMemberExpression,
    isObjectPattern,
    isOptionalMemberExpression,
    isYieldExpression,
    isStatement
  } = _t2;
  const PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function getBinaryPrecedence(node2, nodeType) {
    if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
      return PRECEDENCE.get(node2.operator);
    }
    if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
      return PRECEDENCE.get("in");
    }
  }
  function isTSTypeExpression(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  }
  const isClassExtendsClause = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node2;
  };
  const hasPostfixPart = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node2 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node2 || parentType === "TaggedTemplateExpression" && parent.tag === node2 || parentType === "TSNonNullExpression";
  };
  function NullableTypeAnnotation(node2, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation(node2, parent, tokenContext) {
    const parentType = parent.type;
    return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
  }
  function UpdateExpression(node2, parent) {
    return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent);
  }
  function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
  }
  function ObjectExpression(node2, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
  }
  function DoExpression(node2, parent, tokenContext) {
    return !node2.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
  }
  function Binary(node2, parent) {
    const parentType = parent.type;
    if (node2.type === "BinaryExpression" && node2.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node2;
    }
    if (isClassExtendsClause(node2, parent)) {
      return true;
    }
    if (hasPostfixPart(node2, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    const parentPos = getBinaryPrecedence(parent, parentType);
    if (parentPos != null) {
      const nodePos = getBinaryPrecedence(node2, node2.type);
      if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node2 || parentPos > nodePos) {
        return true;
      }
    }
  }
  function UnionTypeAnnotation(node2, parent) {
    const parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  }
  function OptionalIndexedAccessType(node2, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node2;
  }
  function TSAsExpression(node2, parent) {
    if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node2) {
      return true;
    }
    if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node2 === parent.left) {
      return true;
    }
    return Binary(node2, parent);
  }
  function TSConditionalType(node2, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
      return true;
    }
    if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node2) {
      return true;
    }
    if (parentType === "TSConditionalType" && (parent.checkType === node2 || parent.extendsType === node2)) {
      return true;
    }
    return false;
  }
  function TSUnionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSIntersectionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSInferType(node2, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType") {
      return true;
    }
    if (node2.typeParameter.constraint) {
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node2) {
        return true;
      }
    }
    return false;
  }
  function TSTypeOperator(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSInstantiationExpression(node2, parent) {
    const parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  }
  function TSFunctionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSConditionalType" && (parent.checkType === node2 || parent.extendsType === node2);
  }
  function BinaryExpression(node2, parent, tokenContext) {
    return node2.operator === "in" && Boolean(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);
  }
  function SequenceExpression(node2, parent) {
    const parentType = parent.type;
    if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node2 || parentType === "OptionalMemberExpression" && parent.property === node2 || parentType === "TemplateLiteral") {
      return false;
    }
    if (parentType === "ClassDeclaration") {
      return true;
    }
    if (parentType === "ForOfStatement") {
      return parent.right === node2;
    }
    if (parentType === "ExportDefaultDeclaration") {
      return true;
    }
    return !isStatement(parent);
  }
  function YieldExpression(node2, parent) {
    const parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node2, parent) || parentType === "AwaitExpression" && isYieldExpression(node2) || parentType === "ConditionalExpression" && node2 === parent.test || isClassExtendsClause(node2, parent) || isTSTypeExpression(parentType);
  }
  function ClassExpression(node2, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function UnaryLike(node2, parent) {
    return hasPostfixPart(node2, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node2 || isClassExtendsClause(node2, parent);
  }
  function FunctionExpression(node2, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function ConditionalExpression(node2, parent) {
    const parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node2 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node2, parent);
  }
  function OptionalMemberExpression(node2, parent) {
    return isCallExpression(parent) && parent.callee === node2 || isMemberExpression(parent) && parent.object === node2;
  }
  function AssignmentExpression(node2, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node2.left)) {
      return true;
    } else {
      return ConditionalExpression(node2, parent);
    }
  }
  function LogicalExpression(node2, parent) {
    const parentType = parent.type;
    if (isTSTypeExpression(parentType)) return true;
    if (parentType !== "LogicalExpression") return false;
    switch (node2.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  }
  function Identifier(node2, parent, tokenContext, getRawIdentifier) {
    var _node$extra;
    const parentType = parent.type;
    if ((_node$extra = node2.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node2) {
      const rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (getRawIdentifier && getRawIdentifier(node2) !== node2.name) {
      return false;
    }
    if (node2.name === "let") {
      const isFollowedByBracket = isMemberExpression(parent, {
        object: node2,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node2,
        computed: true,
        optional: false
      });
      if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {
        return true;
      }
      return Boolean(tokenContext & _index.TokenContext.forOfHead);
    }
    return node2.name === "async" && isForOfStatement(parent, {
      left: node2,
      await: false
    });
  }
  return parentheses;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  Object.defineProperty(node, "__esModule", {
    value: true
  });
  node.TokenContext = void 0;
  node.isLastChild = isLastChild;
  node.needsParens = needsParens;
  node.needsWhitespace = needsWhitespace;
  node.needsWhitespaceAfter = needsWhitespaceAfter;
  node.needsWhitespaceBefore = needsWhitespaceBefore;
  var whitespace2 = requireWhitespace();
  var parens = requireParentheses();
  var _t2 = requireLib$5();
  const {
    FLIPPED_ALIAS_KEYS,
    VISITOR_KEYS,
    isCallExpression,
    isDecorator,
    isExpressionStatement,
    isMemberExpression,
    isNewExpression,
    isParenthesizedExpression
  } = _t2;
  node.TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function expandAliases(obj) {
    const map = /* @__PURE__ */ new Map();
    function add(type, func) {
      const fn2 = map.get(type);
      map.set(type, fn2 ? function(node2, parent, stack, getRawIdentifier) {
        var _fn;
        return (_fn = fn2(node2, parent, stack, getRawIdentifier)) != null ? _fn : func(node2, parent, stack, getRawIdentifier);
      } : func);
    }
    for (const type of Object.keys(obj)) {
      const aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  }
  const expandedParens = expandAliases(parens);
  const expandedWhitespaceNodes = expandAliases(whitespace2.nodes);
  function isOrHasCallExpression(node2) {
    if (isCallExpression(node2)) {
      return true;
    }
    return isMemberExpression(node2) && isOrHasCallExpression(node2.object);
  }
  function needsWhitespace(node2, parent, type) {
    var _expandedWhitespaceNo;
    if (!node2) return false;
    if (isExpressionStatement(node2)) {
      node2 = node2.expression;
    }
    const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node2.type)) == null ? void 0 : _expandedWhitespaceNo(node2, parent);
    if (typeof flag === "number") {
      return (flag & type) !== 0;
    }
    return false;
  }
  function needsWhitespaceBefore(node2, parent) {
    return needsWhitespace(node2, parent, 1);
  }
  function needsWhitespaceAfter(node2, parent) {
    return needsWhitespace(node2, parent, 2);
  }
  function needsParens(node2, parent, tokenContext, getRawIdentifier) {
    var _expandedParens$get;
    if (!parent) return false;
    if (isNewExpression(parent) && parent.callee === node2) {
      if (isOrHasCallExpression(node2)) return true;
    }
    if (isDecorator(parent)) {
      return !isDecoratorMemberExpression(node2) && !(isCallExpression(node2) && isDecoratorMemberExpression(node2.callee)) && !isParenthesizedExpression(node2);
    }
    return ((_expandedParens$get = expandedParens.get(node2.type)) == null ? void 0 : _expandedParens$get(node2, parent, tokenContext, getRawIdentifier)) || false;
  }
  function isDecoratorMemberExpression(node2) {
    switch (node2.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node2.computed && node2.property.type === "Identifier" && isDecoratorMemberExpression(node2.object);
      default:
        return false;
    }
  }
  function isLastChild(parent, child) {
    const visitorKeys = VISITOR_KEYS[parent.type];
    for (let i = visitorKeys.length - 1; i >= 0; i--) {
      const val = parent[visitorKeys[i]];
      if (val === child) {
        return true;
      } else if (Array.isArray(val)) {
        let j2 = val.length - 1;
        while (j2 >= 0 && val[j2] === null) j2--;
        return j2 >= 0 && val[j2] === child;
      } else if (val) {
        return false;
      }
    }
    return false;
  }
  return node;
}
var tokenMap = {};
var hasRequiredTokenMap;
function requireTokenMap() {
  if (hasRequiredTokenMap) return tokenMap;
  hasRequiredTokenMap = 1;
  Object.defineProperty(tokenMap, "__esModule", {
    value: true
  });
  tokenMap.TokenMap = void 0;
  var _t2 = requireLib$5();
  const {
    traverseFast: traverseFast2,
    VISITOR_KEYS
  } = _t2;
  class TokenMap {
    constructor(ast, tokens, source) {
      this._tokens = void 0;
      this._source = void 0;
      this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
      this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
      this._tokensCache = /* @__PURE__ */ new Map();
      this._tokens = tokens;
      this._source = source;
      traverseFast2(ast, (node2) => {
        const indexes = this._getTokensIndexesOfNode(node2);
        if (indexes.length > 0) this._nodesToTokenIndexes.set(node2, indexes);
      });
      this._tokensCache.clear();
    }
    has(node2) {
      return this._nodesToTokenIndexes.has(node2);
    }
    getIndexes(node2) {
      return this._nodesToTokenIndexes.get(node2);
    }
    find(node2, condition) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        for (let k2 = 0; k2 < indexes.length; k2++) {
          const index = indexes[k2];
          const tok = this._tokens[index];
          if (condition(tok, index)) return tok;
        }
      }
      return null;
    }
    findLastIndex(node2, condition) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        for (let k2 = indexes.length - 1; k2 >= 0; k2--) {
          const index = indexes[k2];
          const tok = this._tokens[index];
          if (condition(tok, index)) return index;
        }
      }
      return -1;
    }
    findMatching(node2, test, occurrenceCount = 0) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        let i = 0;
        const count = occurrenceCount;
        if (count > 1) {
          const cache2 = this._nodesOccurrencesCountCache.get(node2);
          if (cache2 && cache2.test === test && cache2.count < count) {
            i = cache2.i + 1;
            occurrenceCount -= cache2.count + 1;
          }
        }
        for (; i < indexes.length; i++) {
          const tok = this._tokens[indexes[i]];
          if (this.matchesOriginal(tok, test)) {
            if (occurrenceCount === 0) {
              if (count > 0) {
                this._nodesOccurrencesCountCache.set(node2, {
                  test,
                  count,
                  i
                });
              }
              return tok;
            }
            occurrenceCount--;
          }
        }
      }
      return null;
    }
    matchesOriginal(token, test) {
      if (token.end - token.start !== test.length) return false;
      if (token.value != null) return token.value === test;
      return this._source.startsWith(test, token.start);
    }
    startMatches(node2, test) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (!indexes) return false;
      const tok = this._tokens[indexes[0]];
      if (tok.start !== node2.start) return false;
      return this.matchesOriginal(tok, test);
    }
    endMatches(node2, test) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (!indexes) return false;
      const tok = this._tokens[indexes[indexes.length - 1]];
      if (tok.end !== node2.end) return false;
      return this.matchesOriginal(tok, test);
    }
    _getTokensIndexesOfNode(node2) {
      if (node2.start == null || node2.end == null) return [];
      const {
        first,
        last
      } = this._findTokensOfNode(node2, 0, this._tokens.length - 1);
      let low = first;
      const children = childrenIterator(node2);
      if ((node2.type === "ExportNamedDeclaration" || node2.type === "ExportDefaultDeclaration") && node2.declaration && node2.declaration.type === "ClassDeclaration") {
        children.next();
      }
      const indexes = [];
      for (const child of children) {
        if (child == null) continue;
        if (child.start == null || child.end == null) continue;
        const childTok = this._findTokensOfNode(child, low, last);
        const high = childTok.first;
        for (let k2 = low; k2 < high; k2++) indexes.push(k2);
        low = childTok.last + 1;
      }
      for (let k2 = low; k2 <= last; k2++) indexes.push(k2);
      return indexes;
    }
    _findTokensOfNode(node2, low, high) {
      const cached = this._tokensCache.get(node2);
      if (cached) return cached;
      const first = this._findFirstTokenOfNode(node2.start, low, high);
      const last = this._findLastTokenOfNode(node2.end, first, high);
      this._tokensCache.set(node2, {
        first,
        last
      });
      return {
        first,
        last
      };
    }
    _findFirstTokenOfNode(start, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (start < this._tokens[mid].start) {
          high = mid - 1;
        } else if (start > this._tokens[mid].start) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return low;
    }
    _findLastTokenOfNode(end, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (end < this._tokens[mid].end) {
          high = mid - 1;
        } else if (end > this._tokens[mid].end) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return high;
    }
  }
  tokenMap.TokenMap = TokenMap;
  function* childrenIterator(node2) {
    if (node2.type === "TemplateLiteral") {
      yield node2.quasis[0];
      for (let i = 1; i < node2.quasis.length; i++) {
        yield node2.expressions[i - 1];
        yield node2.quasis[i];
      }
      return;
    }
    const keys = VISITOR_KEYS[node2.type];
    for (const key of keys) {
      const child = node2[key];
      if (!child) continue;
      if (Array.isArray(child)) {
        yield* child;
      } else {
        yield child;
      }
    }
  }
  return tokenMap;
}
var generators = {};
var templateLiterals = {};
var hasRequiredTemplateLiterals;
function requireTemplateLiterals() {
  if (hasRequiredTemplateLiterals) return templateLiterals;
  hasRequiredTemplateLiterals = 1;
  Object.defineProperty(templateLiterals, "__esModule", {
    value: true
  });
  templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
  templateLiterals.TemplateElement = TemplateElement;
  templateLiterals.TemplateLiteral = TemplateLiteral;
  templateLiterals._printTemplate = _printTemplate;
  function TaggedTemplateExpression(node2) {
    this.print(node2.tag);
    {
      this.print(node2.typeParameters);
    }
    this.print(node2.quasi);
  }
  function TemplateElement() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function _printTemplate(node2, substitutions) {
    const quasis = node2.quasis;
    let partRaw = "`";
    for (let i = 0; i < quasis.length - 1; i++) {
      partRaw += quasis[i].value.raw;
      this.token(partRaw + "${", true);
      this.print(substitutions[i]);
      partRaw = "}";
      if (this.tokenMap) {
        const token = this.tokenMap.findMatching(node2, "}", i);
        if (token) this._catchUpTo(token.loc.start);
      }
    }
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + "`", true);
  }
  function TemplateLiteral(node2) {
    this._printTemplate(node2, node2.expressions);
  }
  return templateLiterals;
}
var expressions = {};
var hasRequiredExpressions;
function requireExpressions() {
  if (hasRequiredExpressions) return expressions;
  hasRequiredExpressions = 1;
  Object.defineProperty(expressions, "__esModule", {
    value: true
  });
  expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
  expressions.AssignmentPattern = AssignmentPattern;
  expressions.AwaitExpression = AwaitExpression;
  expressions.BindExpression = BindExpression;
  expressions.CallExpression = CallExpression;
  expressions.ConditionalExpression = ConditionalExpression;
  expressions.Decorator = Decorator;
  expressions.DoExpression = DoExpression;
  expressions.EmptyStatement = EmptyStatement;
  expressions.ExpressionStatement = ExpressionStatement;
  expressions.Import = Import;
  expressions.MemberExpression = MemberExpression;
  expressions.MetaProperty = MetaProperty;
  expressions.ModuleExpression = ModuleExpression;
  expressions.NewExpression = NewExpression;
  expressions.OptionalCallExpression = OptionalCallExpression;
  expressions.OptionalMemberExpression = OptionalMemberExpression;
  expressions.ParenthesizedExpression = ParenthesizedExpression;
  expressions.PrivateName = PrivateName;
  expressions.SequenceExpression = SequenceExpression;
  expressions.Super = Super;
  expressions.ThisExpression = ThisExpression;
  expressions.UnaryExpression = UnaryExpression;
  expressions.UpdateExpression = UpdateExpression;
  expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  expressions.YieldExpression = YieldExpression;
  expressions._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
  var _t2 = requireLib$5();
  var _index = requireNode();
  const {
    isCallExpression,
    isLiteral,
    isMemberExpression,
    isNewExpression,
    isPattern
  } = _t2;
  function UnaryExpression(node2) {
    const {
      operator
    } = node2;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node2.argument);
  }
  function DoExpression(node2) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node2.body);
  }
  function ParenthesizedExpression(node2) {
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.print(node2.expression);
    exit();
    this.rightParens(node2);
  }
  function UpdateExpression(node2) {
    if (node2.prefix) {
      this.token(node2.operator);
      this.print(node2.argument);
    } else {
      this.print(node2.argument, true);
      this.token(node2.operator);
    }
  }
  function ConditionalExpression(node2) {
    this.print(node2.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.alternate);
  }
  function NewExpression(node2, parent) {
    this.word("new");
    this.space();
    this.print(node2.callee);
    if (this.format.minified && node2.arguments.length === 0 && !node2.optional && !isCallExpression(parent, {
      callee: node2
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node2.typeArguments);
    {
      this.print(node2.typeParameters);
      if (node2.optional) {
        this.token("?.");
      }
    }
    if (node2.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node2, ")")) {
      return;
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node2);
  }
  function SequenceExpression(node2) {
    this.printList(node2.expressions);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function _shouldPrintDecoratorsBeforeExport(node2) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node2.start === "number" && node2.start === node2.declaration.start;
  }
  function Decorator(node2) {
    this.tokenChar(64);
    this.print(node2.expression);
    this.newline();
  }
  function OptionalMemberExpression(node2) {
    let {
      computed
    } = node2;
    const {
      optional,
      property
    } = node2;
    this.print(node2.object);
    if (!computed && isMemberExpression(property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral(property) && typeof property.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property);
    }
  }
  function OptionalCallExpression(node2) {
    this.print(node2.callee);
    {
      this.print(node2.typeParameters);
    }
    if (node2.optional) {
      this.token("?.");
    }
    this.print(node2.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments);
    exit();
    this.rightParens(node2);
  }
  function CallExpression(node2) {
    this.print(node2.callee);
    this.print(node2.typeArguments);
    {
      this.print(node2.typeParameters);
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node2);
  }
  function Import() {
    this.word("import");
  }
  function AwaitExpression(node2) {
    this.word("await");
    this.space();
    this.print(node2.argument);
  }
  function YieldExpression(node2) {
    if (node2.delegate) {
      this.word("yield", true);
      this.tokenChar(42);
      if (node2.argument) {
        this.space();
        this.print(node2.argument);
      }
    } else if (node2.argument) {
      this.word("yield", true);
      this.space();
      this.print(node2.argument);
    } else {
      this.word("yield");
    }
  }
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node2) {
    this.tokenContext |= _index.TokenContext.expressionStatement;
    this.print(node2.expression);
    this.semicolon();
  }
  function AssignmentPattern(node2) {
    this.print(node2.left);
    if (node2.left.type === "Identifier" || isPattern(node2.left)) {
      if (node2.left.optional) this.tokenChar(63);
      this.print(node2.left.typeAnnotation);
    }
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.right);
  }
  function AssignmentExpression(node2) {
    this.print(node2.left);
    this.space();
    if (node2.operator === "in" || node2.operator === "instanceof") {
      this.word(node2.operator);
    } else {
      this.token(node2.operator);
      this._endsWithDiv = node2.operator === "/";
    }
    this.space();
    this.print(node2.right);
  }
  function BindExpression(node2) {
    this.print(node2.object);
    this.token("::");
    this.print(node2.callee);
  }
  function MemberExpression(node2) {
    this.print(node2.object);
    if (!node2.computed && isMemberExpression(node2.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    let computed = node2.computed;
    if (isLiteral(node2.property) && typeof node2.property.value === "number") {
      computed = true;
    }
    if (computed) {
      const exit = this.enterDelimited();
      this.tokenChar(91);
      this.print(node2.property);
      this.tokenChar(93);
      exit();
    } else {
      this.tokenChar(46);
      this.print(node2.property);
    }
  }
  function MetaProperty(node2) {
    this.print(node2.meta);
    this.tokenChar(46);
    this.print(node2.property);
  }
  function PrivateName(node2) {
    this.tokenChar(35);
    this.print(node2.id);
  }
  function V8IntrinsicIdentifier(node2) {
    this.tokenChar(37);
    this.word(node2.name);
  }
  function ModuleExpression(node2) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {
      body
    } = node2;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body);
    this.dedent();
    this.rightBrace(node2);
  }
  return expressions;
}
var statements = {};
var hasRequiredStatements;
function requireStatements() {
  if (hasRequiredStatements) return statements;
  hasRequiredStatements = 1;
  Object.defineProperty(statements, "__esModule", {
    value: true
  });
  statements.BreakStatement = BreakStatement;
  statements.CatchClause = CatchClause;
  statements.ContinueStatement = ContinueStatement;
  statements.DebuggerStatement = DebuggerStatement;
  statements.DoWhileStatement = DoWhileStatement;
  statements.ForOfStatement = statements.ForInStatement = void 0;
  statements.ForStatement = ForStatement;
  statements.IfStatement = IfStatement;
  statements.LabeledStatement = LabeledStatement;
  statements.ReturnStatement = ReturnStatement;
  statements.SwitchCase = SwitchCase;
  statements.SwitchStatement = SwitchStatement;
  statements.ThrowStatement = ThrowStatement;
  statements.TryStatement = TryStatement;
  statements.VariableDeclaration = VariableDeclaration;
  statements.VariableDeclarator = VariableDeclarator;
  statements.WhileStatement = WhileStatement;
  statements.WithStatement = WithStatement;
  var _t2 = requireLib$5();
  const {
    isFor,
    isForStatement,
    isIfStatement,
    isStatement
  } = _t2;
  function WithStatement(node2) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node2.object);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function IfStatement(node2) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.space();
    const needsBlock = node2.alternate && isIfStatement(getLastStatement(node2.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node2.consequent);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node2.alternate) {
      if (this.endsWith(125)) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node2.alternate);
    }
  }
  function getLastStatement(statement) {
    const {
      body
    } = statement;
    if (isStatement(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  }
  function ForStatement(node2) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    {
      const exit = this.enterForStatementInit();
      this.print(node2.init);
      exit();
    }
    this.tokenChar(59);
    if (node2.test) {
      this.space();
      this.print(node2.test);
    }
    this.token(";", false, 1);
    if (node2.update) {
      this.space();
      this.print(node2.update);
    }
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function WhileStatement(node2) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function ForXStatement(node2) {
    this.word("for");
    this.space();
    const isForOf = node2.type === "ForOfStatement";
    if (isForOf && node2.await) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
      const exit = this.enterForXStatementInit(isForOf);
      this.print(node2.left);
      exit == null || exit();
    }
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node2.right);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  statements.ForInStatement = ForXStatement;
  statements.ForOfStatement = ForXStatement;
  function DoWhileStatement(node2) {
    this.word("do");
    this.space();
    this.print(node2.body);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.semicolon();
  }
  function printStatementAfterKeyword(printer2, node2) {
    if (node2) {
      printer2.space();
      printer2.printTerminatorless(node2);
    }
    printer2.semicolon();
  }
  function BreakStatement(node2) {
    this.word("break");
    printStatementAfterKeyword(this, node2.label);
  }
  function ContinueStatement(node2) {
    this.word("continue");
    printStatementAfterKeyword(this, node2.label);
  }
  function ReturnStatement(node2) {
    this.word("return");
    printStatementAfterKeyword(this, node2.argument);
  }
  function ThrowStatement(node2) {
    this.word("throw");
    printStatementAfterKeyword(this, node2.argument);
  }
  function LabeledStatement(node2) {
    this.print(node2.label);
    this.tokenChar(58);
    this.space();
    this.print(node2.body);
  }
  function TryStatement(node2) {
    this.word("try");
    this.space();
    this.print(node2.block);
    this.space();
    if (node2.handlers) {
      this.print(node2.handlers[0]);
    } else {
      this.print(node2.handler);
    }
    if (node2.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node2.finalizer);
    }
  }
  function CatchClause(node2) {
    this.word("catch");
    this.space();
    if (node2.param) {
      this.tokenChar(40);
      this.print(node2.param);
      this.print(node2.param.typeAnnotation);
      this.tokenChar(41);
      this.space();
    }
    this.print(node2.body);
  }
  function SwitchStatement(node2) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node2.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node2.cases, true);
    this.rightBrace(node2);
  }
  function SwitchCase(node2) {
    if (node2.test) {
      this.word("case");
      this.space();
      this.print(node2.test);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node2.consequent.length) {
      this.newline();
      this.printSequence(node2.consequent, true);
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }
  function VariableDeclaration(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    const {
      kind
    } = node2;
    if (kind === "await using") {
      this.word("await");
      this.space();
      this.word("using", true);
    } else {
      this.word(kind, kind === "using");
    }
    this.space();
    let hasInits = false;
    if (!isFor(parent)) {
      for (const declar of node2.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    this.printList(node2.declarations, void 0, void 0, node2.declarations.length > 1, hasInits ? function(occurrenceCount) {
      this.token(",", false, occurrenceCount);
      this.newline();
    } : void 0);
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node2) return;
      } else {
        if (parent.left === node2) return;
      }
    }
    this.semicolon();
  }
  function VariableDeclarator(node2) {
    this.print(node2.id);
    if (node2.definite) this.tokenChar(33);
    this.print(node2.id.typeAnnotation);
    if (node2.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.init);
    }
  }
  return statements;
}
var classes = {};
var hasRequiredClasses;
function requireClasses() {
  if (hasRequiredClasses) return classes;
  hasRequiredClasses = 1;
  Object.defineProperty(classes, "__esModule", {
    value: true
  });
  classes.ClassAccessorProperty = ClassAccessorProperty;
  classes.ClassBody = ClassBody;
  classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
  classes.ClassMethod = ClassMethod;
  classes.ClassPrivateMethod = ClassPrivateMethod;
  classes.ClassPrivateProperty = ClassPrivateProperty;
  classes.ClassProperty = ClassProperty;
  classes.StaticBlock = StaticBlock;
  classes._classMethodHead = _classMethodHead;
  var _t2 = requireLib$5();
  const {
    isExportDefaultDeclaration,
    isExportNamedDeclaration
  } = _t2;
  function ClassDeclaration(node2, parent) {
    const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node2.decorators);
    }
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node2.id) {
      this.space();
      this.print(node2.id);
    }
    this.print(node2.typeParameters);
    if (node2.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.superClass);
      this.print(node2.superTypeParameters);
    }
    if (node2.implements) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node2.implements);
    }
    this.space();
    this.print(node2.body);
  }
  function ClassBody(node2) {
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      const separator = classBodyEmptySemicolonsPrinter(this, node2);
      separator == null || separator(-1);
      const exit = this.enterDelimited();
      this.printJoin(node2.body, true, true, separator, true);
      exit();
      if (!this.endsWith(10)) this.newline();
      this.rightBrace(node2);
    }
  }
  function classBodyEmptySemicolonsPrinter(printer2, node2) {
    if (!printer2.tokenMap || node2.start == null || node2.end == null) {
      return null;
    }
    const indexes = printer2.tokenMap.getIndexes(node2);
    if (!indexes) return null;
    let k2 = 1;
    let occurrenceCount = 0;
    let nextLocIndex = 0;
    const advanceNextLocIndex = () => {
      while (nextLocIndex < node2.body.length && node2.body[nextLocIndex].start == null) {
        nextLocIndex++;
      }
    };
    advanceNextLocIndex();
    return (i) => {
      if (nextLocIndex <= i) {
        nextLocIndex = i + 1;
        advanceNextLocIndex();
      }
      const end = nextLocIndex === node2.body.length ? node2.end : node2.body[nextLocIndex].start;
      let tok;
      while (k2 < indexes.length && printer2.tokenMap.matchesOriginal(tok = printer2._tokens[indexes[k2]], ";") && tok.start < end) {
        printer2.token(";", void 0, occurrenceCount++);
        k2++;
      }
    };
  }
  function ClassProperty(node2) {
    this.printJoin(node2.decorators);
    if (!node2.static && !this.format.preserveFormat) {
      var _node$key$loc;
      const endLine = (_node$key$loc = node2.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node2);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassAccessorProperty(node2) {
    var _node$key$loc2;
    this.printJoin(node2.decorators);
    const endLine = (_node$key$loc2 = node2.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
    if (endLine) this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node2);
    this.word("accessor", true);
    this.space();
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassPrivateProperty(node2) {
    this.printJoin(node2.decorators);
    this.tsPrintClassMemberModifiers(node2);
    this.print(node2.key);
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassMethod(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function ClassPrivateMethod(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function _classMethodHead(node2) {
    this.printJoin(node2.decorators);
    if (!this.format.preserveFormat) {
      var _node$key$loc3;
      const endLine = (_node$key$loc3 = node2.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node2);
    this._methodHead(node2);
  }
  function StaticBlock(node2) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node2.body, true);
      this.rightBrace(node2);
    }
  }
  return classes;
}
var methods = {};
var hasRequiredMethods;
function requireMethods() {
  if (hasRequiredMethods) return methods;
  hasRequiredMethods = 1;
  Object.defineProperty(methods, "__esModule", {
    value: true
  });
  methods.ArrowFunctionExpression = ArrowFunctionExpression;
  methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
  methods._functionHead = _functionHead;
  methods._methodHead = _methodHead;
  methods._param = _param;
  methods._parameters = _parameters;
  methods._params = _params;
  methods._predicate = _predicate;
  methods._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
  var _t2 = requireLib$5();
  var _index = requireNode();
  const {
    isIdentifier
  } = _t2;
  function _params(node2, idNode, parentNode) {
    this.print(node2.typeParameters);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node2.params, ")");
    const noLineTerminator = node2.type === "ArrowFunctionExpression";
    this.print(node2.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  }
  function _parameters(parameters, endToken) {
    const exit = this.enterDelimited();
    const trailingComma = this.shouldPrintTrailingComma(endToken);
    const paramLength = parameters.length;
    for (let i = 0; i < paramLength; i++) {
      this._param(parameters[i]);
      if (trailingComma || i < paramLength - 1) {
        this.token(",", void 0, i);
        this.space();
      }
    }
    this.token(endToken);
    exit();
  }
  function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation);
  }
  function _methodHead(node2) {
    const kind = node2.kind;
    const key = node2.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node2.generator) {
        this.tokenChar(42);
      }
    }
    if (node2.computed) {
      this.tokenChar(91);
      this.print(key);
      this.tokenChar(93);
    } else {
      this.print(key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    this._params(node2, node2.computed && node2.key.type !== "StringLiteral" ? void 0 : node2.key);
  }
  function _predicate(node2, noLineTerminatorAfter) {
    if (node2.predicate) {
      if (!node2.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node2.predicate, noLineTerminatorAfter);
    }
  }
  function _functionHead(node2, parent) {
    if (node2.async) {
      this.word("async");
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.space();
    }
    this.word("function");
    if (node2.generator) {
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.tokenChar(42);
    }
    this.space();
    if (node2.id) {
      this.print(node2.id);
    }
    this._params(node2, node2.id, parent);
    if (node2.type !== "TSDeclareFunction") {
      this._predicate(node2);
    }
  }
  function FunctionExpression(node2, parent) {
    this._functionHead(node2, parent);
    this.space();
    this.print(node2.body);
  }
  function ArrowFunctionExpression(node2, parent) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    if (this._shouldPrintArrowParamsParens(node2)) {
      this._params(node2, void 0, parent);
    } else {
      this.print(node2.params[0], true);
    }
    this._predicate(node2, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.tokenContext |= _index.TokenContext.arrowBody;
    this.print(node2.body);
  }
  function _shouldPrintArrowParamsParens(node2) {
    var _firstParam$leadingCo, _firstParam$trailingC;
    if (node2.params.length !== 1) return true;
    if (node2.typeParameters || node2.returnType || node2.predicate) {
      return true;
    }
    const firstParam = node2.params[0];
    if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
      return true;
    }
    if (this.tokenMap) {
      if (node2.loc == null) return true;
      if (this.tokenMap.findMatching(node2, "(") !== null) return true;
      const arrowToken = this.tokenMap.findMatching(node2, "=>");
      if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
      return arrowToken.loc.start.line !== node2.loc.start.line;
    }
    if (this.format.retainLines) return true;
    return false;
  }
  function _getFuncIdName(idNode, parent) {
    let id = idNode;
    if (!id && parent) {
      const parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id) return;
    let nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  }
  return methods;
}
var modules = {};
var hasRequiredModules;
function requireModules() {
  if (hasRequiredModules) return modules;
  hasRequiredModules = 1;
  Object.defineProperty(modules, "__esModule", {
    value: true
  });
  modules.ExportAllDeclaration = ExportAllDeclaration;
  modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
  modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
  modules.ExportNamedDeclaration = ExportNamedDeclaration;
  modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  modules.ExportSpecifier = ExportSpecifier;
  modules.ImportAttribute = ImportAttribute;
  modules.ImportDeclaration = ImportDeclaration;
  modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
  modules.ImportExpression = ImportExpression;
  modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  modules.ImportSpecifier = ImportSpecifier;
  modules._printAttributes = _printAttributes;
  var _t2 = requireLib$5();
  var _index = requireNode();
  const {
    isClassDeclaration,
    isExportDefaultSpecifier,
    isExportNamespaceSpecifier,
    isImportDefaultSpecifier,
    isImportNamespaceSpecifier,
    isStatement
  } = _t2;
  function ImportSpecifier(node2) {
    if (node2.importKind === "type" || node2.importKind === "typeof") {
      this.word(node2.importKind);
      this.space();
    }
    this.print(node2.imported);
    if (node2.local && node2.local.name !== node2.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.local);
    }
  }
  function ImportDefaultSpecifier(node2) {
    this.print(node2.local);
  }
  function ExportDefaultSpecifier(node2) {
    this.print(node2.exported);
  }
  function ExportSpecifier(node2) {
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node2.local);
    if (node2.exported && node2.local.name !== node2.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.exported);
    }
  }
  function ExportNamespaceSpecifier(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.exported);
  }
  let warningShown = false;
  function _printAttributes(node2, hasPreviousBrace) {
    var _node$extra;
    const {
      importAttributesKeyword
    } = this.format;
    const {
      attributes,
      assertions
    } = node2;
    if (attributes && !importAttributesKeyword && node2.extra && (node2.extra.deprecatedAssertSyntax || node2.extra.deprecatedWithLegacySyntax) && !warningShown) {
      warningShown = true;
      console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
    }
    const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node2.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
      this.printList(attributes || assertions);
      return;
    }
    const occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token("{", void 0, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
    this.space();
    this.token("}", void 0, occurrenceCount);
  }
  function ExportAllDeclaration(node2) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node2.attributes) != null && _node$attributes.length || (_node$assertions = node2.assertions) != null && _node$assertions.length) {
      this.print(node2.source, true);
      this.space();
      this._printAttributes(node2, false);
    } else {
      this.print(node2.source);
    }
    this.semicolon();
  }
  function maybePrintDecoratorsBeforeExport(printer2, node2) {
    if (isClassDeclaration(node2.declaration) && printer2._shouldPrintDecoratorsBeforeExport(node2)) {
      printer2.printJoin(node2.declaration.decorators);
    }
  }
  function ExportNamedDeclaration(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.space();
    if (node2.declaration) {
      const declar = node2.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      const specifiers = node2.specifiers.slice(0);
      let hasSpecial = false;
      for (; ; ) {
        const first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        hasBrace = true;
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, this.shouldPrintTrailingComma("}"));
          this.space();
        }
        this.tokenChar(125);
      }
      if (node2.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node2.attributes) != null && _node$attributes2.length || (_node$assertions2 = node2.assertions) != null && _node$assertions2.length) {
          this.print(node2.source, true);
          this.space();
          this._printAttributes(node2, hasBrace);
        } else {
          this.print(node2.source);
        }
      }
      this.semicolon();
    }
  }
  function ExportDefaultDeclaration(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    this.tokenContext |= _index.TokenContext.exportDefault;
    const declar = node2.declaration;
    this.print(declar);
    if (!isStatement(declar)) this.semicolon();
  }
  function ImportDeclaration(node2) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    const isTypeKind = node2.importKind === "type" || node2.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node2.importKind);
      this.space();
    } else if (node2.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node2.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node2.phase);
      this.space();
    }
    const specifiers = node2.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      const first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift());
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    let hasBrace = false;
    if (specifiers.length) {
      hasBrace = true;
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, this.shouldPrintTrailingComma("}"));
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      hasBrace = true;
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node2.attributes) != null && _node$attributes3.length || (_node$assertions3 = node2.assertions) != null && _node$assertions3.length) {
      this.print(node2.source, true);
      this.space();
      this._printAttributes(node2, hasBrace);
    } else {
      this.print(node2.source);
    }
    this.semicolon();
  }
  function ImportAttribute(node2) {
    this.print(node2.key);
    this.tokenChar(58);
    this.space();
    this.print(node2.value);
  }
  function ImportNamespaceSpecifier(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.local);
  }
  function ImportExpression(node2) {
    this.word("import");
    if (node2.phase) {
      this.tokenChar(46);
      this.word(node2.phase);
    }
    this.tokenChar(40);
    const shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
    this.print(node2.source);
    if (node2.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node2.options);
    }
    if (shouldPrintTrailingComma) {
      this.tokenChar(44);
    }
    this.rightParens(node2);
  }
  return modules;
}
var types = {};
var jsesc_1;
var hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object = {};
  const hasOwnProperty2 = object.hasOwnProperty;
  const forOwn = (object2, callback) => {
    for (const key in object2) {
      if (hasOwnProperty2.call(object2, key)) {
        callback(key, object2[key]);
      }
    }
  };
  const extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };
  const forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  const fourHexEscape = (hex) => {
    return "\\u" + ("0000" + hex).slice(-4);
  };
  const hexadecimal = (code, lowercase2) => {
    let hexadecimal2 = code.toString(16);
    if (lowercase2) return hexadecimal2;
    return hexadecimal2.toUpperCase();
  };
  const toString = object.toString;
  const isArray = Array.isArray;
  const isBuffer = (value) => {
    return typeof Buffer === "function" && Buffer.isBuffer(value);
  };
  const isObject = (value) => {
    return toString.call(value) == "[object Object]";
  };
  const isString = (value) => {
    return typeof value == "string" || toString.call(value) == "[object String]";
  };
  const isNumber = (value) => {
    return typeof value == "number" || toString.call(value) == "[object Number]";
  };
  const isBigInt = (value) => {
    return typeof value == "bigint";
  };
  const isFunction = (value) => {
    return typeof value == "function";
  };
  const isMap = (value) => {
    return toString.call(value) == "[object Map]";
  };
  const isSet = (value) => {
    return toString.call(value) == "[object Set]";
  };
  const singleEscapes = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  };
  const regexSingleEscape = /[\\\b\f\n\r\t]/;
  const regexDigit = /[0-9]/;
  const regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  const escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
  const escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
  const jsesc = (argument, options2) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options2.indentLevel;
      indent = options2.indent.repeat(options2.indentLevel);
    };
    const defaults = {
      "escapeEverything": false,
      "minimal": false,
      "isScriptContext": false,
      "quotes": "single",
      "wrap": false,
      "es6": false,
      "json": false,
      "compact": true,
      "lowercaseHex": false,
      "numbers": "decimal",
      "indent": "	",
      "indentLevel": 0,
      "__inline1__": false,
      "__inline2__": false
    };
    const json = options2 && options2.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options2 = extend(defaults, options2);
    if (options2.quotes != "single" && options2.quotes != "double" && options2.quotes != "backtick") {
      options2.quotes = "single";
    }
    const quote = options2.quotes == "double" ? '"' : options2.quotes == "backtick" ? "`" : "'";
    const compact = options2.compact;
    const lowercaseHex = options2.lowercaseHex;
    let indent = options2.indent.repeat(options2.indentLevel);
    let oldIndent = "";
    const inline1 = options2.__inline1__;
    const inline2 = options2.__inline2__;
    const newLine = compact ? "" : "\n";
    let result;
    let isEmpty = true;
    const useBinNumbers = options2.numbers == "binary";
    const useOctNumbers = options2.numbers == "octal";
    const useDecNumbers = options2.numbers == "decimal";
    const useHexNumbers = options2.numbers == "hexadecimal";
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options2.__inline1__ = true;
          options2.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options2.wrap = true;
        if (inline1) {
          options2.__inline1__ = false;
          options2.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value) => {
          isEmpty = false;
          if (inline2) {
            options2.__inline2__ = false;
          }
          result.push(
            (compact || inline2 ? "" : indent) + jsesc(value, options2)
          );
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      } else if (isNumber(argument) || isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        let result2;
        if (useDecNumbers) {
          result2 = String(argument);
        } else if (useHexNumbers) {
          let hexadecimal2 = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal2 = hexadecimal2.toUpperCase();
          }
          result2 = "0x" + hexadecimal2;
        } else if (useBinNumbers) {
          result2 = "0b" + argument.toString(2);
        } else if (useOctNumbers) {
          result2 = "0o" + argument.toString(8);
        }
        if (isBigInt(argument)) {
          return result2 + "n";
        }
        return result2;
      } else if (isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        return argument + "n";
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options2.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push(
            (compact ? "" : indent) + jsesc(key, options2) + ":" + (compact ? "" : " ") + jsesc(value, options2)
          );
        });
        if (isEmpty) {
          return "{}";
        }
        return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
      }
    }
    const regex = options2.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    result = argument.replace(regex, (char, pair, lone, quoteChar, index, string2) => {
      if (pair) {
        if (options2.minimal) return pair;
        const first = pair.charCodeAt(0);
        const second = pair.charCodeAt(1);
        if (options2.es6) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          const hex2 = hexadecimal(codePoint, lowercaseHex);
          return "\\u{" + hex2 + "}";
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone) {
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      }
      if (char == "\0" && !json && !regexDigit.test(string2.charAt(index + 1))) {
        return "\\0";
      }
      if (quoteChar) {
        if (quoteChar == quote || options2.escapeEverything) {
          return "\\" + quoteChar;
        }
        return quoteChar;
      }
      if (regexSingleEscape.test(char)) {
        return singleEscapes[char];
      }
      if (options2.minimal && !regexWhitespace.test(char)) {
        return char;
      }
      const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
      if (json || hex.length > 2) {
        return fourHexEscape(hex);
      }
      return "\\x" + ("00" + hex).slice(-2);
    });
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options2.isScriptContext) {
      result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    if (options2.wrap) {
      result = quote + result + quote;
    }
    return result;
  };
  jsesc.version = "3.0.2";
  jsesc_1 = jsesc;
  return jsesc_1;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", {
    value: true
  });
  types.ArgumentPlaceholder = ArgumentPlaceholder;
  types.ArrayPattern = types.ArrayExpression = ArrayExpression;
  types.BigIntLiteral = BigIntLiteral;
  types.BooleanLiteral = BooleanLiteral;
  types.Identifier = Identifier;
  types.NullLiteral = NullLiteral;
  types.NumericLiteral = NumericLiteral;
  types.ObjectPattern = types.ObjectExpression = ObjectExpression;
  types.ObjectMethod = ObjectMethod;
  types.ObjectProperty = ObjectProperty;
  types.PipelineBareFunction = PipelineBareFunction;
  types.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
  types.PipelineTopicExpression = PipelineTopicExpression;
  types.RecordExpression = RecordExpression;
  types.RegExpLiteral = RegExpLiteral;
  types.SpreadElement = types.RestElement = RestElement;
  types.StringLiteral = StringLiteral;
  types.TopicReference = TopicReference;
  types.TupleExpression = TupleExpression;
  types.VoidPattern = VoidPattern;
  types._getRawIdentifier = _getRawIdentifier;
  var _t2 = requireLib$5();
  var _jsesc = requireJsesc();
  const {
    isAssignmentPattern,
    isIdentifier
  } = _t2;
  let lastRawIdentNode = null;
  let lastRawIdentResult = "";
  function _getRawIdentifier(node2) {
    if (node2 === lastRawIdentNode) return lastRawIdentResult;
    lastRawIdentNode = node2;
    const {
      name
    } = node2;
    const token = this.tokenMap.find(node2, (tok) => tok.value === name);
    if (token) {
      lastRawIdentResult = this._originalCode.slice(token.start, token.end);
      return lastRawIdentResult;
    }
    return lastRawIdentResult = node2.name;
  }
  function Identifier(node2) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node2.loc) == null ? void 0 : _node$loc.identifierName) || node2.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node2) : node2.name);
  }
  function ArgumentPlaceholder() {
    this.tokenChar(63);
  }
  function RestElement(node2) {
    this.token("...");
    this.print(node2.argument);
  }
  function ObjectExpression(node2) {
    const props = node2.properties;
    this.tokenChar(123);
    if (props.length) {
      const exit = this.enterDelimited();
      this.space();
      this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
      this.space();
      exit();
    }
    this.sourceWithOffset("end", node2.loc, -1);
    this.tokenChar(125);
  }
  function ObjectMethod(node2) {
    this.printJoin(node2.decorators);
    this._methodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function ObjectProperty(node2) {
    this.printJoin(node2.decorators);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern(node2.value) && isIdentifier(node2.key) && node2.key.name === node2.value.left.name) {
        this.print(node2.value);
        return;
      }
      this.print(node2.key);
      if (node2.shorthand && isIdentifier(node2.key) && isIdentifier(node2.value) && node2.key.name === node2.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node2.value);
  }
  function ArrayExpression(node2) {
    const elems = node2.elements;
    const len = elems.length;
    this.tokenChar(91);
    const exit = this.enterDelimited();
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
          this.token(",", false, i);
        }
      } else {
        this.token(",", false, i);
      }
    }
    exit();
    this.tokenChar(93);
  }
  function RecordExpression(node2) {
    const props = node2.properties;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      } else {
        startToken = "#{";
        endToken = "}";
      }
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
      this.space();
    }
    this.token(endToken);
  }
  function TupleExpression(node2) {
    const elems = node2.elements;
    const len = elems.length;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      }
    }
    this.token(startToken);
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
          this.token(",", false, i);
        }
      }
    }
    this.token(endToken);
  }
  function RegExpLiteral(node2) {
    this.word(`/${node2.pattern}/${node2.flags}`);
  }
  function BooleanLiteral(node2) {
    this.word(node2.value ? "true" : "false");
  }
  function NullLiteral() {
    this.word("null");
  }
  function NumericLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    const opts = this.format.jsescOption;
    const value = node2.value;
    const str = value + "";
    if (opts.numbers) {
      this.number(_jsesc(value, opts), value);
    } else if (raw == null) {
      this.number(str, value);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value);
    } else {
      this.number(raw, value);
    }
  }
  function StringLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.token(raw);
      return;
    }
    const val = _jsesc(node2.value, this.format.jsescOption);
    this.token(val);
  }
  function BigIntLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.word(raw);
      return;
    }
    this.word(node2.value + "n");
  }
  const validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function TopicReference() {
    const {
      topicToken
    } = this.format;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      const givenTopicTokenJSON = JSON.stringify(topicToken);
      const validTopics = Array.from(validTopicTokenSet, (v2) => JSON.stringify(v2));
      throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
    }
  }
  function PipelineTopicExpression(node2) {
    this.print(node2.expression);
  }
  function PipelineBareFunction(node2) {
    this.print(node2.callee);
  }
  function PipelinePrimaryTopicReference() {
    this.tokenChar(35);
  }
  function VoidPattern() {
    this.word("void");
  }
  return types;
}
var flow = {};
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow;
  hasRequiredFlow = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1.AnyTypeAnnotation = AnyTypeAnnotation;
    exports$1.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports$1.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports$1.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports$1.DeclareClass = DeclareClass;
    exports$1.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports$1.DeclareExportDeclaration = DeclareExportDeclaration;
    exports$1.DeclareFunction = DeclareFunction;
    exports$1.DeclareInterface = DeclareInterface;
    exports$1.DeclareModule = DeclareModule;
    exports$1.DeclareModuleExports = DeclareModuleExports;
    exports$1.DeclareOpaqueType = DeclareOpaqueType;
    exports$1.DeclareTypeAlias = DeclareTypeAlias;
    exports$1.DeclareVariable = DeclareVariable;
    exports$1.DeclaredPredicate = DeclaredPredicate;
    exports$1.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports$1.EnumBooleanBody = EnumBooleanBody;
    exports$1.EnumBooleanMember = EnumBooleanMember;
    exports$1.EnumDeclaration = EnumDeclaration;
    exports$1.EnumDefaultedMember = EnumDefaultedMember;
    exports$1.EnumNumberBody = EnumNumberBody;
    exports$1.EnumNumberMember = EnumNumberMember;
    exports$1.EnumStringBody = EnumStringBody;
    exports$1.EnumStringMember = EnumStringMember;
    exports$1.EnumSymbolBody = EnumSymbolBody;
    exports$1.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports$1.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports$1.FunctionTypeParam = FunctionTypeParam;
    exports$1.IndexedAccessType = IndexedAccessType;
    exports$1.InferredPredicate = InferredPredicate;
    exports$1.InterfaceDeclaration = InterfaceDeclaration;
    exports$1.GenericTypeAnnotation = exports$1.ClassImplements = exports$1.InterfaceExtends = InterfaceExtends;
    exports$1.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports$1.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports$1.MixedTypeAnnotation = MixedTypeAnnotation;
    exports$1.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports$1.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports$1, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports$1.NumberTypeAnnotation = NumberTypeAnnotation;
    exports$1.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports$1.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports$1.ObjectTypeIndexer = ObjectTypeIndexer;
    exports$1.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports$1.ObjectTypeProperty = ObjectTypeProperty;
    exports$1.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports$1.OpaqueType = OpaqueType;
    exports$1.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports$1.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports$1, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports$1.StringTypeAnnotation = StringTypeAnnotation;
    exports$1.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports$1.ThisTypeAnnotation = ThisTypeAnnotation;
    exports$1.TupleTypeAnnotation = TupleTypeAnnotation;
    exports$1.TypeAlias = TypeAlias;
    exports$1.TypeAnnotation = TypeAnnotation;
    exports$1.TypeCastExpression = TypeCastExpression;
    exports$1.TypeParameter = TypeParameter;
    exports$1.TypeParameterDeclaration = exports$1.TypeParameterInstantiation = TypeParameterInstantiation;
    exports$1.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports$1.UnionTypeAnnotation = UnionTypeAnnotation;
    exports$1.Variance = Variance;
    exports$1.VoidTypeAnnotation = VoidTypeAnnotation;
    exports$1._interfaceish = _interfaceish;
    exports$1._variance = _variance;
    var _t2 = requireLib$5();
    var _modules = requireModules();
    var _index = requireNode();
    var _types2 = requireTypes();
    const {
      isDeclareExportDeclaration,
      isStatement
    } = _t2;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node2) {
      this.print(node2.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node2);
    }
    function DeclareFunction(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node2.id);
      this.print(node2.id.typeAnnotation.typeAnnotation);
      if (node2.predicate) {
        this.space();
        this.print(node2.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node2) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node2.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node2) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node2);
    }
    function DeclareModule(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node2.id);
      this.space();
      this.print(node2.body);
    }
    function DeclareModuleExports(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node2.typeAnnotation);
    }
    function DeclareTypeAlias(node2) {
      this.word("declare");
      this.space();
      this.TypeAlias(node2);
    }
    function DeclareOpaqueType(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node2);
    }
    function DeclareVariable(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node2.id);
      this.print(node2.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node2) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node2.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node2);
    }
    function DeclareExportAllDeclaration(node2) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node2);
    }
    function EnumDeclaration(node2) {
      const {
        id,
        body
      } = node2;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context2, name, hasExplicitType) {
      if (hasExplicitType) {
        context2.space();
        context2.word("of");
        context2.space();
        context2.word(name);
      }
      context2.space();
    }
    function enumBody(context2, node2) {
      const {
        members
      } = node2;
      context2.token("{");
      context2.indent();
      context2.newline();
      for (const member of members) {
        context2.print(member);
        context2.newline();
      }
      if (node2.hasUnknownMembers) {
        context2.token("...");
        context2.newline();
      }
      context2.dedent();
      context2.token("}");
    }
    function EnumBooleanBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node2);
    }
    function EnumNumberBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node2);
    }
    function EnumStringBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node2);
    }
    function EnumSymbolBody(node2) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node2);
    }
    function EnumDefaultedMember(node2) {
      const {
        id
      } = node2;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context2, node2) {
      context2.print(node2.id);
      context2.space();
      context2.token("=");
      context2.space();
      context2.print(node2.init);
      context2.token(",");
    }
    function EnumBooleanMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumNumberMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumStringMember(node2) {
      enumInitializedMember(this, node2);
    }
    function FlowExportDeclaration(node2) {
      if (node2.declaration) {
        const declar = node2.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node2.specifiers.length) {
          this.space();
          this.printList(node2.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node2.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node2.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node2, parent) {
      this.print(node2.typeParameters);
      this.tokenChar(40);
      if (node2.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node2.this.typeAnnotation);
        if (node2.params.length || node2.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node2.params);
      if (node2.rest) {
        if (node2.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node2.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node2.returnType);
    }
    function FunctionTypeParam(node2) {
      this.print(node2.name);
      if (node2.optional) this.tokenChar(63);
      if (node2.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.typeAnnotation);
    }
    function InterfaceExtends(node2) {
      this.print(node2.id);
      this.print(node2.typeParameters, true);
    }
    function _interfaceish(node2) {
      var _node$extends;
      this.print(node2.id);
      this.print(node2.typeParameters);
      if ((_node$extends = node2.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends);
      }
      if (node2.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node2.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node2.mixins);
        }
        if ((_node$implements = node2.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node2.implements);
        }
      }
      this.space();
      this.print(node2.body);
    }
    function _variance(node2) {
      var _node$variance;
      const kind = (_node$variance = node2.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node2) {
      this.word("interface");
      this.space();
      this._interfaceish(node2);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node2) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node2.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends);
      }
      this.space();
      this.print(node2.body);
    }
    function IntersectionTypeAnnotation(node2) {
      this.printJoin(node2.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node2) {
      this.tokenChar(63);
      this.print(node2.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node2) {
      this.tokenChar(91);
      this.printList(node2.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.argument);
    }
    function TypeAlias(node2) {
      this.word("type");
      this.space();
      this.print(node2.id);
      this.print(node2.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right);
      this.semicolon();
    }
    function TypeAnnotation(node2, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node2.optional) {
        this.tokenChar(63);
      }
      this.print(node2.typeAnnotation);
    }
    function TypeParameterInstantiation(node2) {
      this.tokenChar(60);
      this.printList(node2.params);
      this.tokenChar(62);
    }
    function TypeParameter(node2) {
      this._variance(node2);
      this.word(node2.name);
      if (node2.bound) {
        this.print(node2.bound);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default);
      }
    }
    function OpaqueType(node2) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node2.id);
      this.print(node2.typeParameters);
      if (node2.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node2.supertype);
      }
      if (node2.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node2) {
      if (node2.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node2.properties, ...node2.callProperties || [], ...node2.indexers || [], ...node2.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, () => {
          if (props.length !== 1 || node2.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node2.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node2.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node2.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node2.optional) this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeCallProperty(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeIndexer(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this._variance(node2);
      this.tokenChar(91);
      if (node2.id) {
        this.print(node2.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node2.value);
    }
    function ObjectTypeProperty(node2) {
      if (node2.proto) {
        this.word("proto");
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.kind === "get" || node2.kind === "set") {
        this.word(node2.kind);
        this.space();
      }
      this._variance(node2);
      this.print(node2.key);
      if (node2.optional) this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeSpreadProperty(node2) {
      this.token("...");
      this.print(node2.argument);
    }
    function QualifiedTypeIdentifier(node2) {
      this.print(node2.qualification);
      this.tokenChar(46);
      this.print(node2.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node2) {
      this.printJoin(node2.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression);
      this.print(node2.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node2) {
      if (node2.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node2) {
      this.print(node2.objectType, true);
      this.tokenChar(91);
      this.print(node2.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node2) {
      this.print(node2.objectType);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node2.indexType);
      this.tokenChar(93);
    }
  })(flow);
  return flow;
}
var base = {};
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  Object.defineProperty(base, "__esModule", {
    value: true
  });
  base.BlockStatement = BlockStatement;
  base.Directive = Directive;
  base.DirectiveLiteral = DirectiveLiteral;
  base.File = File;
  base.InterpreterDirective = InterpreterDirective;
  base.Placeholder = Placeholder;
  base.Program = Program;
  function File(node2) {
    if (node2.program) {
      this.print(node2.program.interpreter);
    }
    this.print(node2.program);
  }
  function Program(node2) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = (_node$directives = node2.directives) == null ? void 0 : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, void 0, newline);
      if (!((_node$directives$trai = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body);
  }
  function BlockStatement(node2) {
    var _node$directives2;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    const directivesLen = (_node$directives2 = node2.directives) == null ? void 0 : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, true, newline);
      if (!((_node$directives$trai2 = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body, true);
    exit();
    this.rightBrace(node2);
  }
  function Directive(node2) {
    this.print(node2.value);
    this.semicolon();
  }
  const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.token(raw);
      return;
    }
    const {
      value
    } = node2;
    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token(`'${value}'`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node2) {
    this.token(`#!${node2.value}`);
    this.newline(1, true);
  }
  function Placeholder(node2) {
    this.token("%%");
    this.print(node2.name);
    this.token("%%");
    if (node2.expectedNode === "Statement") {
      this.semicolon();
    }
  }
  return base;
}
var jsx = {};
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx;
  hasRequiredJsx = 1;
  Object.defineProperty(jsx, "__esModule", {
    value: true
  });
  jsx.JSXAttribute = JSXAttribute;
  jsx.JSXClosingElement = JSXClosingElement;
  jsx.JSXClosingFragment = JSXClosingFragment;
  jsx.JSXElement = JSXElement;
  jsx.JSXEmptyExpression = JSXEmptyExpression;
  jsx.JSXExpressionContainer = JSXExpressionContainer;
  jsx.JSXFragment = JSXFragment;
  jsx.JSXIdentifier = JSXIdentifier;
  jsx.JSXMemberExpression = JSXMemberExpression;
  jsx.JSXNamespacedName = JSXNamespacedName;
  jsx.JSXOpeningElement = JSXOpeningElement;
  jsx.JSXOpeningFragment = JSXOpeningFragment;
  jsx.JSXSpreadAttribute = JSXSpreadAttribute;
  jsx.JSXSpreadChild = JSXSpreadChild;
  jsx.JSXText = JSXText;
  function JSXAttribute(node2) {
    this.print(node2.name);
    if (node2.value) {
      this.tokenChar(61);
      this.print(node2.value);
    }
  }
  function JSXIdentifier(node2) {
    this.word(node2.name);
  }
  function JSXNamespacedName(node2) {
    this.print(node2.namespace);
    this.tokenChar(58);
    this.print(node2.name);
  }
  function JSXMemberExpression(node2) {
    this.print(node2.object);
    this.tokenChar(46);
    this.print(node2.property);
  }
  function JSXSpreadAttribute(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.argument);
    this.rightBrace(node2);
  }
  function JSXExpressionContainer(node2) {
    this.tokenChar(123);
    this.print(node2.expression);
    this.rightBrace(node2);
  }
  function JSXSpreadChild(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.expression);
    this.rightBrace(node2);
  }
  function JSXText(node2) {
    const raw = this.getPossibleRaw(node2);
    if (raw !== void 0) {
      this.token(raw, true);
    } else {
      this.token(node2.value, true);
    }
  }
  function JSXElement(node2) {
    const open = node2.openingElement;
    this.print(open);
    if (open.selfClosing) return;
    this.indent();
    for (const child of node2.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node2.closingElement);
  }
  function spaceSeparator() {
    this.space();
  }
  function JSXOpeningElement(node2) {
    this.tokenChar(60);
    this.print(node2.name);
    {
      if (node2.typeArguments) {
        this.print(node2.typeArguments);
      }
      this.print(node2.typeParameters);
    }
    if (node2.attributes.length > 0) {
      this.space();
      this.printJoin(node2.attributes, void 0, void 0, spaceSeparator);
    }
    if (node2.selfClosing) {
      this.space();
      this.tokenChar(47);
    }
    this.tokenChar(62);
  }
  function JSXClosingElement(node2) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node2.name);
    this.tokenChar(62);
  }
  function JSXEmptyExpression() {
    this.printInnerComments();
  }
  function JSXFragment(node2) {
    this.print(node2.openingFragment);
    this.indent();
    for (const child of node2.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node2.closingFragment);
  }
  function JSXOpeningFragment() {
    this.tokenChar(60);
    this.tokenChar(62);
  }
  function JSXClosingFragment() {
    this.token("</");
    this.tokenChar(62);
  }
  return jsx;
}
var typescript = {};
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript;
  hasRequiredTypescript = 1;
  Object.defineProperty(typescript, "__esModule", {
    value: true
  });
  typescript.TSAnyKeyword = TSAnyKeyword;
  typescript.TSArrayType = TSArrayType;
  typescript.TSSatisfiesExpression = typescript.TSAsExpression = TSTypeExpression;
  typescript.TSBigIntKeyword = TSBigIntKeyword;
  typescript.TSBooleanKeyword = TSBooleanKeyword;
  typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  typescript.TSInterfaceHeritage = typescript.TSClassImplements = TSClassImplements;
  typescript.TSConditionalType = TSConditionalType;
  typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  typescript.TSConstructorType = TSConstructorType;
  typescript.TSDeclareFunction = TSDeclareFunction;
  typescript.TSDeclareMethod = TSDeclareMethod;
  typescript.TSEnumBody = TSEnumBody;
  typescript.TSEnumDeclaration = TSEnumDeclaration;
  typescript.TSEnumMember = TSEnumMember;
  typescript.TSExportAssignment = TSExportAssignment;
  typescript.TSExternalModuleReference = TSExternalModuleReference;
  typescript.TSFunctionType = TSFunctionType;
  typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  typescript.TSImportType = TSImportType;
  typescript.TSIndexSignature = TSIndexSignature;
  typescript.TSIndexedAccessType = TSIndexedAccessType;
  typescript.TSInferType = TSInferType;
  typescript.TSInstantiationExpression = TSInstantiationExpression;
  typescript.TSInterfaceBody = TSInterfaceBody;
  typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
  typescript.TSIntersectionType = TSIntersectionType;
  typescript.TSIntrinsicKeyword = TSIntrinsicKeyword;
  typescript.TSLiteralType = TSLiteralType;
  typescript.TSMappedType = TSMappedType;
  typescript.TSMethodSignature = TSMethodSignature;
  typescript.TSModuleBlock = TSModuleBlock;
  typescript.TSModuleDeclaration = TSModuleDeclaration;
  typescript.TSNamedTupleMember = TSNamedTupleMember;
  typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  typescript.TSNeverKeyword = TSNeverKeyword;
  typescript.TSNonNullExpression = TSNonNullExpression;
  typescript.TSNullKeyword = TSNullKeyword;
  typescript.TSNumberKeyword = TSNumberKeyword;
  typescript.TSObjectKeyword = TSObjectKeyword;
  typescript.TSOptionalType = TSOptionalType;
  typescript.TSParameterProperty = TSParameterProperty;
  typescript.TSParenthesizedType = TSParenthesizedType;
  typescript.TSPropertySignature = TSPropertySignature;
  typescript.TSQualifiedName = TSQualifiedName;
  typescript.TSRestType = TSRestType;
  typescript.TSStringKeyword = TSStringKeyword;
  typescript.TSSymbolKeyword = TSSymbolKeyword;
  typescript.TSTemplateLiteralType = TSTemplateLiteralType;
  typescript.TSThisType = TSThisType;
  typescript.TSTupleType = TSTupleType;
  typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  typescript.TSTypeAnnotation = TSTypeAnnotation;
  typescript.TSTypeAssertion = TSTypeAssertion;
  typescript.TSTypeLiteral = TSTypeLiteral;
  typescript.TSTypeOperator = TSTypeOperator;
  typescript.TSTypeParameter = TSTypeParameter;
  typescript.TSTypeParameterDeclaration = typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  typescript.TSTypePredicate = TSTypePredicate;
  typescript.TSTypeQuery = TSTypeQuery;
  typescript.TSTypeReference = TSTypeReference;
  typescript.TSUndefinedKeyword = TSUndefinedKeyword;
  typescript.TSUnionType = TSUnionType;
  typescript.TSUnknownKeyword = TSUnknownKeyword;
  typescript.TSVoidKeyword = TSVoidKeyword;
  typescript.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
  typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  function TSTypeAnnotation(node2, parent) {
    this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node2 ? "=>" : ":");
    this.space();
    if (node2.optional) this.tokenChar(63);
    this.print(node2.typeAnnotation);
  }
  function TSTypeParameterInstantiation(node2, parent) {
    this.tokenChar(60);
    let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node2.params.length === 1;
    if (this.tokenMap && node2.start != null && node2.end != null) {
      printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node2, (t) => this.tokenMap.matchesOriginal(t, ",")));
      printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
    }
    this.printList(node2.params, printTrailingSeparator);
    this.tokenChar(62);
  }
  function TSTypeParameter(node2) {
    if (node2.const) {
      this.word("const");
      this.space();
    }
    if (node2.in) {
      this.word("in");
      this.space();
    }
    if (node2.out) {
      this.word("out");
      this.space();
    }
    this.word(node2.name);
    if (node2.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.constraint);
    }
    if (node2.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.default);
    }
  }
  function TSParameterProperty(node2) {
    if (node2.accessibility) {
      this.word(node2.accessibility);
      this.space();
    }
    if (node2.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node2.parameter);
  }
  function TSDeclareFunction(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node2, parent);
    this.semicolon();
  }
  function TSDeclareMethod(node2) {
    this._classMethodHead(node2);
    this.semicolon();
  }
  function TSQualifiedName(node2) {
    this.print(node2.left);
    this.tokenChar(46);
    this.print(node2.right);
  }
  function TSCallSignatureDeclaration(node2) {
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function maybePrintTrailingCommaOrSemicolon(printer2, node2) {
    if (!printer2.tokenMap || !node2.start || !node2.end) {
      printer2.semicolon();
      return;
    }
    if (printer2.tokenMap.endMatches(node2, ",")) {
      printer2.token(",");
    } else if (printer2.tokenMap.endMatches(node2, ";")) {
      printer2.semicolon();
    }
  }
  function TSConstructSignatureDeclaration(node2) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSPropertySignature(node2) {
    const {
      readonly
    } = node2;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.print(node2.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function tsPrintPropertyOrMethodName(node2) {
    if (node2.computed) {
      this.tokenChar(91);
    }
    this.print(node2.key);
    if (node2.computed) {
      this.tokenChar(93);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
  }
  function TSMethodSignature(node2) {
    const {
      kind
    } = node2;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSIndexSignature(node2) {
    const {
      readonly,
      static: isStatic
    } = node2;
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node2.parameters, "]");
    this.print(node2.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node2) {
    this.tsPrintFunctionOrConstructorType(node2);
  }
  function TSConstructorType(node2) {
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node2);
  }
  function tsPrintFunctionOrConstructorType(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    this.space();
    const returnType = node2.typeAnnotation;
    this.print(returnType);
  }
  function TSTypeReference(node2) {
    const typeArguments = node2.typeParameters;
    this.print(node2.typeName, !!typeArguments);
    this.print(typeArguments);
  }
  function TSTypePredicate(node2) {
    if (node2.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node2.parameterName);
    if (node2.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node2.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node2) {
    this.word("typeof");
    this.space();
    this.print(node2.exprName);
    const typeArguments = node2.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSTypeLiteral(node2) {
    printBraced(this, node2, () => this.printJoin(node2.members, true, true));
  }
  function TSArrayType(node2) {
    this.print(node2.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function TSTupleType(node2) {
    this.tokenChar(91);
    this.printList(node2.elementTypes, this.shouldPrintTrailingComma("]"));
    this.tokenChar(93);
  }
  function TSOptionalType(node2) {
    this.print(node2.typeAnnotation);
    this.tokenChar(63);
  }
  function TSRestType(node2) {
    this.token("...");
    this.print(node2.typeAnnotation);
  }
  function TSNamedTupleMember(node2) {
    this.print(node2.label);
    if (node2.optional) this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node2.elementType);
  }
  function TSUnionType(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "|");
  }
  function TSIntersectionType(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "&");
  }
  function tsPrintUnionOrIntersectionType(printer2, node2, sep) {
    var _printer$tokenMap;
    let hasLeadingToken = 0;
    if ((_printer$tokenMap = printer2.tokenMap) != null && _printer$tokenMap.startMatches(node2, sep)) {
      hasLeadingToken = 1;
      printer2.token(sep);
    }
    printer2.printJoin(node2.types, void 0, void 0, function(i) {
      this.space();
      this.token(sep, void 0, i + hasLeadingToken);
      this.space();
    });
  }
  function TSConditionalType(node2) {
    this.print(node2.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node2.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.falseType);
  }
  function TSInferType(node2) {
    this.word("infer");
    this.print(node2.typeParameter);
  }
  function TSParenthesizedType(node2) {
    this.tokenChar(40);
    this.print(node2.typeAnnotation);
    this.tokenChar(41);
  }
  function TSTypeOperator(node2) {
    this.word(node2.operator);
    this.space();
    this.print(node2.typeAnnotation);
  }
  function TSIndexedAccessType(node2) {
    this.print(node2.objectType, true);
    this.tokenChar(91);
    this.print(node2.indexType);
    this.tokenChar(93);
  }
  function TSMappedType(node2) {
    const {
      nameType,
      optional,
      readonly,
      typeAnnotation
    } = node2;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    {
      this.word(node2.typeParameter.name);
    }
    this.space();
    this.word("in");
    this.space();
    {
      this.print(node2.typeParameter.constraint);
    }
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    if (typeAnnotation) {
      this.tokenChar(58);
      this.space();
      this.print(typeAnnotation);
    }
    this.space();
    exit();
    this.tokenChar(125);
  }
  function tokenIfPlusMinus(self2, tok) {
    if (tok !== true) {
      self2.token(tok);
    }
  }
  function TSTemplateLiteralType(node2) {
    this._printTemplate(node2, node2.types);
  }
  function TSLiteralType(node2) {
    this.print(node2.literal);
  }
  function TSClassImplements(node2) {
    this.print(node2.expression);
    this.print(node2.typeArguments);
  }
  function TSInterfaceDeclaration(node2) {
    const {
      declare,
      id,
      typeParameters,
      extends: extendz,
      body
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id);
    this.print(typeParameters);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz);
    }
    this.space();
    this.print(body);
  }
  function TSInterfaceBody(node2) {
    printBraced(this, node2, () => this.printJoin(node2.body, true, true));
  }
  function TSTypeAliasDeclaration(node2) {
    const {
      declare,
      id,
      typeParameters,
      typeAnnotation
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation);
    this.semicolon();
  }
  function TSTypeExpression(node2) {
    const {
      type,
      expression,
      typeAnnotation
    } = node2;
    this.print(expression, true);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation);
  }
  function TSTypeAssertion(node2) {
    const {
      typeAnnotation,
      expression
    } = node2;
    this.tokenChar(60);
    this.print(typeAnnotation);
    this.tokenChar(62);
    this.space();
    this.print(expression);
  }
  function TSInstantiationExpression(node2) {
    this.print(node2.expression);
    {
      this.print(node2.typeParameters);
    }
  }
  function TSEnumDeclaration(node2) {
    const {
      declare,
      const: isConst,
      id
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id);
    this.space();
    {
      TSEnumBody.call(this, node2);
    }
  }
  function TSEnumBody(node2) {
    printBraced(this, node2, () => {
      var _this$shouldPrintTrai;
      return this.printList(node2.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
    });
  }
  function TSEnumMember(node2) {
    const {
      id,
      initializer
    } = node2;
    this.print(id);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer);
    }
  }
  function TSModuleDeclaration(node2) {
    const {
      declare,
      id,
      kind
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    {
      if (!node2.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node2.body) {
        this.semicolon();
        return;
      }
      let body = node2.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
  }
  function TSModuleBlock(node2) {
    printBraced(this, node2, () => this.printSequence(node2.body, true));
  }
  function TSImportType(node2) {
    const {
      argument,
      qualifier,
      options: options2
    } = node2;
    this.word("import");
    this.tokenChar(40);
    this.print(argument);
    if (options2) {
      this.tokenChar(44);
      this.print(options2);
    }
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier);
    }
    const typeArguments = node2.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSImportEqualsDeclaration(node2) {
    const {
      id,
      moduleReference
    } = node2;
    if (node2.isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
  }
  function TSExternalModuleReference(node2) {
    this.token("require(");
    this.print(node2.expression);
    this.tokenChar(41);
  }
  function TSNonNullExpression(node2) {
    this.print(node2.expression);
    this.tokenChar(33);
  }
  function TSExportAssignment(node2) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.expression);
    this.semicolon();
  }
  function TSNamespaceExportDeclaration(node2) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node2.id);
    this.semicolon();
  }
  function tsPrintSignatureDeclarationBase(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    const returnType = node2.typeAnnotation;
    this.print(returnType);
  }
  function tsPrintClassMemberModifiers(node2) {
    const isPrivateField = node2.type === "ClassPrivateProperty";
    const isPublicField = node2.type === "ClassAccessorProperty" || node2.type === "ClassProperty";
    printModifiersList(this, node2, [isPublicField && node2.declare && "declare", !isPrivateField && node2.accessibility]);
    if (node2.static) {
      this.word("static");
      this.space();
    }
    printModifiersList(this, node2, [!isPrivateField && node2.abstract && "abstract", !isPrivateField && node2.override && "override", (isPublicField || isPrivateField) && node2.readonly && "readonly"]);
  }
  function printBraced(printer2, node2, cb) {
    printer2.token("{");
    const exit = printer2.enterDelimited();
    cb();
    exit();
    printer2.rightBrace(node2);
  }
  function printModifiersList(printer2, node2, modifiers) {
    var _printer$tokenMap2;
    const modifiersSet = /* @__PURE__ */ new Set();
    for (const modifier of modifiers) {
      if (modifier) modifiersSet.add(modifier);
    }
    (_printer$tokenMap2 = printer2.tokenMap) == null || _printer$tokenMap2.find(node2, (tok) => {
      if (modifiersSet.has(tok.value)) {
        printer2.token(tok.value);
        printer2.space();
        modifiersSet.delete(tok.value);
        return modifiersSet.size === 0;
      }
      return false;
    });
    for (const modifier of modifiersSet) {
      printer2.word(modifier);
      printer2.space();
    }
  }
  return typescript;
}
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _templateLiterals = requireTemplateLiterals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = requireExpressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _expressions[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = requireStatements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _statements[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = requireClasses();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _classes[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = requireMethods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _methods[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = requireModules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _modules[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = requireTypes();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _types[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = requireFlow();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _flow[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = requireBase();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _base[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = requireJsx();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _jsx[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = requireTypescript();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _typescript[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  })(generators);
  return generators;
}
var deprecated = {};
var hasRequiredDeprecated;
function requireDeprecated() {
  if (hasRequiredDeprecated) return deprecated;
  hasRequiredDeprecated = 1;
  Object.defineProperty(deprecated, "__esModule", {
    value: true
  });
  deprecated.addDeprecatedGenerators = addDeprecatedGenerators;
  function addDeprecatedGenerators(PrinterClass) {
    {
      const deprecatedBabel7Generators = {
        Noop() {
        },
        TSExpressionWithTypeArguments(node2) {
          this.print(node2.expression);
          this.print(node2.typeParameters);
        },
        DecimalLiteral(node2) {
          const raw = this.getPossibleRaw(node2);
          if (!this.format.minified && raw !== void 0) {
            this.word(raw);
            return;
          }
          this.word(node2.value + "m");
        }
      };
      Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
    }
  }
  return deprecated;
}
var hasRequiredPrinter;
function requirePrinter() {
  if (hasRequiredPrinter) return printer$2;
  hasRequiredPrinter = 1;
  Object.defineProperty(printer$2, "__esModule", {
    value: true
  });
  printer$2.default = void 0;
  var _buffer = requireBuffer();
  var _index = requireNode();
  var n = _index;
  var _t2 = requireLib$5();
  var _tokenMap = requireTokenMap();
  var generatorFunctions = requireGenerators();
  var _deprecated = requireDeprecated();
  const {
    isExpression,
    isFunction,
    isStatement,
    isClassBody,
    isTSInterfaceBody,
    isTSEnumMember
  } = _t2;
  const SCIENTIFIC_NOTATION = /e/i;
  const ZERO_DECIMAL_INTEGER = /\.0+$/;
  const HAS_NEWLINE = /[\n\r\u2028\u2029]/;
  const HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
  function commentIsNewline(c2) {
    return c2.type === "CommentLine" || HAS_NEWLINE.test(c2.value);
  }
  const {
    needsParens
  } = n;
  class Printer {
    constructor(format, map, tokens = null, originalCode = null) {
      this.tokenContext = _index.TokenContext.normal;
      this._tokens = null;
      this._originalCode = null;
      this._currentNode = null;
      this._indent = 0;
      this._indentRepeat = 0;
      this._insideAux = false;
      this._noLineTerminator = false;
      this._noLineTerminatorAfterNode = null;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = /* @__PURE__ */ new Set();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this._endsWithDiv = false;
      this._lastCommentLine = 0;
      this._endsWithInnerRaw = false;
      this._indentInnerComments = true;
      this.tokenMap = null;
      this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
      this._printSemicolonBeforeNextNode = -1;
      this._printSemicolonBeforeNextToken = -1;
      this.format = format;
      this._tokens = tokens;
      this._originalCode = originalCode;
      this._indentRepeat = format.indent.style.length;
      this._inputMap = (map == null ? void 0 : map._inputMap) || null;
      this._buf = new _buffer.default(map, format.indent.style[0]);
    }
    enterForStatementInit() {
      this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate;
      return () => this.tokenContext = _index.TokenContext.normal;
    }
    enterForXStatementInit(isForOf) {
      if (isForOf) {
        this.tokenContext |= _index.TokenContext.forOfHead;
        return null;
      } else {
        this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = _index.TokenContext.normal;
      }
    }
    enterDelimited() {
      const oldTokenContext = this.tokenContext;
      const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
      if (!(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
        return () => {
        };
      }
      this._noLineTerminatorAfterNode = null;
      this.tokenContext = _index.TokenContext.normal;
      return () => {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        this.tokenContext = oldTokenContext;
      };
    }
    generate(ast) {
      if (this.format.preserveFormat) {
        this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
      }
      this.print(ast);
      this._maybeAddAuxComment();
      return this._buf.get();
    }
    indent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent++;
    }
    dedent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent--;
    }
    semicolon(force = false) {
      this._maybeAddAuxComment();
      if (force) {
        this._appendChar(59);
        this._noLineTerminator = false;
        return;
      }
      if (this.tokenMap) {
        const node2 = this._currentNode;
        if (node2.start != null && node2.end != null) {
          if (!this.tokenMap.endMatches(node2, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          const indexes = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
        }
      }
      this._queue(59);
      this._noLineTerminator = false;
    }
    rightBrace(node2) {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(125);
    }
    rightParens(node2) {
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(41);
    }
    space(force = false) {
      const {
        format
      } = this;
      if (format.compact || format.preserveFormat) return;
      if (force) {
        this._space();
      } else if (this._buf.hasContent()) {
        const lastCp = this.getLastChar();
        if (lastCp !== 32 && lastCp !== 10) {
          this._space();
        }
      }
    }
    word(str, noLineTerminatorAfter = false) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str);
      if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
        this._space();
      }
      this._append(str, false);
      this._endsWithWord = true;
      this._noLineTerminator = noLineTerminatorAfter;
    }
    number(str, number) {
      function isNonDecimalLiteral(str2) {
        if (str2.length > 2 && str2.charCodeAt(0) === 48) {
          const secondChar = str2.charCodeAt(1);
          return secondChar === 98 || secondChar === 111 || secondChar === 120;
        }
        return false;
      }
      this.word(str);
      this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    token(str, maybeNewline = false, occurrenceCount = 0) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str, occurrenceCount);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
      const lastChar = this.getLastChar();
      const strFirst = str.charCodeAt(0);
      if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
        this._space();
      }
      this._append(str, maybeNewline);
      this._noLineTerminator = false;
    }
    tokenChar(char) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      const str = String.fromCharCode(char);
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str);
      const lastChar = this.getLastChar();
      if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
        this._space();
      }
      this._appendChar(char);
      this._noLineTerminator = false;
    }
    newline(i = 1, force) {
      if (i <= 0) return;
      if (!force) {
        if (this.format.retainLines || this.format.compact) return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      if (i > 2) i = 2;
      i -= this._buf.getNewlineCount();
      for (let j2 = 0; j2 < i; j2++) {
        this._newline();
      }
      return;
    }
    endsWith(char) {
      return this.getLastChar() === char;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp("start", loc);
      this._buf.exactSource(loc, cb);
    }
    source(prop, loc) {
      if (!loc) return;
      this._catchUp(prop, loc);
      this._buf.source(prop, loc);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!loc || this.format.preserveFormat) return;
      this._catchUp(prop, loc);
      this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    sourceIdentifierName(identifierName, pos) {
      if (!this._buf._canMarkIdName) return;
      const sourcePosition = this._buf._sourcePosition;
      sourcePosition.identifierNamePos = pos;
      sourcePosition.identifierName = identifierName;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(str, occurrenceCount = 0) {
      const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
      if (token) this._catchUpTo(token.loc.start);
      if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
        this._buf.appendChar(59);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      this._printSemicolonBeforeNextToken = -1;
      this._printSemicolonBeforeNextNode = -1;
    }
    _append(str, maybeNewline) {
      this._maybeIndent(str.charCodeAt(0));
      this._buf.append(str, maybeNewline);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _appendChar(char) {
      this._maybeIndent(char);
      this._buf.appendChar(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _queue(char) {
      this._maybeIndent(char);
      this._buf.queue(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _maybeIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        this._buf.queueIndentation(this._getIndent());
      }
    }
    _shouldIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        return true;
      }
    }
    catchUp(line) {
      if (!this.format.retainLines) return;
      const count = line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
    _catchUp(prop, loc) {
      const {
        format
      } = this;
      if (!format.preserveFormat) {
        if (format.retainLines && loc != null && loc[prop]) {
          this.catchUp(loc[prop].line);
        }
        return;
      }
      const pos = loc == null ? void 0 : loc[prop];
      if (pos != null) this._catchUpTo(pos);
    }
    _catchUpTo({
      line,
      column,
      index
    }) {
      const count = line - this._buf.getCurrentLine();
      if (count > 0 && this._noLineTerminator) {
        return;
      }
      for (let i = 0; i < count; i++) {
        this._newline();
      }
      const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
      if (spacesCount > 0) {
        const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
        this._append(spaces, false);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(node2) {
      this._noLineTerminator = true;
      this.print(node2);
    }
    print(node2, noLineTerminatorAfter = false, trailingCommentsLineOffset) {
      var _node$extra, _node$leadingComments, _node$leadingComments2;
      if (!node2) return;
      this._endsWithInnerRaw = false;
      const nodeType = node2.type;
      const format = this.format;
      const oldConcise = format.concise;
      if (node2._compact) {
        format.concise = true;
      }
      const printMethod = this[nodeType];
      if (printMethod === void 0) {
        throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node2.constructor.name)}`);
      }
      const parent = this._currentNode;
      this._currentNode = node2;
      if (this.tokenMap) {
        this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
      }
      const oldInAux = this._insideAux;
      this._insideAux = node2.loc == null;
      this._maybeAddAuxComment(this._insideAux && !oldInAux);
      const parenthesized = (_node$extra = node2.extra) == null ? void 0 : _node$extra.parenthesized;
      let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node2, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!shouldPrintParens && parenthesized && (_node$leadingComments = node2.leadingComments) != null && _node$leadingComments.length && node2.leadingComments[0].type === "CommentBlock") {
        const parentType = parent == null ? void 0 : parent.type;
        switch (parentType) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (parent.callee !== node2) break;
          default:
            shouldPrintParens = true;
        }
      }
      let indentParenthesized = false;
      if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node2.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node2.loc && node2.loc.start.line > this._buf.getCurrentLine())) {
        shouldPrintParens = true;
        indentParenthesized = true;
      }
      let oldNoLineTerminatorAfterNode;
      let oldTokenContext;
      if (!shouldPrintParens) {
        noLineTerminatorAfter || (noLineTerminatorAfter = !!parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node2));
        if (noLineTerminatorAfter) {
          var _node$trailingComment;
          if ((_node$trailingComment = node2.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
            if (isExpression(node2)) shouldPrintParens = true;
          } else {
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = node2;
          }
        }
      }
      if (shouldPrintParens) {
        this.tokenChar(40);
        if (indentParenthesized) this.indent();
        this._endsWithInnerRaw = false;
        if (this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate) {
          oldTokenContext = this.tokenContext;
          this.tokenContext = _index.TokenContext.normal;
        }
        oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        this._noLineTerminatorAfterNode = null;
      }
      this._lastCommentLine = 0;
      this._printLeadingComments(node2, parent);
      const loc = nodeType === "Program" || nodeType === "File" ? null : node2.loc;
      this.exactSource(loc, printMethod.bind(this, node2, parent));
      if (shouldPrintParens) {
        this._printTrailingComments(node2, parent);
        if (indentParenthesized) {
          this.dedent();
          this.newline();
        }
        this.tokenChar(41);
        this._noLineTerminator = noLineTerminatorAfter;
        if (oldTokenContext) this.tokenContext = oldTokenContext;
      } else if (noLineTerminatorAfter && !this._noLineTerminator) {
        this._noLineTerminator = true;
        this._printTrailingComments(node2, parent);
      } else {
        this._printTrailingComments(node2, parent, trailingCommentsLineOffset);
      }
      this._currentNode = parent;
      format.concise = oldConcise;
      this._insideAux = oldInAux;
      if (oldNoLineTerminatorAfterNode !== void 0) {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
      }
      this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      const comment = this.format.auxiliaryCommentBefore;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      const comment = this.format.auxiliaryCommentAfter;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    getPossibleRaw(node2) {
      const extra = node2.extra;
      if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node2.value === extra.rawValue) {
        return extra.raw;
      }
    }
    printJoin(nodes, statement, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {
      if (!(nodes != null && nodes.length)) return;
      if (indent == null && this.format.retainLines) {
        var _nodes$0$loc;
        const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
        if (startLine != null && startLine !== this._buf.getCurrentLine()) {
          indent = true;
        }
      }
      if (indent) this.indent();
      const newlineOpts = {
        nextNodeStartLine: 0
      };
      const boundSeparator = separator == null ? void 0 : separator.bind(this);
      const len = nodes.length;
      for (let i = 0; i < len; i++) {
        const node2 = nodes[i];
        if (!node2) continue;
        if (statement) this._printNewline(i === 0, newlineOpts);
        this.print(node2, void 0, trailingCommentsLineOffset || 0);
        iterator == null || iterator(node2, i);
        if (boundSeparator != null) {
          if (i < len - 1) boundSeparator(i, false);
          else if (printTrailingSeparator) boundSeparator(i, true);
        }
        if (statement) {
          var _node$trailingComment2;
          if (!((_node$trailingComment2 = node2.trailingComments) != null && _node$trailingComment2.length)) {
            this._lastCommentLine = 0;
          }
          if (i + 1 === len) {
            this.newline(1);
          } else {
            var _nextNode$loc;
            const nextNode = nodes[i + 1];
            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
            this._printNewline(true, newlineOpts);
          }
        }
      }
      if (indent) this.dedent();
    }
    printAndIndentOnComments(node2) {
      const indent = node2.leadingComments && node2.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node2);
      if (indent) this.dedent();
    }
    printBlock(parent) {
      const node2 = parent.body;
      if (node2.type !== "EmptyStatement") {
        this.space();
      }
      this.print(node2);
    }
    _printTrailingComments(node2, parent, lineOffset) {
      const {
        innerComments,
        trailingComments
      } = node2;
      if (innerComments != null && innerComments.length) {
        this._printComments(2, innerComments, node2, parent, lineOffset);
      }
      if (trailingComments != null && trailingComments.length) {
        this._printComments(2, trailingComments, node2, parent, lineOffset);
      }
    }
    _printLeadingComments(node2, parent) {
      const comments2 = node2.leadingComments;
      if (!(comments2 != null && comments2.length)) return;
      this._printComments(0, comments2, node2, parent);
    }
    _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
      if (this._endsWithInnerRaw) {
        var _this$tokenMap;
        this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
      }
      this._endsWithInnerRaw = true;
      this._indentInnerComments = true;
    }
    printInnerComments(nextToken) {
      const node2 = this._currentNode;
      const comments2 = node2.innerComments;
      if (!(comments2 != null && comments2.length)) return;
      const hasSpace = this.endsWith(32);
      const indent = this._indentInnerComments;
      const printedCommentsCount = this._printedComments.size;
      if (indent) this.indent();
      this._printComments(1, comments2, node2, void 0, void 0, nextToken);
      if (hasSpace && printedCommentsCount !== this._printedComments.size) {
        this.space();
      }
      if (indent) this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(nodes, indent, trailingCommentsLineOffset) {
      this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, void 0, trailingCommentsLineOffset);
    }
    printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
      this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, iterator);
    }
    shouldPrintTrailingComma(listEnd) {
      if (!this.tokenMap) return null;
      const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
      if (listEndIndex <= 0) return null;
      return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
    }
    _printNewline(newLine, opts) {
      const format = this.format;
      if (format.retainLines || format.compact) return;
      if (format.concise) {
        this.space();
        return;
      }
      if (!newLine) {
        return;
      }
      const startLine = opts.nextNodeStartLine;
      const lastCommentLine = this._lastCommentLine;
      if (startLine > 0 && lastCommentLine > 0) {
        const offset = startLine - lastCommentLine;
        if (offset >= 0) {
          this.newline(offset || 1);
          return;
        }
      }
      if (this._buf.hasContent()) {
        this.newline(1);
      }
    }
    _shouldPrintComment(comment, nextToken) {
      if (comment.ignore) return 0;
      if (this._printedComments.has(comment)) return 0;
      if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
        return 2;
      }
      if (nextToken && this.tokenMap) {
        const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
        if (commentTok && commentTok.start > nextToken.start) {
          return 2;
        }
      }
      this._printedComments.add(comment);
      if (!this.format.shouldPrintComment(comment.value)) {
        return 0;
      }
      return 1;
    }
    _printComment(comment, skipNewLines) {
      const noLineTerminator = this._noLineTerminator;
      const isBlockComment = comment.type === "CommentBlock";
      const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
        this.newline(1);
      }
      const lastCharCode = this.getLastChar();
      if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
        this.space();
      }
      let val;
      if (isBlockComment) {
        val = `/*${comment.value}*/`;
        if (this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
          if (offset) {
            const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }
          if (this.format.concise) {
            val = val.replace(/\n(?!$)/g, `
`);
          } else {
            let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            if (this._shouldIndent(47) || this.format.retainLines) {
              indentSize += this._getIndent();
            }
            val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
          }
        }
      } else if (!noLineTerminator) {
        val = `//${comment.value}`;
      } else {
        val = `/*${comment.value}*/`;
      }
      if (this._endsWithDiv) this._space();
      if (this.tokenMap) {
        const {
          _printSemicolonBeforeNextToken,
          _printSemicolonBeforeNextNode
        } = this;
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
        this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
        this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
      } else {
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
      }
      if (!isBlockComment && !noLineTerminator) {
        this.newline(1, true);
      }
      if (printNewLines && skipNewLines !== 3) {
        this.newline(1);
      }
    }
    _printComments(type, comments2, node2, parent, lineOffset = 0, nextToken) {
      const nodeLoc = node2.loc;
      const len = comments2.length;
      let hasLoc = !!nodeLoc;
      const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
      const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
      let lastLine = 0;
      let leadingCommentNewline = 0;
      const maybeNewline = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let i = 0; i < len; i++) {
        const comment = comments2[i];
        const shouldPrint = this._shouldPrintComment(comment, nextToken);
        if (shouldPrint === 2) {
          hasLoc = false;
          break;
        }
        if (hasLoc && comment.loc && shouldPrint === 1) {
          const commentStartLine = comment.loc.start.line;
          const commentEndLine = comment.loc.end.line;
          if (type === 0) {
            let offset = 0;
            if (i === 0) {
              if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                offset = leadingCommentNewline = 1;
              }
            } else {
              offset = commentStartLine - lastLine;
            }
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
              lastLine = nodeStartLine;
            }
          } else if (type === 1) {
            const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.min(1, nodeEndLine - lastLine));
              lastLine = nodeEndLine;
            }
          } else {
            const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
          }
        } else {
          hasLoc = false;
          if (shouldPrint !== 1) {
            continue;
          }
          if (len === 1) {
            const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
            const shouldSkipNewline = singleLine && !isStatement(node2) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node2);
            if (type === 0) {
              this._printComment(comment, shouldSkipNewline && node2.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                body: node2
              }) ? 1 : 0);
            } else if (shouldSkipNewline && type === 2) {
              this._printComment(comment, 1);
            } else {
              this._printComment(comment, 0);
            }
          } else if (type === 1 && !(node2.type === "ObjectExpression" && node2.properties.length > 1) && node2.type !== "ClassBody" && node2.type !== "TSInterfaceBody") {
            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
          } else {
            this._printComment(comment, 0);
          }
        }
      }
      if (type === 2 && hasLoc && lastLine) {
        this._lastCommentLine = lastLine;
      }
    }
  }
  Object.assign(Printer.prototype, generatorFunctions);
  {
    (0, _deprecated.addDeprecatedGenerators)(Printer);
  }
  printer$2.default = Printer;
  function commaSeparator(occurrenceCount, last) {
    this.token(",", false, occurrenceCount);
    if (!last) this.space();
  }
  return printer$2;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$3;
  hasRequiredLib$4 = 1;
  Object.defineProperty(lib$3, "__esModule", {
    value: true
  });
  lib$3.default = void 0;
  lib$3.generate = generate;
  var _sourceMap = requireSourceMap();
  var _printer = requirePrinter();
  function normalizeOptions(code, opts, ast) {
    if (opts.experimental_preserveFormat) {
      if (typeof code !== "string") {
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      }
      if (!opts.retainLines) {
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      }
      if (opts.compact && opts.compact !== "auto") {
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      }
      if (opts.minified) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      }
      if (opts.jsescOption) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      }
      if (!Array.isArray(ast.tokens)) {
        throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.");
      }
    }
    const format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      preserveFormat: opts.experimental_preserveFormat,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      topicToken: opts.topicToken,
      importAttributesKeyword: opts.importAttributesKeyword
    };
    {
      var _opts$recordAndTupleS;
      format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format.jsescOption.json = opts.jsonCompatibleStrings;
      format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
    }
    if (format.minified) {
      format.compact = true;
      format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
      format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
    }
    if (format.compact === "auto") {
      format.compact = typeof code === "string" && code.length > 5e5;
      if (format.compact) {
        console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
      }
    }
    if (format.compact || format.preserveFormat) {
      format.indent.adjustMultilineComment = false;
    }
    const {
      auxiliaryCommentBefore,
      auxiliaryCommentAfter,
      shouldPrintComment
    } = format;
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
      format.auxiliaryCommentBefore = void 0;
    }
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
      format.auxiliaryCommentAfter = void 0;
    }
    return format;
  }
  {
    lib$3.CodeGenerator = class CodeGenerator {
      constructor(ast, opts = {}, code) {
        this._ast = void 0;
        this._format = void 0;
        this._map = void 0;
        this._ast = ast;
        this._format = normalizeOptions(code, opts, ast);
        this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      }
      generate() {
        const printer2 = new _printer.default(this._format, this._map);
        return printer2.generate(this._ast);
      }
    };
  }
  function generate(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts, ast);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    const printer2 = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
    return printer2.generate(ast);
  }
  lib$3.default = generate;
  return lib$3;
}
var ancestry = {};
var hasRequiredAncestry;
function requireAncestry() {
  if (hasRequiredAncestry) return ancestry;
  hasRequiredAncestry = 1;
  Object.defineProperty(ancestry, "__esModule", {
    value: true
  });
  ancestry.find = find;
  ancestry.findParent = findParent;
  ancestry.getAncestry = getAncestry;
  ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  ancestry.getFunctionParent = getFunctionParent;
  ancestry.getStatementParent = getStatementParent;
  ancestry.inType = inType;
  ancestry.isAncestor = isAncestor;
  ancestry.isDescendant = isDescendant;
  var _t2 = requireLib$5();
  const {
    VISITOR_KEYS
  } = _t2;
  function findParent(callback) {
    let path2 = this;
    while (path2 = path2.parentPath) {
      if (callback(path2)) return path2;
    }
    return null;
  }
  function find(callback) {
    let path2 = this;
    do {
      if (callback(path2)) return path2;
    } while (path2 = path2.parentPath);
    return null;
  }
  function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
  }
  function getStatementParent() {
    let path2 = this;
    do {
      if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement()) {
        break;
      } else {
        path2 = path2.parentPath;
      }
    } while (path2);
    if (path2 && (path2.isProgram() || path2.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path2;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
      let earliest;
      const keys = VISITOR_KEYS[deepest.type];
      for (const ancestry2 of ancestries) {
        const path2 = ancestry2[i + 1];
        if (!earliest) {
          earliest = path2;
          continue;
        }
        if (path2.listKey && earliest.listKey === path2.listKey) {
          if (path2.key < earliest.key) {
            earliest = path2;
            continue;
          }
        }
        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path2.parentKey);
        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path2;
        }
      }
      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map((path2) => {
      const ancestry2 = [];
      do {
        ancestry2.unshift(path2);
      } while ((path2 = path2.parentPath) && path2 !== this);
      if (ancestry2.length < minDepth) {
        minDepth = ancestry2.length;
      }
      return ancestry2;
    });
    const first = ancestries[0];
    depthLoop: for (let i = 0; i < minDepth; i++) {
      const shouldMatch = first[i];
      for (const ancestry2 of ancestries) {
        if (ancestry2[i] !== shouldMatch) {
          break depthLoop;
        }
      }
      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    let path2 = this;
    const paths = [];
    do {
      paths.push(path2);
    } while (path2 = path2.parentPath);
    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
  }
  function inType(...candidateTypes) {
    let path2 = this;
    while (path2) {
      if (candidateTypes.includes(path2.node.type)) return true;
      path2 = path2.parentPath;
    }
    return false;
  }
  return ancestry;
}
var inference = {};
var inferers = {};
var infererReference = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", {
    value: true
  });
  util.createUnionType = createUnionType;
  var _t2 = requireLib$5();
  const {
    createFlowUnionType: createFlowUnionType2,
    createTSUnionType: createTSUnionType2,
    createUnionTypeAnnotation,
    isFlowType,
    isTSType
  } = _t2;
  function createUnionType(types2) {
    {
      if (types2.every((v2) => isFlowType(v2))) {
        if (createFlowUnionType2) {
          return createFlowUnionType2(types2);
        }
        return createUnionTypeAnnotation(types2);
      } else if (types2.every((v2) => isTSType(v2))) {
        if (createTSUnionType2) {
          return createTSUnionType2(types2);
        }
      }
    }
  }
  return util;
}
var hasRequiredInfererReference;
function requireInfererReference() {
  if (hasRequiredInfererReference) return infererReference;
  hasRequiredInfererReference = 1;
  Object.defineProperty(infererReference, "__esModule", {
    value: true
  });
  infererReference.default = _default;
  var _t2 = requireLib$5();
  var _util = requireUtil();
  const {
    BOOLEAN_NUMBER_BINARY_OPERATORS,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof2,
    numberTypeAnnotation,
    voidTypeAnnotation
  } = _t2;
  function _default(node2) {
    if (!this.isReferenced()) return;
    const binding2 = this.scope.getBinding(node2.name);
    if (binding2) {
      if (binding2.identifier.typeAnnotation) {
        return binding2.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding2, this, node2.name);
      }
    }
    if (node2.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node2.name === "NaN" || node2.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node2.name === "arguments") ;
  }
  function getTypeAnnotationBindingConstantViolations(binding2, path2, name) {
    const types2 = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding2, path2, functionConstantViolations);
    const testType = getConditionalAnnotation(binding2, path2, name);
    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(binding2, testType.ifStatement);
      constantViolations = constantViolations.filter((path3) => !testConstantViolations.includes(path3));
      types2.push(testType.typeAnnotation);
    }
    if (constantViolations.length) {
      constantViolations.push(...functionConstantViolations);
      for (const violation of constantViolations) {
        types2.push(violation.getTypeAnnotation());
      }
    }
    if (!types2.length) {
      return;
    }
    return (0, _util.createUnionType)(types2);
  }
  function getConstantViolationsBefore(binding2, path2, functions) {
    const violations = binding2.constantViolations.slice();
    violations.unshift(binding2.path);
    return violations.filter((violation) => {
      violation = violation.resolve();
      const status = violation._guessExecutionStatusRelativeTo(path2);
      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }
  function inferAnnotationFromBinaryExpression(name, path2) {
    const operator = path2.node.operator;
    const right = path2.get("right").resolve();
    const left = path2.get("left").resolve();
    let target;
    if (left.isIdentifier({
      name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name
    })) {
      target = left;
    }
    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }
      if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      }
      return;
    }
    if (operator !== "===" && operator !== "==") return;
    let typeofPath;
    let typePath;
    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }
    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof2(typeValue);
  }
  function getParentConditionalPath(binding2, path2, name) {
    let parentPath;
    while (parentPath = path2.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path2.key === "test") {
          return;
        }
        return parentPath;
      }
      if (parentPath.isFunction()) {
        if (name == null || parentPath.parentPath.scope.getBinding(name) !== binding2) return;
      }
      path2 = parentPath;
    }
  }
  function getConditionalAnnotation(binding2, path2, name) {
    const ifStatement = getParentConditionalPath(binding2, path2, name);
    if (!ifStatement) return;
    const test = ifStatement.get("test");
    const paths = [test];
    const types2 = [];
    for (let i = 0; i < paths.length; i++) {
      const path3 = paths[i];
      if (path3.isLogicalExpression()) {
        if (path3.node.operator === "&&") {
          paths.push(path3.get("left"));
          paths.push(path3.get("right"));
        }
      } else if (path3.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path3);
        if (type) types2.push(type);
      }
    }
    if (types2.length) {
      return {
        typeAnnotation: (0, _util.createUnionType)(types2),
        ifStatement
      };
    }
    return getConditionalAnnotation(binding2, ifStatement, name);
  }
  return infererReference;
}
var hasRequiredInferers;
function requireInferers() {
  if (hasRequiredInferers) return inferers;
  hasRequiredInferers = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1.ArrayExpression = ArrayExpression;
    exports$1.AssignmentExpression = AssignmentExpression;
    exports$1.BinaryExpression = BinaryExpression;
    exports$1.BooleanLiteral = BooleanLiteral;
    exports$1.CallExpression = CallExpression;
    exports$1.ConditionalExpression = ConditionalExpression;
    exports$1.ClassDeclaration = exports$1.ClassExpression = exports$1.FunctionDeclaration = exports$1.ArrowFunctionExpression = exports$1.FunctionExpression = Func;
    Object.defineProperty(exports$1, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports$1.LogicalExpression = LogicalExpression;
    exports$1.NewExpression = NewExpression;
    exports$1.NullLiteral = NullLiteral;
    exports$1.NumericLiteral = NumericLiteral;
    exports$1.ObjectExpression = ObjectExpression;
    exports$1.ParenthesizedExpression = ParenthesizedExpression;
    exports$1.RegExpLiteral = RegExpLiteral;
    exports$1.RestElement = RestElement;
    exports$1.SequenceExpression = SequenceExpression;
    exports$1.StringLiteral = StringLiteral;
    exports$1.TSAsExpression = TSAsExpression;
    exports$1.TSNonNullExpression = TSNonNullExpression;
    exports$1.TaggedTemplateExpression = TaggedTemplateExpression;
    exports$1.TemplateLiteral = TemplateLiteral;
    exports$1.TypeCastExpression = TypeCastExpression;
    exports$1.UnaryExpression = UnaryExpression;
    exports$1.UpdateExpression = UpdateExpression;
    exports$1.VariableDeclarator = VariableDeclarator;
    var _t2 = requireLib$5();
    var _infererReference = requireInfererReference();
    var _util = requireUtil();
    const {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression: buildMatchMemberExpression2,
      genericTypeAnnotation,
      identifier: identifier2,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t2;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node2) {
      return node2.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node2) {
      return node2.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node2) {
      if (node2.callee.type === "Identifier") {
        return genericTypeAnnotation(node2.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node2) {
      const operator = node2.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node2) {
      const operator = node2.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node2) {
      const operator = node2.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier2("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier2("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier2("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier2("Function"));
    }
    const isArrayFrom = buildMatchMemberExpression2("Array.from");
    const isObjectKeys = buildMatchMemberExpression2("Object.keys");
    const isObjectValues = buildMatchMemberExpression2("Object.values");
    const isObjectEntries = buildMatchMemberExpression2("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node: node2
        } = callee;
        if (node2.async) {
          if (node2.generator) {
            return genericTypeAnnotation(identifier2("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier2("Promise"));
          }
        } else {
          if (node2.generator) {
            return genericTypeAnnotation(identifier2("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else ;
        }
      }
    }
  })(inferers);
  return inferers;
}
var hasRequiredInference;
function requireInference() {
  if (hasRequiredInference) return inference;
  hasRequiredInference = 1;
  Object.defineProperty(inference, "__esModule", {
    value: true
  });
  inference._getTypeAnnotation = _getTypeAnnotation;
  inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  inference.couldBeBaseType = couldBeBaseType;
  inference.getTypeAnnotation = getTypeAnnotation;
  inference.isBaseType = isBaseType;
  inference.isGenericType = isGenericType;
  var inferers2 = requireInferers();
  var _t2 = requireLib$5();
  const {
    anyTypeAnnotation,
    isAnyTypeAnnotation,
    isArrayTypeAnnotation,
    isBooleanTypeAnnotation,
    isEmptyTypeAnnotation,
    isFlowBaseAnnotation,
    isGenericTypeAnnotation,
    isIdentifier,
    isMixedTypeAnnotation,
    isNumberTypeAnnotation,
    isStringTypeAnnotation,
    isTSArrayType,
    isTSTypeAnnotation,
    isTSTypeReference,
    isTupleTypeAnnotation,
    isTypeAnnotation,
    isUnionTypeAnnotation,
    isVoidTypeAnnotation,
    stringTypeAnnotation,
    voidTypeAnnotation
  } = _t2;
  function getTypeAnnotation() {
    let type = this.getData("typeAnnotation");
    if (type != null) {
      return type;
    }
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
    if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
      type = type.typeAnnotation;
    }
    this.setData("typeAnnotation", type);
    return type;
  }
  const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
  function _getTypeAnnotation() {
    const node2 = this.node;
    if (!node2) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }
        return voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node2.typeAnnotation) {
      return node2.typeAnnotation;
    }
    if (typeAnnotationInferringNodes.has(node2)) {
      return;
    }
    typeAnnotationInferringNodes.add(node2);
    try {
      var _inferer;
      let inferer = inferers2[node2.type];
      if (inferer) {
        return inferer.call(this, node2);
      }
      inferer = inferers2[this.parentPath.type];
      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node2);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }
  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  }
  function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;
    if (isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();
    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
    return false;
  }
  function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    if (genericName === "Array") {
      if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
        return true;
      }
    }
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
      name: genericName
    });
  }
  return inference;
}
var replacement = {};
var lib$2 = {};
var picocolors_browser = { exports: {} };
var hasRequiredPicocolors_browser;
function requirePicocolors_browser() {
  if (hasRequiredPicocolors_browser) return picocolors_browser.exports;
  hasRequiredPicocolors_browser = 1;
  var x2 = String;
  var create = function() {
    return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
  };
  picocolors_browser.exports = create();
  picocolors_browser.exports.createColors = create;
  return picocolors_browser.exports;
}
var jsTokens = {};
var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens;
  hasRequiredJsTokens = 1;
  Object.defineProperty(jsTokens, "__esModule", {
    value: true
  });
  jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  jsTokens.matchToToken = function(match) {
    var token = { type: "invalid", value: match[0], closed: void 0 };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5]) token.type = "comment";
    else if (match[6]) token.type = "comment", token.closed = !!match[7];
    else if (match[8]) token.type = "regex";
    else if (match[9]) token.type = "number";
    else if (match[10]) token.type = "name";
    else if (match[11]) token.type = "punctuator";
    else if (match[12]) token.type = "whitespace";
    return token;
  };
  return jsTokens;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$2, "__esModule", { value: true });
  var picocolors = /* @__PURE__ */ requirePicocolors_browser();
  var jsTokens2 = requireJsTokens();
  var helperValidatorIdentifier = requireLib$7();
  function isColorSupported() {
    return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
  }
  const compose = (f2, g2) => (v2) => f2(g2(v2));
  function buildDefs(colors) {
    return {
      keyword: colors.cyan,
      capitalized: colors.yellow,
      jsxIdentifier: colors.yellow,
      punctuator: colors.yellow,
      number: colors.magenta,
      string: colors.green,
      regex: colors.magenta,
      comment: colors.gray,
      invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
      gutter: colors.gray,
      marker: compose(colors.red, colors.bold),
      message: compose(colors.red, colors.bold),
      reset: colors.reset
    };
  }
  const defsOn = buildDefs(picocolors.createColors(true));
  const defsOff = buildDefs(picocolors.createColors(false));
  function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
  }
  const sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  const BRACKET = /^[()[\]{}]$/;
  let tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = jsTokens2.default.exec(text)) {
        const token = jsTokens2.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  function highlight(text) {
    if (text === "") return "";
    const defs = getDefs(true);
    let highlighted = "";
    for (const {
      type,
      value
    } of tokenize(text)) {
      if (type in defs) {
        highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
      } else {
        highlighted += value;
      }
    }
    return highlighted;
  }
  let deprecationWarningShown = false;
  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
      const number = start + 1 + index2;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + defs.message(opts.message);
          }
        }
        return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (shouldHighlight) {
      return defs.reset(frame);
    } else {
      return frame;
    }
  }
  function index(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
  lib$2.codeFrameColumns = codeFrameColumns;
  lib$2.default = index;
  lib$2.highlight = highlight;
  return lib$2;
}
var modification = {};
var removal = {};
var removalHooks = {};
var hasRequiredRemovalHooks;
function requireRemovalHooks() {
  if (hasRequiredRemovalHooks) return removalHooks;
  hasRequiredRemovalHooks = 1;
  Object.defineProperty(removalHooks, "__esModule", {
    value: true
  });
  removalHooks.hooks = void 0;
  removalHooks.hooks = [function(self2, parent) {
    const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function(self2, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function(self2, parent) {
    if (parent.isBinary()) {
      if (self2.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  }, function(self2, parent) {
    if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self2.replaceWith({
        type: "BlockStatement",
        directives: [],
        body: []
      });
      return true;
    }
  }];
  return removalHooks;
}
var hasRequiredRemoval;
function requireRemoval() {
  if (hasRequiredRemoval) return removal;
  hasRequiredRemoval = 1;
  Object.defineProperty(removal, "__esModule", {
    value: true
  });
  removal._assertUnremoved = _assertUnremoved;
  removal._callRemovalHooks = _callRemovalHooks;
  removal._markRemoved = _markRemoved;
  removal._remove = _remove;
  removal._removeFromScope = _removeFromScope;
  removal.remove = remove;
  var _removalHooks = requireRemovalHooks();
  var _cache = requireCache();
  var _replacement = requireReplacement();
  var _index = requirePath();
  var t = requireLib$5();
  var _modification = requireModification();
  var _context = requireContext();
  function remove() {
    var _this$opts;
    _assertUnremoved.call(this);
    _context.resync.call(this);
    if (_callRemovalHooks.call(this)) {
      _markRemoved.call(this);
      return;
    }
    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      _removeFromScope.call(this);
    }
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
  }
  function _removeFromScope() {
    const bindings = t.getBindingIdentifiers(this.node, false, false, true);
    Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
  }
  function _callRemovalHooks() {
    if (this.parentPath) {
      for (const fn2 of _removalHooks.hooks) {
        if (fn2(this, this.parentPath)) return true;
      }
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      _modification.updateSiblingKeys.call(this, this.key, -1);
    } else {
      _replacement._replaceWith.call(this, null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
    if (this.parent) {
      var _getCachedPaths;
      (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    }
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
  return removal;
}
var hoister = {};
var hasRequiredHoister;
function requireHoister() {
  if (hasRequiredHoister) return hoister;
  hasRequiredHoister = 1;
  Object.defineProperty(hoister, "__esModule", {
    value: true
  });
  hoister.default = void 0;
  var _t2 = requireLib$5();
  var _t22 = _t2;
  const {
    react
  } = _t2;
  const {
    cloneNode: cloneNode2,
    jsxExpressionContainer,
    variableDeclaration,
    variableDeclarator
  } = _t22;
  const referenceVisitor = {
    ReferencedIdentifier(path2, state) {
      if (path2.isJSXIdentifier() && react.isCompatTag(path2.node.name) && !path2.parentPath.isJSXMemberExpression()) {
        return;
      }
      if (path2.node.name === "this") {
        let scope2 = path2.scope;
        do {
          if (scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope2 = scope2.parent);
        if (scope2) state.breakOnScopePaths.push(scope2.path);
      }
      const binding2 = path2.scope.getBinding(path2.node.name);
      if (!binding2) return;
      for (const violation of binding2.constantViolations) {
        if (violation.scope !== binding2.path.scope) {
          state.mutableBinding = true;
          path2.stop();
          return;
        }
      }
      if (binding2 !== state.scope.getBinding(path2.node.name)) return;
      state.bindings[path2.node.name] = binding2;
    }
  };
  class PathHoister {
    constructor(path2, scope2) {
      this.breakOnScopePaths = void 0;
      this.bindings = void 0;
      this.mutableBinding = void 0;
      this.scopes = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.attachAfter = void 0;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope2;
      this.path = path2;
      this.attachAfter = false;
    }
    isCompatibleScope(scope2) {
      for (const key of Object.keys(this.bindings)) {
        const binding2 = this.bindings[key];
        if (!scope2.bindingIdentifierEquals(key, binding2.identifier)) {
          return false;
        }
      }
      return true;
    }
    getCompatibleScopes() {
      let scope2 = this.path.scope;
      do {
        if (this.isCompatibleScope(scope2)) {
          this.scopes.push(scope2);
        } else {
          break;
        }
        if (this.breakOnScopePaths.includes(scope2.path)) {
          break;
        }
      } while (scope2 = scope2.parent);
    }
    getAttachmentPath() {
      let path2 = this._getAttachmentPath();
      if (!path2) return;
      let targetScope = path2.scope;
      if (targetScope.path === path2) {
        targetScope = path2.scope.parent;
      }
      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (const name of Object.keys(this.bindings)) {
          if (!targetScope.hasOwnBinding(name)) continue;
          const binding2 = this.bindings[name];
          if (binding2.kind === "param" || binding2.path.parentKey === "params") {
            continue;
          }
          const bindingParentPath = this.getAttachmentParentForPath(binding2.path);
          if (bindingParentPath.key >= path2.key) {
            this.attachAfter = true;
            path2 = binding2.path;
            for (const violationPath of binding2.constantViolations) {
              if (this.getAttachmentParentForPath(violationPath).key > path2.key) {
                path2 = violationPath;
              }
            }
          }
        }
      }
      return path2;
    }
    _getAttachmentPath() {
      const scopes = this.scopes;
      const scope2 = scopes.pop();
      if (!scope2) return;
      if (scope2.path.isFunction()) {
        if (this.hasOwnParamBindings(scope2)) {
          if (this.scope === scope2) return;
          const bodies = scope2.path.get("body").get("body");
          for (let i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope2.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const scope2 = this.scopes.pop();
      if (scope2) return this.getAttachmentParentForPath(scope2.path);
    }
    getAttachmentParentForPath(path2) {
      do {
        if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement()) {
          return path2;
        }
      } while (path2 = path2.parentPath);
      return path2;
    }
    hasOwnParamBindings(scope2) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope2.hasOwnBinding(name)) continue;
        const binding2 = this.bindings[name];
        if (binding2.kind === "param" && binding2.constant) return true;
      }
      return false;
    }
    run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = variableDeclarator(uid, this.path.node);
      const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
      const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
      const parent = this.path.parentPath;
      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }
      this.path.replaceWith(cloneNode2(uid));
      return attached.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  }
  hoister.default = PathHoister;
  return hoister;
}
var hasRequiredModification;
function requireModification() {
  if (hasRequiredModification) return modification;
  hasRequiredModification = 1;
  Object.defineProperty(modification, "__esModule", {
    value: true
  });
  modification._containerInsert = _containerInsert;
  modification._containerInsertAfter = _containerInsertAfter;
  modification._containerInsertBefore = _containerInsertBefore;
  modification._verifyNodeList = _verifyNodeList;
  modification.insertAfter = insertAfter;
  modification.insertBefore = insertBefore;
  modification.pushContainer = pushContainer;
  modification.unshiftContainer = unshiftContainer;
  modification.updateSiblingKeys = updateSiblingKeys;
  var _cache = requireCache();
  var _index = requirePath();
  var _context = requireContext();
  var _removal = requireRemoval();
  var _t2 = requireLib$5();
  var _hoister = requireHoister();
  const {
    arrowFunctionExpression,
    assertExpression,
    assignmentExpression,
    blockStatement,
    callExpression,
    cloneNode: cloneNode2,
    expressionStatement,
    isAssignmentExpression,
    isCallExpression,
    isExportNamedDeclaration,
    isExpression,
    isIdentifier,
    isSequenceExpression,
    isSuper,
    thisExpression
  } = _t2;
  function insertBefore(nodes_) {
    _removal._assertUnremoved.call(this);
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertBefore.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return blockPath.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    updateSiblingKeys.call(this, from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);
    for (let i = 0; i < nodes.length; i++) {
      var _this$context;
      const to2 = from + i;
      const path2 = this.getSibling(to2);
      paths.push(path2);
      if ((_this$context = this.context) != null && _this$context.queue) {
        _context.pushContext.call(path2, this.context);
      }
    }
    const contexts = _context._getQueueContexts.call(this);
    for (const path2 of paths) {
      _context.setScope.call(path2);
      path2.debug("Inserted.");
      for (const context2 of contexts) {
        context2.maybeQueue(path2, true);
      }
    }
    return paths;
  }
  function _containerInsertBefore(nodes) {
    return _containerInsert.call(this, this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return _containerInsert.call(this, this.key + 1, nodes);
  }
  const last = (arr) => arr[arr.length - 1];
  function isHiddenInSequenceExpression(path2) {
    return isSequenceExpression(path2.parent) && (last(path2.parent.expressions) !== path2.node || isHiddenInSequenceExpression(path2.parentPath));
  }
  function isAlmostConstantAssignment(node2, scope2) {
    if (!isAssignmentExpression(node2) || !isIdentifier(node2.left)) {
      return false;
    }
    const blockScope = scope2.getBlockParent();
    return blockScope.hasOwnBinding(node2.left.name) && blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1;
  }
  function insertAfter(nodes_) {
    _removal._assertUnremoved.call(this);
    if (this.isSequenceExpression()) {
      return last(this.get("expressions")).insertAfter(nodes_);
    }
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map((node2) => {
        return isExpression(node2) ? expressionStatement(node2) : node2;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      const self2 = this;
      if (self2.node) {
        const node2 = self2.node;
        let {
          scope: scope2
        } = this;
        if (scope2.path.isPattern()) {
          assertExpression(node2);
          self2.replaceWith(callExpression(arrowFunctionExpression([], node2), []));
          self2.get("callee.body").insertAfter(nodes);
          return [self2];
        }
        if (isHiddenInSequenceExpression(self2)) {
          nodes.unshift(node2);
        } else if (isCallExpression(node2) && isSuper(node2.callee)) {
          nodes.unshift(node2);
          nodes.push(thisExpression());
        } else if (isAlmostConstantAssignment(node2, scope2)) {
          nodes.unshift(node2);
          nodes.push(cloneNode2(node2.left));
        } else if (scope2.isPure(node2, true)) {
          nodes.push(node2);
        } else {
          if (parentPath.isMethod({
            computed: true,
            key: node2
          })) {
            scope2 = scope2.parent;
          }
          const temp = scope2.generateDeclaredUidIdentifier();
          nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode2(temp), node2)));
          nodes.push(expressionStatement(cloneNode2(temp)));
        }
      }
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertAfter.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return blockPath.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    const paths = (0, _cache.getCachedPaths)(this);
    if (!paths) return;
    for (const [, path2] of paths) {
      if (typeof path2.key === "number" && path2.container === this.container && path2.key >= fromIndex) {
        path2.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      let msg;
      if (!node2) {
        msg = "has falsy node";
      } else if (typeof node2 !== "object") {
        msg = "contains a non-object node";
      } else if (!node2.type) {
        msg = "without a type";
      } else if (node2 instanceof _index.default) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        const type = Array.isArray(node2) ? "array" : typeof node2;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }
    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes);
    const container = this.node[listKey];
    const path2 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: 0
    }).setContext(this.context);
    return _containerInsertBefore.call(path2, verifiedNodes);
  }
  function pushContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes);
    const container = this.node[listKey];
    const path2 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: container.length
    }).setContext(this.context);
    return path2.replaceWithMultiple(verifiedNodes);
  }
  {
    modification.hoist = function hoist(scope2 = this.scope) {
      const hoister2 = new _hoister.default(this, scope2);
      return hoister2.run();
    };
  }
  return modification;
}
var lib$1 = {};
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  Object.defineProperty(lib$1, "__esModule", {
    value: true
  });
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  class Position {
    constructor(line, col, index) {
      this.line = void 0;
      this.column = void 0;
      this.index = void 0;
      this.line = line;
      this.column = col;
      this.index = index;
    }
  }
  class SourceLocation {
    constructor(start, end) {
      this.start = void 0;
      this.end = void 0;
      this.filename = void 0;
      this.identifierName = void 0;
      this.start = start;
      this.end = end;
    }
  }
  function createPositionWithColumnOffset(position, columnOffset) {
    const {
      line,
      column,
      index
    } = position;
    return new Position(line, column + columnOffset, index + columnOffset);
  }
  const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code
    }
  };
  const NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  };
  const toNodeDescription = (node2) => node2.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node2.prefix}`] : NodeDescriptions[node2.type];
  var StandardErrors = {
    AccessorIsGenerator: ({
      kind
    }) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind
    }) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName
    }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName,
      exportName
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type
    }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type
    }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: ({
      importName
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix
    }) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord
    }) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({
      identifierName
    }) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({
      ancestor
    }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({
      ancestor
    }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor
    }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected
    }) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName
    }) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName
    }) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin
    }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key
    }) => `Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode
    }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName
    }) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName
    }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName
    }) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword: keyword2
    }) => `Unexpected keyword '${keyword2}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord
    }) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected,
      unexpected
    }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
    UnexpectedVoidPattern: "Unexpected void binding.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target,
      onlyValidPropertyName
    }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName
    }) => `Identifier '${identifierName}' has already been declared.`,
    VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
    VoidPatternInitializer: "A void binding may not have an initializer.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  };
  var StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName
    }) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName
    }) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  var ParseExpressionErrors = {
    ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
    ParseExpressionExpectsEOF: ({
      unexpected
    }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
  };
  const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = Object.assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token
    }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type
    }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
      type
    })}; please wrap it in parentheses.`
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  });
  const _excluded = ["message"];
  function defineHidden(obj, key, value) {
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      value
    });
  }
  function toParseErrorConstructor({
    toMessage,
    code: code2,
    reasonCode,
    syntaxPlugin
  }) {
    const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
    {
      const oldReasonCodes = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      if (oldReasonCodes[reasonCode]) {
        reasonCode = oldReasonCodes[reasonCode];
      }
    }
    return function constructor(loc, details) {
      const error = new SyntaxError();
      error.code = code2;
      error.reasonCode = reasonCode;
      error.loc = loc;
      error.pos = loc.index;
      error.syntaxPlugin = syntaxPlugin;
      if (hasMissingPlugin) {
        error.missingPlugin = details.missingPlugin;
      }
      defineHidden(error, "clone", function clone2(overrides = {}) {
        var _overrides$loc;
        const {
          line,
          column,
          index
        } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
        return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
      });
      defineHidden(error, "details", details);
      Object.defineProperty(error, "message", {
        configurable: true,
        get() {
          const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
          this.message = message;
          return message;
        },
        set(value) {
          Object.defineProperty(this, "message", {
            value,
            writable: true
          });
        }
      });
      return error;
    };
  }
  function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
      return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    }
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)) {
      const template = argument[reasonCode];
      const _ref = typeof template === "string" ? {
        message: () => template
      } : typeof template === "function" ? {
        message: template
      } : template, {
        message
      } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
      const toMessage = typeof message === "string" ? () => message : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode,
        toMessage
      }, syntaxPlugin ? {
        syntaxPlugin
      } : {}, rest));
    }
    return ParseErrorConstructors;
  }
  const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
  function createDefaultOptions() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      allowYieldOutsideFunction: false,
      plugins: [],
      strictMode: void 0,
      ranges: false,
      tokens: false,
      createImportExpressions: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
  }
  function getOptions(opts) {
    const options2 = createDefaultOptions();
    if (opts == null) {
      return options2;
    }
    if (opts.annexB != null && opts.annexB !== false) {
      throw new Error("The `annexB` option can only be set to `false`.");
    }
    for (const key of Object.keys(options2)) {
      if (opts[key] != null) options2[key] = opts[key];
    }
    if (options2.startLine === 1) {
      if (opts.startIndex == null && options2.startColumn > 0) {
        options2.startIndex = options2.startColumn;
      } else if (opts.startColumn == null && options2.startIndex > 0) {
        options2.startColumn = options2.startIndex;
      }
    } else if (opts.startColumn == null || opts.startIndex == null) {
      if (opts.startIndex != null) {
        throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
      }
    }
    if (options2.sourceType === "commonjs") {
      if (opts.allowAwaitOutsideFunction != null) {
        throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
      }
      if (opts.allowReturnOutsideFunction != null) {
        throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
      }
      if (opts.allowNewTargetOutsideFunction != null) {
        throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
      }
    }
    return options2;
  }
  const {
    defineProperty
  } = Object;
  const toUnenumerable = (object, key) => {
    if (object) {
      defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
    }
  };
  function toESTreeLocation(node2) {
    toUnenumerable(node2.loc.start, "index");
    toUnenumerable(node2.loc.end, "index");
    return node2;
  }
  var estree = (superClass) => class ESTreeParserMixin extends superClass {
    parse() {
      const file = toESTreeLocation(super.parse());
      if (this.optionFlags & 256) {
        file.tokens = file.tokens.map(toESTreeLocation);
      }
      return file;
    }
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (_2) {
      }
      const node2 = this.estreeParseLiteral(regex);
      node2.regex = {
        pattern,
        flags
      };
      return node2;
    }
    parseBigIntLiteral(value) {
      let bigInt;
      try {
        bigInt = BigInt(value);
      } catch (_unused) {
        bigInt = null;
      }
      const node2 = this.estreeParseLiteral(bigInt);
      node2.bigint = String(node2.value || value);
      return node2;
    }
    parseDecimalLiteral(value) {
      const decimal = null;
      const node2 = this.estreeParseLiteral(decimal);
      node2.decimal = String(node2.value || value);
      return node2;
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    estreeParseChainExpression(node2, endLoc) {
      const chain = this.startNodeAtNode(node2);
      chain.expression = node2;
      return this.finishNodeAt(chain, "ChainExpression", endLoc);
    }
    directiveToStmt(directive) {
      const expression = directive.value;
      delete directive.value;
      this.castNodeTo(expression, "Literal");
      expression.raw = expression.extra.raw;
      expression.value = expression.extra.expressionValue;
      const stmt = this.castNodeTo(directive, "ExpressionStatement");
      stmt.expression = expression;
      stmt.directive = expression.extra.rawValue;
      delete expression.extra;
      return stmt;
    }
    fillOptionalPropertiesForTSESLint(node2) {
    }
    cloneEstreeStringLiteral(node2) {
      const {
        start,
        end,
        loc,
        range,
        raw,
        value
      } = node2;
      const cloned = Object.create(node2.constructor.prototype);
      cloned.type = "Literal";
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.raw = raw;
      cloned.value = value;
      return cloned;
    }
    initFunction(node2, isAsync) {
      super.initFunction(node2, isAsync);
      node2.expression = false;
    }
    checkDeclaration(node2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        this.checkDeclaration(node2.value);
      } else {
        super.checkDeclaration(node2);
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
      super.parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse);
      const directiveStatements = node2.directives.map((d2) => this.directiveToStmt(d2));
      node2.body = directiveStatements.concat(node2.body);
      delete node2.directives;
    }
    parsePrivateName() {
      const node2 = super.parsePrivateName();
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return node2;
        }
      }
      return this.convertPrivateNameToPrivateIdentifier(node2);
    }
    convertPrivateNameToPrivateIdentifier(node2) {
      const name = super.getPrivateNameSV(node2);
      delete node2.id;
      node2.name = name;
      return this.castNodeTo(node2, "PrivateIdentifier");
    }
    isPrivateName(node2) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.isPrivateName(node2);
        }
      }
      return node2.type === "PrivateIdentifier";
    }
    getPrivateNameSV(node2) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.getPrivateNameSV(node2);
        }
      }
      return node2.name;
    }
    parseLiteral(value, type) {
      const node2 = super.parseLiteral(value, type);
      node2.raw = node2.extra.raw;
      delete node2.extra;
      return node2;
    }
    parseFunctionBody(node2, allowExpression, isMethod = false) {
      super.parseFunctionBody(node2, allowExpression, isMethod);
      node2.expression = node2.body.type !== "BlockStatement";
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node2.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      delete funcNode.kind;
      const {
        typeParameters
      } = node2;
      if (typeParameters) {
        delete node2.typeParameters;
        funcNode.typeParameters = typeParameters;
        this.resetStartLocationFromNode(funcNode, typeParameters);
      }
      const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
      node2.value = valueNode;
      if (type === "ClassPrivateMethod") {
        node2.computed = false;
      }
      if (type === "ObjectMethod") {
        if (node2.kind === "method") {
          node2.kind = "init";
        }
        node2.shorthand = false;
        return this.finishNode(node2, "Property");
      } else {
        return this.finishNode(node2, "MethodDefinition");
      }
    }
    nameIsConstructor(key) {
      if (key.type === "Literal") return key.value === "constructor";
      return super.nameIsConstructor(key);
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      {
        this.castNodeTo(propertyNode, "PropertyDefinition");
      }
      return propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      {
        this.castNodeTo(propertyNode, "PropertyDefinition");
      }
      propertyNode.computed = false;
      return propertyNode;
    }
    parseClassAccessorProperty(node2) {
      const accessorPropertyNode = super.parseClassAccessorProperty(node2);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return accessorPropertyNode;
        }
      }
      if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
        delete accessorPropertyNode.abstract;
        this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
      } else {
        this.castNodeTo(accessorPropertyNode, "AccessorProperty");
      }
      return accessorPropertyNode;
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      const node2 = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (node2) {
        node2.kind = "init";
        this.castNodeTo(node2, "Property");
      }
      return node2;
    }
    finishObjectProperty(node2) {
      node2.kind = "init";
      return this.finishNode(node2, "Property");
    }
    isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding2) {
      return type === "Property" ? "value" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding2);
    }
    isAssignable(node2, isBinding2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        return this.isAssignable(node2.value, isBinding2);
      }
      return super.isAssignable(node2, isBinding2);
    }
    toAssignable(node2, isLHS = false) {
      if (node2 != null && this.isObjectProperty(node2)) {
        const {
          key,
          value
        } = node2;
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
        }
        this.toAssignable(value, isLHS);
      } else {
        super.toAssignable(node2, isLHS);
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
        this.raise(Errors.PatternHasAccessor, prop.key);
      } else if (prop.type === "Property" && prop.method) {
        this.raise(Errors.PatternHasMethod, prop.key);
      } else {
        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
      }
    }
    finishCallExpression(unfinished, optional) {
      const node2 = super.finishCallExpression(unfinished, optional);
      if (node2.callee.type === "Import") {
        var _ref;
        this.castNodeTo(node2, "ImportExpression");
        node2.source = node2.arguments[0];
        node2.options = (_ref = node2.arguments[1]) != null ? _ref : null;
        {
          var _ref2;
          node2.attributes = (_ref2 = node2.arguments[1]) != null ? _ref2 : null;
        }
        delete node2.arguments;
        delete node2.callee;
      } else if (node2.type === "OptionalCallExpression") {
        this.castNodeTo(node2, "CallExpression");
      } else {
        node2.optional = false;
      }
      return node2;
    }
    toReferencedArguments(node2) {
      if (node2.type === "ImportExpression") {
        return;
      }
      super.toReferencedArguments(node2);
    }
    parseExport(unfinished, decorators) {
      const exportStartLoc = this.state.lastTokStartLoc;
      const node2 = super.parseExport(unfinished, decorators);
      switch (node2.type) {
        case "ExportAllDeclaration":
          node2.exported = null;
          break;
        case "ExportNamedDeclaration":
          if (node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier") {
            this.castNodeTo(node2, "ExportAllDeclaration");
            node2.exported = node2.specifiers[0].exported;
            delete node2.specifiers;
          }
        case "ExportDefaultDeclaration":
          {
            var _declaration$decorato;
            const {
              declaration
            } = node2;
            if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node2.start) {
              this.resetStartLocation(node2, exportStartLoc);
            }
          }
          break;
      }
      return node2;
    }
    stopParseSubscript(base2, state) {
      const node2 = super.stopParseSubscript(base2, state);
      if (state.optionalChainMember) {
        return this.estreeParseChainExpression(node2, base2.loc.end);
      }
      return node2;
    }
    parseMember(base2, startLoc, state, computed, optional) {
      const node2 = super.parseMember(base2, startLoc, state, computed, optional);
      if (node2.type === "OptionalMemberExpression") {
        this.castNodeTo(node2, "MemberExpression");
      } else {
        node2.optional = false;
      }
      return node2;
    }
    isOptionalMemberExpression(node2) {
      if (node2.type === "ChainExpression") {
        return node2.expression.type === "MemberExpression";
      }
      return super.isOptionalMemberExpression(node2);
    }
    hasPropertyAsPrivateName(node2) {
      if (node2.type === "ChainExpression") {
        node2 = node2.expression;
      }
      return super.hasPropertyAsPrivateName(node2);
    }
    isObjectProperty(node2) {
      return node2.type === "Property" && node2.kind === "init" && !node2.method;
    }
    isObjectMethod(node2) {
      return node2.type === "Property" && (node2.method || node2.kind === "get" || node2.kind === "set");
    }
    castNodeTo(node2, type) {
      const result = super.castNodeTo(node2, type);
      this.fillOptionalPropertiesForTSESLint(result);
      return result;
    }
    cloneIdentifier(node2) {
      const cloned = super.cloneIdentifier(node2);
      this.fillOptionalPropertiesForTSESLint(cloned);
      return cloned;
    }
    cloneStringLiteral(node2) {
      if (node2.type === "Literal") {
        return this.cloneEstreeStringLiteral(node2);
      }
      return super.cloneStringLiteral(node2);
    }
    finishNodeAt(node2, type, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node2, type, endLoc));
    }
    finishNode(node2, type) {
      const result = super.finishNode(node2, type);
      this.fillOptionalPropertiesForTSESLint(result);
      return result;
    }
    resetStartLocation(node2, startLoc) {
      super.resetStartLocation(node2, startLoc);
      toESTreeLocation(node2);
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node2, endLoc);
      toESTreeLocation(node2);
    }
  };
  class TokContext {
    constructor(token, preserveSpace) {
      this.token = void 0;
      this.preserveSpace = void 0;
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    }
  }
  const types2 = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", true)
  };
  {
    types2.template = new TokContext("`", true);
  }
  const beforeExpr = true;
  const startsExpr = true;
  const isLoop = true;
  const isAssign = true;
  const prefix = true;
  const postfix = true;
  class ExportedTokenType {
    constructor(label, conf = {}) {
      this.label = void 0;
      this.keyword = void 0;
      this.beforeExpr = void 0;
      this.startsExpr = void 0;
      this.rightAssociative = void 0;
      this.isLoop = void 0;
      this.isAssign = void 0;
      this.prefix = void 0;
      this.postfix = void 0;
      this.binop = void 0;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      {
        this.updateContext = null;
      }
    }
  }
  const keywords$1 = /* @__PURE__ */ new Map();
  function createKeyword(name, options2 = {}) {
    options2.keyword = name;
    const token = createToken(name, options2);
    keywords$1.set(name, token);
    return token;
  }
  function createBinop(name, binop) {
    return createToken(name, {
      beforeExpr,
      binop
    });
  }
  let tokenTypeCounter = -1;
  const tokenTypes = [];
  const tokenLabels = [];
  const tokenBinops = [];
  const tokenBeforeExprs = [];
  const tokenStartsExprs = [];
  const tokenPrefixes = [];
  function createToken(name, options2 = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : false);
    tokenTypes.push(new ExportedTokenType(name, options2));
    return tokenTypeCounter;
  }
  function createKeywordLike(name, options2 = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    ++tokenTypeCounter;
    keywords$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : false);
    tokenTypes.push(new ExportedTokenType("name", options2));
    return tokenTypeCounter;
  }
  const tt3 = {
    bracketL: createToken("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr,
      startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr,
      startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr,
      isAssign
    }),
    assign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: createToken("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: createToken("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop
    }),
    _while: createKeyword("while", {
      isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr
    }),
    name: createToken("name", {
      startsExpr
    }),
    placeholder: createToken("%%", {
      startsExpr
    }),
    string: createToken("string", {
      startsExpr
    }),
    num: createToken("num", {
      startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr
    }),
    jsxTagEnd: createToken("jsxTagEnd")
  };
  function tokenIsIdentifier(token) {
    return token >= 93 && token <= 133;
  }
  function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 92;
  }
  function tokenIsKeywordOrIdentifier(token) {
    return token >= 58 && token <= 133;
  }
  function tokenIsLiteralPropertyName(token) {
    return token >= 58 && token <= 137;
  }
  function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
  }
  function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
  }
  function tokenIsAssignment(token) {
    return token >= 29 && token <= 33;
  }
  function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
    return token >= 129 && token <= 131;
  }
  function tokenIsLoop(token) {
    return token >= 90 && token <= 92;
  }
  function tokenIsKeyword(token) {
    return token >= 58 && token <= 92;
  }
  function tokenIsOperator(token) {
    return token >= 39 && token <= 59;
  }
  function tokenIsPostfix(token) {
    return token === 34;
  }
  function tokenIsPrefix(token) {
    return tokenPrefixes[token];
  }
  function tokenIsTSTypeOperator(token) {
    return token >= 121 && token <= 123;
  }
  function tokenIsTSDeclarationStart(token) {
    return token >= 124 && token <= 130;
  }
  function tokenLabelName(token) {
    return tokenLabels[token];
  }
  function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
  }
  function tokenIsRightAssociative(token) {
    return token === 57;
  }
  function tokenIsTemplate(token) {
    return token >= 24 && token <= 25;
  }
  function getExportedToken(token) {
    return tokenTypes[token];
  }
  {
    tokenTypes[8].updateContext = (context2) => {
      context2.pop();
    };
    tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context2) => {
      context2.push(types2.brace);
    };
    tokenTypes[22].updateContext = (context2) => {
      if (context2[context2.length - 1] === types2.template) {
        context2.pop();
      } else {
        context2.push(types2.template);
      }
    };
    tokenTypes[143].updateContext = (context2) => {
      context2.push(types2.j_expr, types2.j_oTag);
    };
  }
  let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-࢏ࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚ౜ౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ೜-ೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-Ƛ꟱-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
  let nonASCIIidentifierChars = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-᫝᫠-᫫ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code2, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code2) return false;
      pos += set[i + 1];
      if (pos >= code2) return true;
    }
    return false;
  }
  function isIdentifierStart(code2) {
    if (code2 < 65) return code2 === 36;
    if (code2 <= 90) return true;
    if (code2 < 97) return code2 === 95;
    if (code2 <= 122) return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2) {
    if (code2 < 48) return code2 === 36;
    if (code2 < 58) return true;
    if (code2 < 65) return false;
    if (code2 <= 90) return true;
    if (code2 < 97) return code2 === 95;
    if (code2 <= 122) return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  function isIteratorStart(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  }
  const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }
  class Scope {
    constructor(flags) {
      this.flags = 0;
      this.names = /* @__PURE__ */ new Map();
      this.firstLexicalName = "";
      this.flags = flags;
    }
  }
  class ScopeHandler {
    constructor(parser2, inModule) {
      this.parser = void 0;
      this.scopeStack = [];
      this.inModule = void 0;
      this.undefinedExports = /* @__PURE__ */ new Map();
      this.parser = parser2;
      this.inModule = inModule;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get allowNewTarget() {
      return (this.currentThisScopeFlags() & 512) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & 64) > 0 && (flags & 2) === 0;
    }
    get inStaticBlock() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 128) {
          return true;
        }
        if (flags & (1667 | 64)) {
          return false;
        }
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get inBareCaseStatement() {
      return (this.currentScope().flags & 256) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      const scope2 = this.scopeStack.pop();
      return scope2.flags;
    }
    treatFunctionsAsVarInScope(scope2) {
      return !!(scope2.flags & (2 | 128) || !this.parser.inModule && scope2.flags & 1);
    }
    declareName(name, bindingType, loc) {
      let scope2 = this.currentScope();
      if (bindingType & 8 || bindingType & 16) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc);
        let type = scope2.names.get(name) || 0;
        if (bindingType & 16) {
          type = type | 4;
        } else {
          if (!scope2.firstLexicalName) {
            scope2.firstLexicalName = name;
          }
          type = type | 2;
        }
        scope2.names.set(name, type);
        if (bindingType & 8) {
          this.maybeExportDefined(scope2, name);
        }
      } else if (bindingType & 4) {
        for (let i = this.scopeStack.length - 1; i >= 0; --i) {
          scope2 = this.scopeStack[i];
          this.checkRedeclarationInScope(scope2, name, bindingType, loc);
          scope2.names.set(name, (scope2.names.get(name) || 0) | 1);
          this.maybeExportDefined(scope2, name);
          if (scope2.flags & 1667) break;
        }
      }
      if (this.parser.inModule && scope2.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    maybeExportDefined(scope2, name) {
      if (this.parser.inModule && scope2.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    checkRedeclarationInScope(scope2, name, bindingType, loc) {
      if (this.isRedeclaredInScope(scope2, name, bindingType)) {
        this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        });
      }
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (!(bindingType & 1)) return false;
      if (bindingType & 8) {
        return scope2.names.has(name);
      }
      const type = scope2.names.get(name) || 0;
      if (bindingType & 16) {
        return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope2) && (type & 1) > 0;
      }
      return (type & 2) > 0 && !(scope2.flags & 8 && scope2.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope2) && (type & 4) > 0;
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      const topLevelScope = this.scopeStack[0];
      if (!topLevelScope.names.has(name)) {
        this.undefinedExports.set(name, id.loc.start);
      }
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 1667) {
          return flags;
        }
      }
    }
    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & (1667 | 64) && !(flags & 4)) {
          return flags;
        }
      }
    }
  }
  class FlowScope extends Scope {
    constructor(...args) {
      super(...args);
      this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
      const scope2 = this.currentScope();
      if (bindingType & 2048) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc);
        this.maybeExportDefined(scope2, name);
        scope2.declareFunctions.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (super.isRedeclaredInScope(scope2, name, bindingType)) return true;
      if (bindingType & 2048 && !scope2.declareFunctions.has(name)) {
        const type = scope2.names.get(name);
        return (type & 4) > 0 || (type & 2) > 0;
      }
      return false;
    }
    checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        super.checkLocalExport(id);
      }
    }
  }
  const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  const FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType
    }) => `Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName,
      enumName
    }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({
      memberName,
      enumName
    }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({
      enumName
    }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType,
      enumName
    }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName,
      memberName,
      explicitType
    }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName,
      memberName
    }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName,
      memberName
    }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({
      enumName,
      memberName,
      suggestion
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName,
      memberName
    }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType
    }) => `Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind,
      suggestion
    }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }
  function hasTypeImportKind(node2) {
    return node2.importKind === "type" || node2.importKind === "typeof";
  }
  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function partition(list, test) {
    const list1 = [];
    const list2 = [];
    for (let i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }
    return [list1, list2];
  }
  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow2 = (superClass) => class FlowParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.flowPragma = void 0;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(type, val) {
      if (type !== 134 && type !== 13 && type !== 28) {
        if (this.flowPragma === void 0) {
          this.flowPragma = null;
        }
      }
      super.finishToken(type, val);
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (!matches) ;
        else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }
      super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || 14);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }
    flowParsePredicate() {
      const node2 = this.startNode();
      const moduloLoc = this.state.startLoc;
      this.next();
      this.expectContextual(110);
      if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
      }
      if (this.eat(10)) {
        node2.value = super.parseExpression();
        this.expect(11);
        return this.finishNode(node2, "DeclaredPredicate");
      } else {
        return this.finishNode(node2, "InferredPredicate");
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(14);
      let type = null;
      let predicate = null;
      if (this.match(54)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(54)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type, predicate];
    }
    flowParseDeclareClass(node2) {
      this.next();
      this.flowParseInterfaceish(node2, true);
      return this.finishNode(node2, "DeclareClass");
    }
    flowParseDeclareFunction(node2) {
      this.next();
      const id = node2.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();
      if (this.match(47)) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(10);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      typeNode.this = tmp._this;
      this.expect(11);
      [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      this.scope.declareName(node2.id.name, 2048, node2.id.loc.start);
      return this.finishNode(node2, "DeclareFunction");
    }
    flowParseDeclare(node2, insideModule) {
      if (this.match(80)) {
        return this.flowParseDeclareClass(node2);
      } else if (this.match(68)) {
        return this.flowParseDeclareFunction(node2);
      } else if (this.match(74)) {
        return this.flowParseDeclareVariable(node2);
      } else if (this.eatContextual(127)) {
        if (this.match(16)) {
          return this.flowParseDeclareModuleExports(node2);
        } else {
          if (insideModule) {
            this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
          }
          return this.flowParseDeclareModule(node2);
        }
      } else if (this.isContextual(130)) {
        return this.flowParseDeclareTypeAlias(node2);
      } else if (this.isContextual(131)) {
        return this.flowParseDeclareOpaqueType(node2);
      } else if (this.isContextual(129)) {
        return this.flowParseDeclareInterface(node2);
      } else if (this.match(82)) {
        return this.flowParseDeclareExportDeclaration(node2, insideModule);
      }
      throw this.unexpected();
    }
    flowParseDeclareVariable(node2) {
      this.next();
      node2.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node2.id.name, 5, node2.id.loc.start);
      this.semicolon();
      return this.finishNode(node2, "DeclareVariable");
    }
    flowParseDeclareModule(node2) {
      this.scope.enter(0);
      if (this.match(134)) {
        node2.id = super.parseExprAtom();
      } else {
        node2.id = this.parseIdentifier();
      }
      const bodyNode = node2.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(5);
      while (!this.match(8)) {
        const bodyNode2 = this.startNode();
        if (this.match(83)) {
          this.next();
          if (!this.isContextual(130) && !this.match(87)) {
            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
          }
          body.push(super.parseImport(bodyNode2));
        } else {
          this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
          body.push(this.flowParseDeclare(bodyNode2, true));
        }
      }
      this.scope.exit();
      this.expect(8);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach((bodyElement) => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
          }
          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
          }
          if (kind === "ES") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
          }
          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node2.kind = kind || "CommonJS";
      return this.finishNode(node2, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node2, insideModule) {
      this.expect(82);
      if (this.eat(65)) {
        if (this.match(68) || this.match(80)) {
          node2.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node2.declaration = this.flowParseType();
          this.semicolon();
        }
        node2.default = true;
        return this.finishNode(node2, "DeclareExportDeclaration");
      } else {
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
          const label = this.state.value;
          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
            unsupportedExportKind: label,
            suggestion: exportSuggestions[label]
          });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
          node2.declaration = this.flowParseDeclare(this.startNode());
          node2.default = false;
          return this.finishNode(node2, "DeclareExportDeclaration");
        } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
          node2 = this.parseExport(node2, null);
          if (node2.type === "ExportNamedDeclaration") {
            node2.default = false;
            delete node2.exportKind;
            return this.castNodeTo(node2, "DeclareExportDeclaration");
          } else {
            return this.castNodeTo(node2, "DeclareExportAllDeclaration");
          }
        }
      }
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(node2) {
      this.next();
      this.expectContextual(111);
      node2.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node2, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node2) {
      this.next();
      const finished = this.flowParseTypeAlias(node2);
      this.castNodeTo(finished, "DeclareTypeAlias");
      return finished;
    }
    flowParseDeclareOpaqueType(node2) {
      this.next();
      const finished = this.flowParseOpaqueType(node2, true);
      this.castNodeTo(finished, "DeclareOpaqueType");
      return finished;
    }
    flowParseDeclareInterface(node2) {
      this.next();
      this.flowParseInterfaceish(node2, false);
      return this.finishNode(node2, "DeclareInterface");
    }
    flowParseInterfaceish(node2, isClass) {
      node2.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node2.id.name, isClass ? 17 : 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.extends = [];
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(12));
      }
      if (isClass) {
        node2.implements = [];
        node2.mixins = [];
        if (this.eatContextual(117)) {
          do {
            node2.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        if (this.eatContextual(113)) {
          do {
            node2.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
      }
      node2.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const node2 = this.startNode();
      node2.id = this.flowParseQualifiedTypeIdentifier();
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node2.typeParameters = null;
      }
      return this.finishNode(node2, "InterfaceExtends");
    }
    flowParseInterface(node2) {
      this.flowParseInterfaceish(node2, false);
      return this.finishNode(node2, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word)) return;
      this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
        reservedType: word
      });
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.startLoc, declaration);
      return this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node2) {
      node2.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.right = this.flowParseTypeInitialiser(29);
      this.semicolon();
      return this.finishNode(node2, "TypeAlias");
    }
    flowParseOpaqueType(node2, declare) {
      this.expectContextual(130);
      node2.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node2.id.name, 8201, node2.id.loc.start);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node2.typeParameters = null;
      }
      node2.supertype = null;
      if (this.match(14)) {
        node2.supertype = this.flowParseTypeInitialiser(14);
      }
      node2.impltype = null;
      if (!declare) {
        node2.impltype = this.flowParseTypeInitialiser(29);
      }
      this.semicolon();
      return this.finishNode(node2, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStartLoc = this.state.startLoc;
      const node2 = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node2.name = ident.name;
      node2.variance = variance;
      node2.bound = ident.typeAnnotation;
      if (this.match(29)) {
        this.eat(29);
        node2.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
        }
      }
      return this.finishNode(node2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node2 = this.startNode();
      node2.params = [];
      this.state.inType = true;
      if (this.match(47) || this.match(143)) {
        this.next();
      } else {
        this.unexpected();
      }
      let defaultRequired = false;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node2.params.push(typeParameter);
        if (typeParameter.default) {
          defaultRequired = true;
        }
        if (!this.match(48)) {
          this.expect(12);
        }
      } while (!this.match(48));
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node2, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(cb) {
      if (this.curContext() !== types2.brace) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      } else {
        return cb();
      }
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() !== 47) return;
      return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      const node2 = this.startNode();
      const oldInType = this.state.inType;
      this.state.inType = true;
      node2.params = [];
      this.flowInTopLevelContext(() => {
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node2.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      });
      this.state.inType = oldInType;
      if (!this.state.inType && this.curContext() === types2.brace) {
        this.reScan_lt_gt();
      }
      this.expect(48);
      return this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return null;
      const node2 = this.startNode();
      const oldInType = this.state.inType;
      node2.params = [];
      this.state.inType = true;
      this.expect(47);
      while (!this.match(48)) {
        node2.params.push(this.flowParseTypeOrImplicitInstantiation());
        if (!this.match(48)) {
          this.expect(12);
        }
      }
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node2 = this.startNode();
      this.expectContextual(129);
      node2.extends = [];
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      node2.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node2, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(node2, isStatic, variance) {
      node2.static = isStatic;
      if (this.lookahead().type === 14) {
        node2.id = this.flowParseObjectPropertyKey();
        node2.key = this.flowParseTypeInitialiser();
      } else {
        node2.id = null;
        node2.key = this.flowParseType();
      }
      this.expect(3);
      node2.value = this.flowParseTypeInitialiser();
      node2.variance = variance;
      return this.finishNode(node2, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node2, isStatic) {
      node2.static = isStatic;
      node2.id = this.flowParseObjectPropertyKey();
      this.expect(3);
      this.expect(3);
      if (this.match(47) || this.match(10)) {
        node2.method = true;
        node2.optional = false;
        node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
      } else {
        node2.method = false;
        if (this.eat(17)) {
          node2.optional = true;
        }
        node2.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(node2, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node2) {
      node2.params = [];
      node2.rest = null;
      node2.typeParameters = null;
      node2.this = null;
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.expect(10);
      if (this.match(78)) {
        node2.this = this.flowParseFunctionTypeParam(true);
        node2.this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        node2.params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        node2.rest = this.flowParseFunctionTypeParam(false);
      }
      this.expect(11);
      node2.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node2, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node2, isStatic) {
      const valueNode = this.startNode();
      node2.static = isStatic;
      node2.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node2, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;
      if (allowExact && this.match(6)) {
        this.expect(6);
        endDelim = 9;
        exact = true;
      } else {
        this.expect(5);
        endDelim = 8;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStartLoc = null;
        let inexactStartLoc = null;
        const node2 = this.startNode();
        if (allowProto && this.isContextual(118)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            protoStartLoc = this.state.startLoc;
            allowStatic = false;
          }
        }
        if (allowStatic && this.isContextual(106)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            isStatic = true;
          }
        }
        const variance = this.flowParseVariance();
        if (this.eat(0)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (this.eat(0)) {
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
          }
        } else if (this.match(10) || this.match(47)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
        } else {
          let kind = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const lookahead = this.lookahead();
            if (tokenIsLiteralPropertyName(lookahead.type)) {
              kind = this.state.value;
              this.next();
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
          if (propOrInexact === null) {
            inexact = true;
            inexactStartLoc = this.state.lastTokStartLoc;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }
        this.flowObjectTypeSemicolon();
        if (inexactStartLoc && !this.match(8) && !this.match(9)) {
          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
        }
      }
      this.expect(endDelim);
      if (allowSpread) {
        nodeStart.inexact = inexact;
      }
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }
    flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
      if (this.eat(21)) {
        const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
          } else if (!allowInexact) {
            this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.InexactVariance, variance);
          }
          return null;
        }
        if (!allowSpread) {
          this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
        }
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (variance) {
          this.raise(FlowErrors.SpreadVariance, variance);
        }
        node2.argument = this.flowParseType();
        return this.finishNode(node2, "ObjectTypeSpreadProperty");
      } else {
        node2.key = this.flowParseObjectPropertyKey();
        node2.static = isStatic;
        node2.proto = protoStartLoc != null;
        node2.kind = kind;
        let optional = false;
        if (this.match(47) || this.match(10)) {
          node2.method = true;
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start));
          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node2);
          }
          if (!allowSpread && node2.key.name === "constructor" && node2.value.this) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, node2.value.this);
          }
        } else {
          if (kind !== "init") this.unexpected();
          node2.method = false;
          if (this.eat(17)) {
            optional = true;
          }
          node2.value = this.flowParseTypeInitialiser();
          node2.variance = variance;
        }
        node2.optional = optional;
        return this.finishNode(node2, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1;
      const length = property.value.params.length + (property.value.rest ? 1 : 0);
      if (property.value.this) {
        this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
      }
      if (length !== paramCount) {
        this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
      }
      if (property.kind === "set" && property.value.rest) {
        this.raise(Errors.BadSetterRestParameter, property);
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
        this.unexpected();
      }
    }
    flowParseQualifiedTypeIdentifier(startLoc, id) {
      startLoc != null ? startLoc : startLoc = this.state.startLoc;
      let node2 = id || this.flowParseRestrictedIdentifier(true);
      while (this.eat(16)) {
        const node22 = this.startNodeAt(startLoc);
        node22.qualification = node2;
        node22.id = this.flowParseRestrictedIdentifier(true);
        node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
      }
      return node2;
    }
    flowParseGenericType(startLoc, id) {
      const node2 = this.startNodeAt(startLoc);
      node2.typeParameters = null;
      node2.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node2 = this.startNode();
      this.expect(87);
      node2.argument = this.flowParsePrimaryType();
      return this.finishNode(node2, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node2 = this.startNode();
      node2.types = [];
      this.expect(0);
      while (this.state.pos < this.length && !this.match(3)) {
        node2.types.push(this.flowParseType());
        if (this.match(3)) break;
        this.expect(12);
      }
      this.expect(3);
      return this.finishNode(node2, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first) {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node2 = this.startNode();
      const lh = this.lookahead();
      const isThis = this.state.type === 78;
      if (lh.type === 14 || lh.type === 17) {
        if (isThis && !first) {
          this.raise(FlowErrors.ThisParamMustBeFirst, node2);
        }
        name = this.parseIdentifier(isThis);
        if (this.eat(17)) {
          optional = true;
          if (isThis) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, node2);
          }
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node2.name = name;
      node2.optional = optional;
      node2.typeAnnotation = typeAnnotation;
      return this.finishNode(node2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node2 = this.startNodeAt(type.loc.start);
      node2.name = null;
      node2.optional = false;
      node2.typeAnnotation = type;
      return this.finishNode(node2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null;
      let _this = null;
      if (this.match(78)) {
        _this = this.flowParseFunctionTypeParam(true);
        _this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        rest = this.flowParseFunctionTypeParam(false);
      }
      return {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startLoc, node2, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node2, "SymbolTypeAnnotation");
        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startLoc = this.state.startLoc;
      const node2 = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;
        case 47: {
          const node3 = this.startNode();
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
          this.expect(10);
          tmp = this.flowParseFunctionTypeParams();
          node3.params = tmp.params;
          node3.rest = tmp.rest;
          node3.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node3.returnType = this.flowParseType();
          return this.finishNode(node3, "FunctionTypeAnnotation");
        }
        case 10: {
          const node3 = this.startNode();
          this.next();
          if (!this.match(11) && !this.match(21)) {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token = this.lookahead().type;
              isGroupedType = token !== 17 && token !== 14;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
              this.expect(11);
              return type;
            } else {
              this.eat(12);
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node3.params = tmp.params;
          node3.rest = tmp.rest;
          node3.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node3.returnType = this.flowParseType();
          node3.typeParameters = null;
          return this.finishNode(node3, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          node2.value = this.match(85);
          this.next();
          return this.finishNode(node2, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            this.next();
            if (this.match(135)) {
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
            }
            if (this.match(136)) {
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
            }
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          throw this.unexpected();
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          this.next();
          return this.finishNode(node2, "VoidTypeAnnotation");
        case 84:
          this.next();
          return this.finishNode(node2, "NullLiteralTypeAnnotation");
        case 78:
          this.next();
          return this.finishNode(node2, "ThisTypeAnnotation");
        case 55:
          this.next();
          return this.finishNode(node2, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type);
            this.next();
            return super.createIdentifier(node2, label);
          } else if (tokenIsIdentifier(this.state.type)) {
            if (this.isContextual(129)) {
              return this.flowParseInterfaceType();
            }
            return this.flowIdentToTypeAnnotation(startLoc, node2, this.parseIdentifier());
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      let seenOptionalIndexedAccess = false;
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startLoc);
        const optional = this.eat(18);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
        this.expect(0);
        if (!optional && this.match(3)) {
          node2.elementType = type;
          this.next();
          type = this.finishNode(node2, "ArrayTypeAnnotation");
        } else {
          node2.objectType = type;
          node2.indexType = this.flowParseType();
          this.expect(3);
          if (seenOptionalIndexedAccess) {
            node2.optional = optional;
            type = this.finishNode(node2, "OptionalIndexedAccessType");
          } else {
            type = this.finishNode(node2, "IndexedAccessType");
          }
        }
      }
      return type;
    }
    flowParsePrefixType() {
      const node2 = this.startNode();
      if (this.eat(17)) {
        node2.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node2, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node2 = this.startNodeAt(param.loc.start);
        node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node2.rest = null;
        node2.this = null;
        node2.returnType = this.flowParseType();
        node2.typeParameters = null;
        return this.finishNode(node2, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node2 = this.startNode();
      this.eat(45);
      const type = this.flowParseAnonFunctionWithoutParens();
      node2.types = [type];
      while (this.eat(45)) {
        node2.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node2 = this.startNode();
      this.eat(43);
      const type = this.flowParseIntersectionType();
      node2.types = [type];
      while (this.eat(43)) {
        node2.types.push(this.flowParseIntersectionType());
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const startLoc = this.state.startLoc;
        const node2 = this.parseIdentifier();
        return this.flowParseGenericType(startLoc, node2);
      } else {
        return this.flowParseType();
      }
    }
    flowParseTypeAnnotation() {
      const node2 = this.startNode();
      node2.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node2, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      if (this.match(14)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }
      return ident;
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation;
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
      return node2.expression;
    }
    flowParseVariance() {
      let variance = null;
      if (this.match(53)) {
        variance = this.startNode();
        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }
        this.next();
        return this.finishNode(variance, "Variance");
      }
      return variance;
    }
    parseFunctionBody(node2, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod));
        return;
      }
      super.parseFunctionBody(node2, false, isMethod);
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      if (this.match(14)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(node2, type, isMethod);
    }
    parseStatementLike(flags) {
      if (this.state.strict && this.isContextual(129)) {
        const lookahead = this.lookahead();
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node2 = this.startNode();
          this.next();
          return this.flowParseInterface(node2);
        }
      } else if (this.isContextual(126)) {
        const node2 = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node2);
      }
      const stmt = super.parseStatementLike(flags);
      if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }
      return stmt;
    }
    parseExpressionStatement(node2, expr, decorators) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
            return this.flowParseDeclare(node2);
          }
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node2);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node2);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node2, false);
          }
        }
      }
      return super.parseExpressionStatement(node2, expr, decorators);
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
        return !this.state.containsEsc;
      }
      return super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
        return this.state.containsEsc;
      }
      return super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        const node2 = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node2);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors);
          return expr;
        }
      }
      this.expect(17);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node2 = this.startNodeAt(startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;
          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        if (failed && valid.length > 1) {
          this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
        }
        if (failed && valid.length === 1) {
          this.state = state;
          noArrowAt.push(valid[0].start);
          this.state.noArrowAt = noArrowAt;
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }
      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(14);
      node2.test = expr;
      node2.consequent = consequent;
      node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0));
      return this.finishNode(node2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(14);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node2, disallowInvalid) {
      const stack = [node2];
      const arrows = [];
      while (stack.length !== 0) {
        const node3 = stack.pop();
        if (node3.type === "ArrowFunctionExpression" && node3.body.type !== "BlockStatement") {
          if (node3.typeParameters || !node3.returnType) {
            this.finishArrowValidation(node3);
          } else {
            arrows.push(node3);
          }
          stack.push(node3.body);
        } else if (node3.type === "ConditionalExpression") {
          stack.push(node3.consequent);
          stack.push(node3.alternate);
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node3) => this.finishArrowValidation(node3));
        return [arrows, []];
      }
      return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)));
    }
    finishArrowValidation(node2) {
      var _node$extra;
      this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
      this.scope.enter(514 | 4);
      super.checkParams(node2, false, true);
      this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node2, parse3) {
      let result;
      if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node2.start))) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse3();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse3();
      }
      return result;
    }
    parseParenItem(node2, startLoc) {
      const newNode = super.parseParenItem(node2, startLoc);
      if (this.eat(17)) {
        newNode.optional = true;
        this.resetEndLocation(node2);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = newNode;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return newNode;
    }
    assertModuleNodeAllowed(node2) {
      if (node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type") {
        return;
      }
      super.assertModuleNodeAllowed(node2);
    }
    parseExportDeclaration(node2) {
      if (this.isContextual(130)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        if (this.match(5)) {
          node2.specifiers = this.parseExportSpecifiers(true);
          super.parseExportFrom(node2);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual(131)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual(129)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.isContextual(126)) {
        node2.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node2);
      }
    }
    eatExportStar(node2) {
      if (super.eatExportStar(node2)) return true;
      if (this.isContextual(130) && this.lookahead().type === 55) {
        node2.exportKind = "type";
        this.next();
        this.next();
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      const {
        startLoc
      } = this.state;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
      if (hasNamespace && node2.exportKind === "type") {
        this.unexpected(startLoc);
      }
      return hasNamespace;
    }
    parseClassId(node2, isStatement, optionalId) {
      super.parseClassId(node2, isStatement, optionalId);
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }
    parseClassMember(classBody, member, state) {
      const {
        startLoc
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        member.declare = true;
      }
      super.parseClassMember(classBody, member, state);
      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
          this.raise(FlowErrors.DeclareClassElement, startLoc);
        } else if (member.value) {
          this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
        }
      }
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1();
      const fullWord = "@@" + word;
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
          identifierName: fullWord
        });
      }
      this.finishToken(132, fullWord);
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 123 && next === 124) {
        this.finishOp(6, 2);
      } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
        this.finishOp(code2 === 62 ? 48 : 47, 1);
      } else if (this.state.inType && code2 === 63) {
        if (next === 46) {
          this.finishOp(18, 2);
        } else {
          this.finishOp(17, 1);
        }
      } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
        this.state.pos += 2;
        this.readIterator();
      } else {
        super.getTokenFromCode(code2);
      }
    }
    isAssignable(node2, isBinding2) {
      if (node2.type === "TypeCastExpression") {
        return this.isAssignable(node2.expression, isBinding2);
      } else {
        return super.isAssignable(node2, isBinding2);
      }
    }
    toAssignable(node2, isLHS = false) {
      if (!isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression") {
        node2.left = this.typeCastToParameter(node2.left);
      }
      super.toAssignable(node2, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra;
        const expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
        }
      }
      return exprList;
    }
    parseArrayLike(close, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, isTuple, refExpressionErrors);
      if (refExpressionErrors != null && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node2.elements);
      }
      return node2;
    }
    isValidLVal(type, disallowCallExpression, isParenthesized, binding2) {
      return type === "TypeCastExpression" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding2);
    }
    parseClassProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassPrivateProperty(node2);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      if (method.params && isConstructor) {
        const params = method.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        }
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        }
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2);
      if (node2.superClass && (this.match(47) || this.match(51))) {
        {
          node2.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
        }
      }
      if (this.isContextual(113)) {
        this.next();
        const implemented = node2.implements = [];
        do {
          const node3 = this.startNode();
          node3.id = this.flowParseRestrictedIdentifier(true);
          if (this.match(47)) {
            node3.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node3.typeParameters = null;
          }
          implemented.push(this.finishNode(node3, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        if (this.isThisParam(param) && method.kind === "get") {
          this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
        }
      }
    }
    parsePropertyNamePrefixOperator(node2) {
      node2.variance = this.flowParseVariance();
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.loc.start);
      }
      delete prop.variance;
      let typeParameters;
      if (this.match(47) && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(10)) this.unexpected();
      }
      const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      if (typeParameters) {
        (result.value || result).typeParameters = typeParameters;
      }
      return result;
    }
    parseFunctionParamType(param) {
      if (this.eat(17)) {
        if (param.type !== "Identifier") {
          this.raise(FlowErrors.PatternIsOptional, param);
        }
        if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
        }
        param.optional = true;
      }
      if (this.match(14)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamAnnotationRequired, param);
      }
      if (this.match(29) && this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamNoDefault, param);
      }
      this.resetEndLocation(param);
      return param;
    }
    parseMaybeDefault(startLoc, left) {
      const node2 = super.parseMaybeDefault(startLoc, left);
      if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
        this.raise(FlowErrors.TypeBeforeInitializer, node2.typeAnnotation);
      }
      return node2;
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2);
      if (node2.module && node2.importKind !== "value") {
        this.raise(FlowErrors.ImportReflectionHasImportType, node2.specifiers[0].loc.start);
      }
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      node2.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return true;
      if (this.isContextual(130)) {
        if (!isExport) return true;
        const ch = this.lookaheadCharCode();
        return ch === 123 || ch === 42;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      super.applyImportPhase(node2, isExport, phase, loc);
      if (isExport) {
        if (!phase && this.match(65)) {
          return;
        }
        node2.exportKind = phase === "type" ? phase : "value";
      } else {
        if (phase === "type" && this.match(55)) this.unexpected();
        node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      const firstIdent = specifier.imported;
      let specifierTypeKind = null;
      if (firstIdent.type === "Identifier") {
        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }
      }
      let isBinding2 = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = this.cloneIdentifier(as_ident);
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;
        } else {
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: firstIdent.value
            });
          }
          specifier.imported = firstIdent;
          specifier.importKind = null;
        }
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding2 = true;
          specifier.local = this.cloneIdentifier(specifier.imported);
        }
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      if (isInTypeOnlyImport && specifierIsTypeImport) {
        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
      }
      if (isInTypeOnlyImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
      }
      if (isBinding2 && !isInTypeOnlyImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node2, isConstructor) {
      const kind = node2.kind;
      if (kind !== "get" && kind !== "set" && this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (this.match(14)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node2.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node2, call);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state = null;
      let jsx3;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        state = this.state.clone();
        jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx3.error) return jsx3.node;
        const {
          context: context2
        } = this.state;
        const currentContext = context2[context2.length - 1];
        if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
          context2.pop();
        }
      }
      if ((_jsx = jsx3) != null && _jsx.error || this.match(47)) {
        var _jsx2, _jsx3;
        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          if (expr.type !== "ArrowFunctionExpression") abort();
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression2;
        }, state);
        let arrowExpression = null;
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
            }
            return arrow.node;
          }
          arrowExpression = arrow.node;
        }
        if ((_jsx2 = jsx3) != null && _jsx2.node) {
          this.state = jsx3.failState;
          return jsx3.node;
        }
        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }
        if ((_jsx3 = jsx3) != null && _jsx3.thrown) throw jsx3.error;
        if (arrow.thrown) throw arrow.error;
        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(19)) this.unexpected();
          return typeNode;
        });
        if (result.thrown) return null;
        if (result.error) this.state = result.failState;
        node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node2);
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node2, params) {
      if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node2.start))) {
        node2.params = params;
      } else {
        super.setArrowFunctionParameters(node2, params);
      }
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node2.start))) {
        return;
      }
      for (let i = 0; i < node2.params.length; i++) {
        if (this.isThisParam(node2.params[i]) && i > 0) {
          this.raise(FlowErrors.ThisParamMustBeFirst, node2.params[i]);
        }
      }
      super.checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged);
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(base2, startLoc, noCalls) {
      if (base2.type === "Identifier" && base2.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base2;
        node2.arguments = super.parseCallExpressionArguments();
        base2 = this.finishNode(node2, "CallExpression");
      } else if (base2.type === "Identifier" && base2.name === "async" && this.match(47)) {
        const state = this.state.clone();
        const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted) return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base2, startLoc, noCalls), state);
        if (result.node && !result.error) return result.node;
        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }
        if (result.node) {
          this.state = result.failState;
          return result.node;
        }
        throw arrow.error || result.error;
      }
      return super.parseSubscripts(base2, startLoc, noCalls);
    }
    parseSubscript(base2, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;
        if (noCalls) {
          subscriptState.stop = true;
          return base2;
        }
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base2;
        node2.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
        this.expect(10);
        node2.arguments = this.parseCallExpressionArguments();
        node2.optional = true;
        return this.finishCallExpression(node2, true);
      } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base2;
        const result = this.tryParse(() => {
          node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(10);
          node2.arguments = super.parseCallExpressionArguments();
          if (subscriptState.optionalChainMember) {
            node2.optional = false;
          }
          return this.finishCallExpression(node2, subscriptState.optionalChainMember);
        });
        if (result.node) {
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }
      return super.parseSubscript(base2, startLoc, noCalls, subscriptState);
    }
    parseNewCallee(node2) {
      super.parseNewCallee(node2);
      let targs = null;
      if (this.shouldParseTypes() && this.match(47)) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }
      node2.typeArguments = targs;
    }
    parseAsyncArrowWithTypeParameters(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      this.parseFunctionParams(node2, false);
      if (!this.parseArrow(node2)) return;
      return super.parseArrowExpression(node2, void 0, true);
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code2);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(code2);
    }
    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);
      if (this.state.hasFlowComment) {
        this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
      }
      return fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
        }
        this.hasFlowCommentCompletion();
        const commentSkip = this.skipFlowComment();
        if (commentSkip) {
          this.state.pos += commentSkip;
          this.state.hasFlowComment = true;
        }
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }
      return false;
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
        memberName,
        enumName
      });
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
    }
    flowEnumErrorNumberMemberNotInitialized(loc, details) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(node2, details) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node2, details);
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc;
      const endOfInit = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          const literal2 = this.parseNumericLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "number",
              loc: literal2.loc.start,
              value: literal2
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 134: {
          const literal2 = this.parseStringLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "string",
              loc: literal2.loc.start,
              value: literal2
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 85:
        case 86: {
          const literal2 = this.parseBooleanLiteral(this.match(85));
          if (endOfInit()) {
            return {
              type: "boolean",
              loc: literal2.loc.start,
              value: literal2
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        default:
          return {
            type: "invalid",
            loc: startLoc
          };
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc;
      const id = this.parseIdentifier(true);
      const init = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(loc, context2, expectedType) {
      const {
        explicitType
      } = context2;
      if (explicitType === null) {
        return;
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(loc, context2);
      }
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = /* @__PURE__ */ new Set();
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = false;
      while (!this.match(8)) {
        if (this.eat(21)) {
          hasUnknownMembers = true;
          break;
        }
        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;
        if (memberName === "") {
          continue;
        }
        if (/^[a-z]/.test(memberName)) {
          this.raise(FlowErrors.EnumInvalidMemberName, id, {
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName
          });
        }
        if (seenNames.has(memberName)) {
          this.raise(FlowErrors.EnumDuplicateMemberName, id, {
            memberName,
            enumName
          });
        }
        seenNames.add(memberName);
        const context2 = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;
        switch (init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, "boolean");
            memberNode.init = init.value;
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, "number");
            memberNode.init = init.value;
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, "string");
            memberNode.init = init.value;
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid": {
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context2);
          }
          case "none": {
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context2);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
        }
        if (!this.match(8)) {
          this.expect(12);
        }
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (!this.eatContextual(102)) return null;
      if (!tokenIsIdentifier(this.state.type)) {
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName
        });
      }
      const {
        value
      } = this.state;
      this.next();
      if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
        this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
          enumName,
          invalidEnumType: value
        });
      }
      return value;
    }
    flowEnumBody(node2, id) {
      const enumName = id.name;
      const nameLoc = id.loc.start;
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(5);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      node2.hasUnknownMembers = hasUnknownMembers;
      switch (explicitType) {
        case "boolean":
          node2.explicitType = true;
          node2.members = members.booleanMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumBooleanBody");
        case "number":
          node2.explicitType = true;
          node2.members = members.numberMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumNumberBody");
        case "string":
          node2.explicitType = true;
          node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(8);
          return this.finishNode(node2, "EnumStringBody");
        case "symbol":
          node2.members = members.defaultedMembers;
          this.expect(8);
          return this.finishNode(node2, "EnumSymbolBody");
        default: {
          const empty = () => {
            node2.members = [];
            this.expect(8);
            return this.finishNode(node2, "EnumStringBody");
          };
          node2.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node2, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node2.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node2.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node2, "EnumNumberBody");
          } else {
            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
              enumName
            });
            return empty();
          }
        }
      }
    }
    flowParseEnumDeclaration(node2) {
      const id = this.parseIdentifier();
      node2.id = id;
      node2.body = this.flowEnumBody(this.startNode(), id);
      return this.finishNode(node2, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.shouldParseTypes()) {
        if (this.match(47) || this.match(51)) {
          node2.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
        }
      }
      return super.jsxParseOpeningElementAfterName(node2);
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return false;
    }
    reScan_lt_gt() {
      const {
        type
      } = this.state;
      if (type === 47) {
        this.state.pos -= 1;
        this.readToken_lt();
      } else if (type === 48) {
        this.state.pos -= 1;
        this.readToken_gt();
      }
    }
    reScan_lt() {
      const {
        type
      } = this.state;
      if (type === 51) {
        this.state.pos -= 2;
        this.finishOp(47, 1);
        return 47;
      }
      return type;
    }
    maybeUnwrapTypeCastExpression(node2) {
      return node2.type === "TypeCastExpression" ? node2.expression : node2;
    }
  };
  const entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  };
  const lineBreak = /\r\n|[\r\n\u2028\u2029]/;
  const lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    switch (code2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  function hasNewLine(input, start, end) {
    for (let i = start; i < end; i++) {
      if (isNewLine(input.charCodeAt(i))) {
        return true;
      }
    }
    return false;
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function isWhitespace(code2) {
    switch (code2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  const JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName
    }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected,
      HTMLEntity
    }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    throw new Error("Node had unexpected type: " + object.type);
  }
  var jsx2 = (superClass) => class JSXParserMixin extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.canStartJSXElement) {
                ++this.state.pos;
                this.finishToken(143);
              } else {
                super.getTokenFromCode(ch);
              }
              return;
            }
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(142, out);
            return;
          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }
    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(Errors.UnterminatedString, this.state.startLoc);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(134, out);
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let radix = 10;
        if (this.codePointAtPos(this.state.pos) === 120) {
          radix = 16;
          ++this.state.pos;
        }
        const codePoint = this.readInt(radix, void 0, false, "bail");
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
          ++this.state.pos;
          return String.fromCodePoint(codePoint);
        }
      } else {
        let count = 0;
        let semi = false;
        while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
          ++this.state.pos;
        }
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos);
          const entity = entities[desc];
          ++this.state.pos;
          if (entity) {
            return entity;
          }
        }
      }
      this.state.pos = startPos;
      return "&";
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);
      this.finishToken(141, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node2 = this.startNode();
      if (this.match(141)) {
        node2.name = this.state.value;
      } else if (tokenIsKeyword(this.state.type)) {
        node2.name = tokenLabelName(this.state.type);
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node2, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(14)) return name;
      const node2 = this.startNodeAt(startLoc);
      node2.namespace = name;
      node2.name = this.jsxParseIdentifier();
      return this.finishNode(node2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startLoc = this.state.startLoc;
      let node2 = this.jsxParseNamespacedName();
      if (node2.type === "JSXNamespacedName") {
        return node2;
      }
      while (this.eat(16)) {
        const newNode = this.startNodeAt(startLoc);
        newNode.object = node2;
        newNode.property = this.jsxParseIdentifier();
        node2 = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node2;
    }
    jsxParseAttributeValue() {
      let node2;
      switch (this.state.type) {
        case 5:
          node2 = this.startNode();
          this.setContext(types2.brace);
          this.next();
          node2 = this.jsxParseExpressionContainer(node2, types2.j_oTag);
          if (node2.expression.type === "JSXEmptyExpression") {
            this.raise(JsxErrors.AttributeIsEmpty, node2);
          }
          return node2;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const node2 = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(node2) {
      this.next();
      node2.expression = this.parseExpression();
      this.setContext(types2.j_expr);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node2, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node2, previousContext) {
      if (this.match(8)) {
        node2.expression = this.jsxParseEmptyExpression();
      } else {
        const expression = this.parseExpression();
        node2.expression = expression;
      }
      this.setContext(previousContext);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node2, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node2 = this.startNode();
      if (this.match(5)) {
        this.setContext(types2.brace);
        this.next();
        this.expect(21);
        node2.argument = this.parseMaybeAssignAllowIn();
        this.setContext(types2.j_oTag);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node2, "JSXSpreadAttribute");
      }
      node2.name = this.jsxParseNamespacedName();
      node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node2, "JSXAttribute");
    }
    jsxParseOpeningElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      if (this.eat(144)) {
        return this.finishNode(node2, "JSXOpeningFragment");
      }
      node2.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node2);
    }
    jsxParseOpeningElementAfterName(node2) {
      const attributes = [];
      while (!this.match(56) && !this.match(144)) {
        attributes.push(this.jsxParseAttribute());
      }
      node2.attributes = attributes;
      node2.selfClosing = this.eat(56);
      this.expect(144);
      return this.finishNode(node2, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      if (this.eat(144)) {
        return this.finishNode(node2, "JSXClosingFragment");
      }
      node2.name = this.jsxParseElementName();
      this.expect(144);
      return this.finishNode(node2, "JSXClosingElement");
    }
    jsxParseElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; ) {
          switch (this.state.type) {
            case 143:
              startLoc = this.state.startLoc;
              this.next();
              if (this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startLoc);
                break contents;
              }
              children.push(this.jsxParseElementAt(startLoc));
              break;
            case 142:
              children.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              const node3 = this.startNode();
              this.setContext(types2.brace);
              this.next();
              if (this.match(21)) {
                children.push(this.jsxParseSpreadChild(node3));
              } else {
                children.push(this.jsxParseExpressionContainer(node3, types2.j_expr));
              }
              break;
            }
            default:
              this.unexpected();
          }
        }
        if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
          this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
            openingTagName: getQualifiedJSXName(openingElement.name)
          });
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          }
        }
      }
      if (isFragment(openingElement)) {
        node2.openingFragment = openingElement;
        node2.closingFragment = closingElement;
      } else {
        node2.openingElement = openingElement;
        node2.closingElement = closingElement;
      }
      node2.children = children;
      if (this.match(47)) {
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
      }
      return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
    }
    jsxParseElement() {
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startLoc);
    }
    setContext(newContext) {
      const {
        context: context2
      } = this.state;
      context2[context2.length - 1] = newContext;
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(143)) {
        return this.jsxParseElement();
      } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
        this.replaceToken(143);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }
    skipSpace() {
      const curContext = this.curContext();
      if (!curContext.preserveSpace) super.skipSpace();
    }
    getTokenFromCode(code2) {
      const context2 = this.curContext();
      if (context2 === types2.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (context2 === types2.j_oTag || context2 === types2.j_cTag) {
        if (isIdentifierStart(code2)) {
          this.jsxReadWord();
          return;
        }
        if (code2 === 62) {
          ++this.state.pos;
          this.finishToken(144);
          return;
        }
        if ((code2 === 34 || code2 === 39) && context2 === types2.j_oTag) {
          this.jsxReadString(code2);
          return;
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        this.finishToken(143);
        return;
      }
      super.getTokenFromCode(code2);
    }
    updateContext(prevType) {
      const {
        context: context2,
        type
      } = this.state;
      if (type === 56 && prevType === 143) {
        context2.splice(-2, 2, types2.j_cTag);
        this.state.canStartJSXElement = false;
      } else if (type === 143) {
        context2.push(types2.j_oTag);
      } else if (type === 144) {
        const out = context2[context2.length - 1];
        if (out === types2.j_oTag && prevType === 56 || out === types2.j_cTag) {
          context2.pop();
          this.state.canStartJSXElement = context2[context2.length - 1] === types2.j_expr;
        } else {
          this.setContext(types2.j_expr);
          this.state.canStartJSXElement = true;
        }
      } else {
        this.state.canStartJSXElement = tokenComesBeforeExpression(type);
      }
    }
  };
  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args);
      this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args) {
      super(...args);
      this.importsStack = [];
    }
    createScope(flags) {
      this.importsStack.push(/* @__PURE__ */ new Set());
      return new TypeScriptScope(flags);
    }
    enter(flags) {
      if (flags === 1024) {
        this.importsStack.push(/* @__PURE__ */ new Set());
      }
      super.enter(flags);
    }
    exit() {
      const flags = super.exit();
      if (flags === 1024) {
        this.importsStack.pop();
      }
      return flags;
    }
    hasImport(name, allowShadow) {
      const len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name)) {
        return true;
      }
      if (!allowShadow && len > 1) {
        for (let i = 0; i < len - 1; i++) {
          if (this.importsStack[i].has(name)) return true;
        }
      }
      return false;
    }
    declareName(name, bindingType, loc) {
      if (bindingType & 4096) {
        if (this.hasImport(name, true)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
        this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      const scope2 = this.currentScope();
      let type = scope2.tsNames.get(name) || 0;
      if (bindingType & 1024) {
        this.maybeExportDefined(scope2, name);
        scope2.tsNames.set(name, type | 16);
        return;
      }
      super.declareName(name, bindingType, loc);
      if (bindingType & 2) {
        if (!(bindingType & 1)) {
          this.checkRedeclarationInScope(scope2, name, bindingType, loc);
          this.maybeExportDefined(scope2, name);
        }
        type = type | 1;
      }
      if (bindingType & 256) {
        type = type | 2;
      }
      if (bindingType & 512) {
        type = type | 4;
      }
      if (bindingType & 128) {
        type = type | 8;
      }
      if (type) scope2.tsNames.set(name, type);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      const type = scope2.tsNames.get(name);
      if ((type & 2) > 0) {
        if (bindingType & 256) {
          const isConst = !!(bindingType & 512);
          const wasConst = (type & 4) > 0;
          return isConst !== wasConst;
        }
        return true;
      }
      if (bindingType & 128 && (type & 8) > 0) {
        if (scope2.names.get(name) & 2) {
          return !!(bindingType & 1);
        } else {
          return false;
        }
      }
      if (bindingType & 2 && (type & 1) > 0) {
        return true;
      }
      return super.isRedeclaredInScope(scope2, name, bindingType);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      if (this.hasImport(name)) return;
      const len = this.scopeStack.length;
      for (let i = len - 1; i >= 0; i--) {
        const scope2 = this.scopeStack[i];
        const type = scope2.tsNames.get(name);
        if ((type & 1) > 0 || (type & 16) > 0) {
          return;
        }
      }
      super.checkLocalExport(id);
    }
  }
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
  }
  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }
    sourceToOffsetPos(sourcePos) {
      return sourcePos + this.startIndex;
    }
    offsetToSourcePos(offsetPos) {
      return offsetPos - this.startIndex;
    }
    hasPlugin(pluginConfig) {
      if (typeof pluginConfig === "string") {
        return this.plugins.has(pluginConfig);
      } else {
        const [pluginName, pluginOptions] = pluginConfig;
        if (!this.hasPlugin(pluginName)) {
          return false;
        }
        const actualOptions = this.plugins.get(pluginName);
        for (const key of Object.keys(pluginOptions)) {
          if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
            return false;
          }
        }
        return true;
      }
    }
    getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    }
  }
  function setTrailingComments(node2, comments2) {
    if (node2.trailingComments === void 0) {
      node2.trailingComments = comments2;
    } else {
      node2.trailingComments.unshift(...comments2);
    }
  }
  function setLeadingComments(node2, comments2) {
    if (node2.leadingComments === void 0) {
      node2.leadingComments = comments2;
    } else {
      node2.leadingComments.unshift(...comments2);
    }
  }
  function setInnerComments(node2, comments2) {
    if (node2.innerComments === void 0) {
      node2.innerComments = comments2;
    } else {
      node2.innerComments.unshift(...comments2);
    }
  }
  function adjustInnerComments(node2, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === null || lastElement.start > commentWS.start) {
      setInnerComments(node2, commentWS.comments);
    } else {
      setTrailingComments(lastElement, commentWS.comments);
    }
  }
  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      const {
        commentsLen
      } = this.state;
      if (this.comments.length !== commentsLen) {
        this.comments.length = commentsLen;
      }
      this.comments.push(comment);
      this.state.commentsLen++;
    }
    processComment(node2) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i = commentStackLength - 1;
      const lastCommentWS = commentStack[i];
      if (lastCommentWS.start === node2.end) {
        lastCommentWS.leadingNode = node2;
        i--;
      }
      const {
        start: nodeStart
      } = node2;
      for (; i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        if (commentEnd > nodeStart) {
          commentWS.containingNode = node2;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node2;
          }
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      var _node$options;
      const {
        comments: comments2
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments2);
        }
        if (commentWS.trailingNode !== null) {
          setLeadingComments(commentWS.trailingNode, comments2);
        }
      } else {
        const node2 = commentWS.containingNode;
        const commentStart = commentWS.start;
        if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
          switch (node2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node2, node2.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node2, node2.arguments, commentWS);
              break;
            case "ImportExpression":
              adjustInnerComments(node2, [node2.source, (_node$options = node2.options) != null ? _node$options : null], commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node2, node2.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node2, node2.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node2, node2.specifiers, commentWS);
              break;
            case "TSEnumDeclaration":
              {
                adjustInnerComments(node2, node2.members, commentWS);
              }
              break;
            case "TSEnumBody":
              adjustInnerComments(node2, node2.members, commentWS);
              break;
            default: {
              setInnerComments(node2, comments2);
            }
          }
        } else {
          setInnerComments(node2, comments2);
        }
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i = commentStack.length - 1; i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node2) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0) return;
      const commentWS = commentStack[length - 1];
      if (commentWS.leadingNode === node2) {
        commentWS.leadingNode = null;
      }
    }
    takeSurroundingComments(node2, start, end) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i = commentStackLength - 1;
      for (; i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        const commentStart = commentWS.start;
        if (commentStart === end) {
          commentWS.leadingNode = node2;
        } else if (commentEnd === start) {
          commentWS.trailingNode = node2;
        } else if (commentEnd < start) {
          break;
        }
      }
    }
  }
  class State {
    constructor() {
      this.flags = 1024;
      this.startIndex = void 0;
      this.curLine = void 0;
      this.lineStart = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.labels = [];
      this.commentsLen = 0;
      this.commentStack = [];
      this.pos = 0;
      this.type = 140;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.context = [types2.brace];
      this.firstInvalidTemplateEscapePos = null;
      this.strictErrors = /* @__PURE__ */ new Map();
      this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(v2) {
      if (v2) this.flags |= 1;
      else this.flags &= -2;
    }
    init({
      strictMode,
      sourceType,
      startIndex,
      startLine,
      startColumn
    }) {
      this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
      this.startIndex = startIndex;
      this.curLine = startLine;
      this.lineStart = -startColumn;
      this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(v2) {
      if (v2) this.flags |= 2;
      else this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(v2) {
      if (v2) this.flags |= 4;
      else this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(v2) {
      if (v2) this.flags |= 8;
      else this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(v2) {
      if (v2) this.flags |= 16;
      else this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(v2) {
      if (v2) this.flags |= 32;
      else this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(v2) {
      if (v2) this.flags |= 64;
      else this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(v2) {
      if (v2) this.flags |= 128;
      else this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(v2) {
      if (v2) this.flags |= 256;
      else this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(v2) {
      if (v2) this.flags |= 512;
      else this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(v2) {
      if (v2) this.flags |= 1024;
      else this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(v2) {
      if (v2) this.flags |= 2048;
      else this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(v2) {
      if (v2) this.flags |= 4096;
      else this.flags &= -4097;
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      const state = new State();
      state.flags = this.flags;
      state.startIndex = this.startIndex;
      state.curLine = this.curLine;
      state.lineStart = this.lineStart;
      state.startLoc = this.startLoc;
      state.endLoc = this.endLoc;
      state.errors = this.errors.slice();
      state.potentialArrowAt = this.potentialArrowAt;
      state.noArrowAt = this.noArrowAt.slice();
      state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
      state.topicContext = this.topicContext;
      state.labels = this.labels.slice();
      state.commentsLen = this.commentsLen;
      state.commentStack = this.commentStack.slice();
      state.pos = this.pos;
      state.type = this.type;
      state.value = this.value;
      state.start = this.start;
      state.end = this.end;
      state.lastTokEndLoc = this.lastTokEndLoc;
      state.lastTokStartLoc = this.lastTokStartLoc;
      state.context = this.context.slice();
      state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
      state.strictErrors = this.strictErrors;
      state.tokensLength = this.tokensLength;
      return state;
    }
  }
  var _isDigit = function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  };
  const isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (; ; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code2;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
      }
      case 117: {
        let code2;
        ({
          code: code2,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
      }
      case 116:
        return res("	");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code2 = input.charCodeAt(pos);
      let val;
      if (code2 === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (_isDigit(code2)) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    if (ch === 123) {
      ++pos;
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code2 !== null && code2 > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code: code2,
      pos
    };
  }
  function buildPosition(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
  }
  const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Token {
    constructor(state) {
      const startIndex = state.startIndex || 0;
      this.type = state.type;
      this.value = state.value;
      this.start = startIndex + state.start;
      this.end = startIndex + state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }
  class Tokenizer extends CommentsParser {
    constructor(options2, input) {
      super();
      this.isLookahead = void 0;
      this.tokens = [];
      this.errorHandlers_readInt = {
        invalidDigit: (pos, lineStart, curLine, radix) => {
          if (!(this.optionFlags & 2048)) return false;
          this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
            radix
          });
          return true;
        },
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
      };
      this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
      });
      this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (pos, lineStart, curLine) => {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
        },
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
        }
      });
      this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
        }
      });
      this.state = new State();
      this.state.init(options2);
      this.input = input;
      this.length = input.length;
      this.comments = [];
      this.isLookahead = false;
    }
    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes();
      if (this.optionFlags & 256) {
        this.pushToken(new Token(this.state));
      }
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
    match(type) {
      return this.state.type === type;
    }
    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    }
    lookahead() {
      const old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(pos) {
      return this.input.charCodeAt(this.nextTokenStartSince(pos));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos) {
      skipWhiteSpaceInLine.lastIndex = pos;
      return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos) {
      let cp2 = this.input.charCodeAt(pos);
      if ((cp2 & 64512) === 55296 && ++pos < this.input.length) {
        const trail = this.input.charCodeAt(pos);
        if ((trail & 64512) === 56320) {
          cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023);
        }
      }
      return cp2;
    }
    setStrict(strict) {
      this.state.strict = strict;
      if (strict) {
        this.state.strictErrors.forEach(([toParseError, at3]) => this.raise(toParseError, at3));
        this.state.strictErrors.clear();
      }
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
      let startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf(commentEnd, start + 2);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
      this.state.pos = end + commentEnd.length;
      lineBreakG.lastIndex = start + 2;
      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }
      if (this.isLookahead) return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end + commentEnd.length),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.optionFlags & 256) this.pushToken(comment);
      return comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }
      if (this.isLookahead) return;
      const end = this.state.pos;
      const value = this.input.slice(start + startSkip, end);
      const comment = {
        type: "CommentLine",
        value,
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.optionFlags & 256) this.pushToken(comment);
      return comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos;
      const comments2 = this.optionFlags & 4096 ? [] : null;
      loop: while (this.state.pos < this.length) {
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const comment = this.skipBlockComment("*/");
                if (comment !== void 0) {
                  this.addComment(comment);
                  comments2 == null || comments2.push(comment);
                }
                break;
              }
              case 47: {
                const comment = this.skipLineComment(2);
                if (comment !== void 0) {
                  this.addComment(comment);
                  comments2 == null || comments2.push(comment);
                }
                break;
              }
              default:
                break loop;
            }
            break;
          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
              const pos = this.state.pos;
              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                const comment = this.skipLineComment(3);
                if (comment !== void 0) {
                  this.addComment(comment);
                  comments2 == null || comments2.push(comment);
                }
              } else {
                break loop;
              }
            } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
              const pos = this.state.pos;
              if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                const comment = this.skipLineComment(4);
                if (comment !== void 0) {
                  this.addComment(comment);
                  comments2 == null || comments2.push(comment);
                }
              } else {
                break loop;
              }
            } else {
              break loop;
            }
        }
      }
      if ((comments2 == null ? void 0 : comments2.length) > 0) {
        const end = this.state.pos;
        const commentWhitespace = {
          start: this.sourceToOffsetPos(spaceStart),
          end: this.sourceToOffsetPos(end),
          comments: comments2,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
    finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) {
        this.updateContext(prevType);
      }
    }
    replaceToken(type) {
      this.state.type = type;
      this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }
      const nextPos = this.state.pos + 1;
      const next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57) {
        throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
      }
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");
        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        }
        this.state.pos += 2;
        if (next === 123) {
          this.finishToken(7);
        } else {
          this.finishToken(1);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(139, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(139, this.readWord1());
      } else {
        this.finishOp(27, 1);
      }
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }
      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(21);
      } else {
        ++this.state.pos;
        this.finishToken(16);
      }
    }
    readToken_slash() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(31, 2);
      } else {
        this.finishOp(56, 1);
      }
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      const start = this.state.pos;
      this.state.pos += 1;
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(28, value);
      return true;
    }
    readToken_mult_modulo(code2) {
      let type = code2 === 42 ? 55 : 54;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = 57;
      }
      if (next === 61 && !this.state.inType) {
        width++;
        type = code2 === 37 ? 33 : 30;
      }
      this.finishOp(type, width);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(code2 === 124 ? 41 : 42, 2);
        }
        return;
      }
      if (code2 === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61 && !this.state.inType) {
        this.finishOp(32, 2);
      } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        this.finishOp(37, 2);
        const lookaheadCh = this.input.codePointAt(this.state.pos);
        if (lookaheadCh === 94) {
          this.unexpected();
        }
      } else {
        this.finishOp(44, 1);
      }
    }
    readToken_atSign() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }])) {
        this.finishOp(38, 2);
      } else {
        this.finishOp(26, 1);
      }
    }
    readToken_plus_min(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.finishOp(34, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(30, 2);
      } else {
        this.finishOp(53, 1);
      }
    }
    readToken_lt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 62) {
        const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code2 === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(19);
        return;
      }
      this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(40, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(18);
      } else {
        ++this.state.pos;
        this.finishToken(17);
      }
    }
    getTokenFromCode(code2) {
      switch (code2) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos;
          this.finishToken(10);
          return;
        case 41:
          ++this.state.pos;
          this.finishToken(11);
          return;
        case 59:
          ++this.state.pos;
          this.finishToken(13);
          return;
        case 44:
          ++this.state.pos;
          this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(2);
          } else {
            ++this.state.pos;
            this.finishToken(0);
          }
          return;
        case 93:
          ++this.state.pos;
          this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(6);
          } else {
            ++this.state.pos;
            this.finishToken(5);
          }
          return;
        case 125:
          ++this.state.pos;
          this.finishToken(8);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(15, 2);
          } else {
            ++this.state.pos;
            this.finishToken(14);
          }
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(code2);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code2);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code2);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code2);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code2);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code2)) {
            this.readWord(code2);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(code2)
      });
    }
    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
    readRegexp() {
      const startLoc = this.state.startLoc;
      const start = this.state.start + 1;
      let escaped, inClass;
      let {
        pos
      } = this.state;
      for (; ; ++pos) {
        if (pos >= this.length) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        const ch = this.input.charCodeAt(pos);
        if (isNewLine(ch)) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos);
      ++pos;
      let mods = "";
      const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
      while (pos < this.length) {
        const cp2 = this.codePointAtPos(pos);
        const char = String.fromCharCode(cp2);
        if (VALID_REGEX_FLAGS.has(cp2)) {
          if (cp2 === 118) {
            if (mods.includes("u")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          } else if (cp2 === 117) {
            if (mods.includes("v")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          }
          if (mods.includes(char)) {
            this.raise(Errors.DuplicateRegExpFlags, nextPos());
          }
        } else if (isIdentifierChar(cp2) || cp2 === 92) {
          this.raise(Errors.MalformedRegExpFlags, nextPos());
        } else {
          break;
        }
        ++pos;
        mods += char;
      }
      this.state.pos = pos;
      this.finishToken(138, {
        pattern: content,
        flags: mods
      });
    }
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
      const {
        n,
        pos
      } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
      this.state.pos = pos;
      return n;
    }
    readRadixNumber(radix) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);
      if (val == null) {
        this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
          radix
        });
      }
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(Errors.InvalidDecimal, startLoc);
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      if (isBigInt) {
        const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, str);
        return;
      }
      this.finishToken(135, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let isFloat = false;
      let isBigInt = false;
      let hasExponent = false;
      let isOctal = false;
      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(Errors.InvalidNumber, this.state.curPosition());
      }
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
        if (!this.state.strict) {
          const underscorePos = integer.indexOf("_");
          if (underscorePos > 0) {
            this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
          }
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45) {
          ++this.state.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(Errors.InvalidOrMissingExponent, startLoc);
        }
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(Errors.InvalidBigIntLiteral, startLoc);
        }
        ++this.state.pos;
        isBigInt = true;
      }
      if (next === 109) {
        this.expectPlugin("decimal", this.state.curPosition());
        if (hasExponent || hasLeadingZero) {
          this.raise(Errors.InvalidDecimal, startLoc);
        }
        ++this.state.pos;
        var isDecimal = true;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(136, str);
        return;
      }
      if (isDecimal) {
        this.finishToken(137, str);
        return;
      }
      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(135, val);
    }
    readCodePoint(throwOnInvalid) {
      const {
        code: code2,
        pos
      } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
      this.state.pos = pos;
      return code2;
    }
    readString(quote) {
      const {
        str,
        pos,
        curLine,
        lineStart
      } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      this.finishToken(134, str);
    }
    readTemplateContinuation() {
      if (!this.match(8)) {
        this.unexpected(null, 8);
      }
      this.state.pos--;
      this.readTemplateToken();
    }
    readTemplateToken() {
      const opening = this.input[this.state.pos];
      const {
        str,
        firstInvalidLoc,
        pos,
        curLine,
        lineStart
      } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      if (firstInvalidLoc) {
        this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
      }
      if (this.input.codePointAt(pos) === 96) {
        this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
      } else {
        this.state.pos++;
        this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
      }
    }
    recordStrictModeErrors(toParseError, at3) {
      const index = at3.index;
      if (this.state.strict && !this.state.strictErrors.has(index)) {
        this.raise(toParseError, at3);
      } else {
        this.state.strictErrors.set(index, [toParseError, at3]);
      }
    }
    readWord1(firstCode) {
      this.state.containsEsc = false;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      if (firstCode !== void 0) {
        this.state.pos += firstCode <= 65535 ? 1 : 2;
      }
      while (this.state.pos < this.length) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.curPosition();
          const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
            chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(true);
          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
            }
            word += String.fromCodePoint(esc);
          }
          chunkStart = this.state.pos;
        } else {
          break;
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode);
      const type = keywords$1.get(word);
      if (type !== void 0) {
        this.finishToken(type, tokenLabelName(type));
      } else {
        this.finishToken(132, word);
      }
    }
    checkKeywordEscapes() {
      const {
        type
      } = this.state;
      if (tokenIsKeyword(type) && this.state.containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
          reservedWord: tokenLabelName(type)
        });
      }
    }
    raise(toParseError, at3, details = {}) {
      const loc = at3 instanceof Position ? at3 : at3.loc.start;
      const error = toParseError(loc, details);
      if (!(this.optionFlags & 2048)) throw error;
      if (!this.isLookahead) this.state.errors.push(error);
      return error;
    }
    raiseOverwrite(toParseError, at3, details = {}) {
      const loc = at3 instanceof Position ? at3 : at3.loc.start;
      const pos = loc.index;
      const errors = this.state.errors;
      for (let i = errors.length - 1; i >= 0; i--) {
        const error = errors[i];
        if (error.loc.index === pos) {
          return errors[i] = toParseError(loc, details);
        }
        if (error.loc.index < pos) break;
      }
      return this.raise(toParseError, at3, details);
    }
    updateContext(prevType) {
    }
    unexpected(loc, type) {
      throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
        expected: type ? tokenLabelName(type) : null
      });
    }
    expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName)) {
        return true;
      }
      throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
        missingPlugin: [pluginName]
      });
    }
    expectOnePlugin(pluginNames) {
      if (!pluginNames.some((name) => this.hasPlugin(name))) {
        throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: pluginNames
        });
      }
    }
    errorBuilder(error) {
      return (pos, lineStart, curLine) => {
        this.raise(error, buildPosition(pos, lineStart, curLine));
      };
    }
  }
  class ClassScope {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set();
      this.loneAccessors = /* @__PURE__ */ new Map();
      this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class ClassScopeHandler {
    constructor(parser2) {
      this.parser = void 0;
      this.stack = [];
      this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      this.parser = parser2;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope());
    }
    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();
      for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, loc);
          }
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    }
    declarePrivateName(name, elementType, loc) {
      const {
        privateNames,
        loneAccessors,
        undefinedPrivateNames
      } = this.current();
      let redefined = privateNames.has(name);
      if (elementType & 3) {
        const accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & 4;
          const newStatic = elementType & 4;
          const oldKind = accessor & 3;
          const newKind = elementType & 3;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) loneAccessors.delete(name);
        } else if (!redefined) {
          loneAccessors.set(name, elementType);
        }
      }
      if (redefined) {
        this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
          identifierName: name
        });
      }
      privateNames.add(name);
      undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
      let classScope;
      for (classScope of this.stack) {
        if (classScope.privateNames.has(name)) return;
      }
      if (classScope) {
        classScope.undefinedPrivateNames.set(name, loc);
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
      }
    }
  }
  class ExpressionScope {
    constructor(type = 0) {
      this.type = type;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type) {
      super(type);
      this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(ParsingErrorClass, at3) {
      const index = at3.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at3]);
    }
    clearDeclarationError(index) {
      this.declarationErrors.delete(index);
    }
    iterateErrors(iterator) {
      this.declarationErrors.forEach(iterator);
    }
  }
  class ExpressionScopeHandler {
    constructor(parser2) {
      this.parser = void 0;
      this.stack = [new ExpressionScope()];
      this.parser = parser2;
    }
    enter(scope2) {
      this.stack.push(scope2);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(toParseError, node2) {
      const origin = node2.loc.start;
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope2 = stack[i];
      while (!scope2.isCertainlyParameterDeclaration()) {
        if (scope2.canBeArrowParameterDeclaration()) {
          scope2.recordDeclarationError(toParseError, origin);
        } else {
          return;
        }
        scope2 = stack[--i];
      }
      this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error, node2) {
      const {
        stack
      } = this;
      const scope2 = stack[stack.length - 1];
      const origin = node2.loc.start;
      if (scope2.isCertainlyParameterDeclaration()) {
        this.parser.raise(error, origin);
      } else if (scope2.canBeArrowParameterDeclaration()) {
        scope2.recordDeclarationError(error, origin);
      } else {
        return;
      }
    }
    recordAsyncArrowParametersError(at3) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope2 = stack[i];
      while (scope2.canBeArrowParameterDeclaration()) {
        if (scope2.type === 2) {
          scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, at3);
        }
        scope2 = stack[--i];
      }
    }
    validateAsPattern() {
      const {
        stack
      } = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(([toParseError, loc]) => {
        this.parser.raise(toParseError, loc);
        let i = stack.length - 2;
        let scope2 = stack[i];
        while (scope2.canBeArrowParameterDeclaration()) {
          scope2.clearDeclarationError(loc.index);
          scope2 = stack[--i];
        }
      });
    }
  }
  function newParameterDeclarationScope() {
    return new ExpressionScope(3);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }
  class UtilParser extends Tokenizer {
    addExtra(node2, key, value, enumerable = true) {
      if (!node2) return;
      let {
        extra
      } = node2;
      if (extra == null) {
        extra = {};
        node2.extra = extra;
      }
      if (enumerable) {
        extra[key] = value;
      } else {
        Object.defineProperty(extra, key, {
          enumerable,
          value
        });
      }
    }
    isContextual(token) {
      return this.state.type === token && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      if (this.input.startsWith(name, nameStart)) {
        const nextCh = this.input.charCodeAt(nameStart + name.length);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(token) {
      if (this.isContextual(token)) {
        this.next();
        return true;
      }
      return false;
    }
    expectContextual(token, toParseError) {
      if (!this.eatContextual(token)) {
        if (toParseError != null) {
          throw this.raise(toParseError, this.state.startLoc);
        }
        this.unexpected(null, token);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return hasNewLine(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
      this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(type, loc) {
      if (!this.eat(type)) {
        this.unexpected(loc, type);
      }
    }
    tryParse(fn2, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node2 = fn2((node3 = null) => {
          abortSignal.node = node3;
          throw abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: node2,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }
        return {
          node: node2,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;
        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }
        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }
        throw error;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      const {
        shorthandAssignLoc,
        doubleProtoLoc,
        privateKeyLoc,
        optionalParametersLoc,
        voidPatternLoc
      } = refExpressionErrors;
      const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;
      if (!andThrow) {
        return hasErrors;
      }
      if (shorthandAssignLoc != null) {
        this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
      }
      if (doubleProtoLoc != null) {
        this.raise(Errors.DuplicateProto, doubleProtoLoc);
      }
      if (privateKeyLoc != null) {
        this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
      }
      if (optionalParametersLoc != null) {
        this.unexpected(optionalParametersLoc);
      }
      if (voidPatternLoc != null) {
        this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
      }
    }
    isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node2) {
      return node2.type === "PrivateName";
    }
    getPrivateNameSV(node2) {
      return node2.id.name;
    }
    hasPropertyAsPrivateName(node2) {
      return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
    }
    isObjectProperty(node2) {
      return node2.type === "ObjectProperty";
    }
    isObjectMethod(node2) {
      return node2.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this, inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this);
      return () => {
        this.state.labels = oldLabels;
        this.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = 0;
      if (this.inModule || this.optionFlags & 1) {
        paramFlags |= 2;
      }
      if (this.optionFlags & 32) {
        paramFlags |= 1;
      }
      const isCommonJS = !this.inModule && this.options.sourceType === "commonjs";
      if (isCommonJS || this.optionFlags & 2) {
        paramFlags |= 4;
      }
      this.prodParam.enter(paramFlags);
      let scopeFlags = isCommonJS ? 514 : 1;
      if (this.optionFlags & 4) {
        scopeFlags |= 512;
      }
      this.scope.enter(scopeFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
      const {
        privateKeyLoc
      } = refExpressionErrors;
      if (privateKeyLoc !== null) {
        this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    }
  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssignLoc = null;
      this.doubleProtoLoc = null;
      this.privateKeyLoc = null;
      this.optionalParametersLoc = null;
      this.voidPatternLoc = null;
    }
  }
  class Node {
    constructor(parser2, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if ((parser2 == null ? void 0 : parser2.optionFlags) & 128) this.range = [pos, 0];
      if (parser2 != null && parser2.filename) this.loc.filename = parser2.filename;
    }
  }
  const NodePrototype = Node.prototype;
  {
    NodePrototype.__clone = function() {
      const newNode = new Node(void 0, this.start, this.loc.start);
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
  }
  class NodeUtils extends UtilParser {
    startNode() {
      const loc = this.state.startLoc;
      return new Node(this, loc.index, loc);
    }
    startNodeAt(loc) {
      return new Node(this, loc.index, loc);
    }
    startNodeAtNode(type) {
      return this.startNodeAt(type.loc.start);
    }
    finishNode(node2, type) {
      return this.finishNodeAt(node2, type, this.state.lastTokEndLoc);
    }
    finishNodeAt(node2, type, endLoc) {
      node2.type = type;
      node2.end = endLoc.index;
      node2.loc.end = endLoc;
      if (this.optionFlags & 128) node2.range[1] = endLoc.index;
      if (this.optionFlags & 4096) {
        this.processComment(node2);
      }
      return node2;
    }
    resetStartLocation(node2, startLoc) {
      node2.start = startLoc.index;
      node2.loc.start = startLoc;
      if (this.optionFlags & 128) node2.range[0] = startLoc.index;
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      node2.end = endLoc.index;
      node2.loc.end = endLoc;
      if (this.optionFlags & 128) node2.range[1] = endLoc.index;
    }
    resetStartLocationFromNode(node2, locationNode) {
      this.resetStartLocation(node2, locationNode.loc.start);
    }
    castNodeTo(node2, type) {
      node2.type = type;
      return node2;
    }
    cloneIdentifier(node2) {
      const {
        type,
        start,
        end,
        loc,
        range,
        name
      } = node2;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.name = name;
      if (node2.extra) cloned.extra = node2.extra;
      return cloned;
    }
    cloneStringLiteral(node2) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node2;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.value = node2.value;
      return cloned;
    }
  }
  const unwrapParenthesizedExpression = (node2) => {
    return node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
  };
  class LValParser extends NodeUtils {
    toAssignable(node2, isLHS = false) {
      var _node$extra, _node$extra3;
      let parenthesized = void 0;
      if (node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node2);
        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node2);
          } else if (parenthesized.type !== "CallExpression" && parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
            this.raise(Errors.InvalidParenthesizedAssignment, node2);
          }
        } else {
          this.raise(Errors.InvalidParenthesizedAssignment, node2);
        }
      }
      switch (node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(node2, "ObjectPattern");
          for (let i = 0, length = node2.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;
            const prop = node2.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
            if (isLast && prop.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, node2.extra.trailingCommaLoc);
            }
          }
          break;
        case "ObjectProperty": {
          const {
            key,
            value
          } = node2;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
          break;
        }
        case "SpreadElement": {
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        }
        case "ArrayExpression":
          this.castNodeTo(node2, "ArrayPattern");
          this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          if (node2.operator !== "=") {
            this.raise(Errors.MissingEqInAssignment, node2.left.loc.end);
          }
          this.castNodeTo(node2, "AssignmentPattern");
          delete node2.operator;
          if (node2.left.type === "VoidPattern") {
            this.raise(Errors.VoidPatternInitializer, node2.left);
          }
          this.toAssignable(node2.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
      } else if (prop.type === "SpreadElement") {
        this.castNodeTo(prop, "RestElement");
        const arg = prop.argument;
        this.checkToRestConversion(arg, false);
        this.toAssignable(arg, isLHS);
        if (!isLast) {
          this.raise(Errors.RestTrailingComma, prop);
        }
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      const end = exprList.length - 1;
      for (let i = 0; i <= end; i++) {
        const elt = exprList[i];
        if (!elt) continue;
        this.toAssignableListItem(exprList, i, isLHS);
        if (elt.type === "RestElement") {
          if (i < end) {
            this.raise(Errors.RestTrailingComma, elt);
          } else if (trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, trailingCommaLoc);
          }
        }
      }
    }
    toAssignableListItem(exprList, index, isLHS) {
      const node2 = exprList[index];
      if (node2.type === "SpreadElement") {
        this.castNodeTo(node2, "RestElement");
        const arg = node2.argument;
        this.checkToRestConversion(arg, true);
        this.toAssignable(arg, isLHS);
      } else {
        this.toAssignable(node2, isLHS);
      }
    }
    isAssignable(node2, isBinding2) {
      switch (node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return true;
        case "ObjectExpression": {
          const last = node2.properties.length - 1;
          return node2.properties.every((prop, i) => {
            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
          });
        }
        case "ObjectProperty":
          return this.isAssignable(node2.value);
        case "SpreadElement":
          return this.isAssignable(node2.argument);
        case "ArrayExpression":
          return node2.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node2.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node2.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding2;
        default:
          return false;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList) {
        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }
    parseSpread(refExpressionErrors) {
      const node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
      return this.finishNode(node2, "SpreadElement");
    }
    parseRestBinding() {
      const node2 = this.startNode();
      this.next();
      const argument = this.parseBindingAtom();
      if (argument.type === "VoidPattern") {
        this.raise(Errors.UnexpectedVoidPattern, argument);
      }
      node2.argument = argument;
      return this.finishNode(node2, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const node2 = this.startNode();
          this.next();
          node2.elements = this.parseBindingList(3, 93, 1);
          return this.finishNode(node2, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
      const allowEmpty = flags & 1;
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
        }
        if (allowEmpty && this.match(12)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(21)) {
          let rest = this.parseRestBinding();
          if (this.hasPlugin("flow") || flags & 2) {
            rest = this.parseFunctionParamType(rest);
          }
          elts.push(rest);
          if (!this.checkCommaAfterRest(closeCharCode)) {
            this.expect(close);
            break;
          }
        } else {
          const decorators = [];
          if (flags & 2) {
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          elts.push(this.parseBindingElement(flags, decorators));
        }
      }
      return elts;
    }
    parseBindingRestProperty(prop) {
      this.next();
      if (this.hasPlugin("discardBinding") && this.match(88)) {
        prop.argument = this.parseVoidPattern(null);
        this.raise(Errors.UnexpectedVoidPattern, prop.argument);
      } else {
        prop.argument = this.parseIdentifier();
      }
      this.checkCommaAfterRest(125);
      return this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
      const {
        type,
        startLoc
      } = this.state;
      if (type === 21) {
        return this.parseBindingRestProperty(this.startNode());
      }
      const prop = this.startNode();
      if (type === 139) {
        this.expectPlugin("destructuringPrivate", startLoc);
        this.classScope.usePrivateName(this.state.value, startLoc);
        prop.key = this.parsePrivateName();
      } else {
        this.parsePropertyName(prop);
      }
      prop.method = false;
      return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    parseBindingElement(flags, decorators) {
      const left = this.parseMaybeDefault();
      if (this.hasPlugin("flow") || flags & 2) {
        this.parseFunctionParamType(left);
      }
      if (decorators.length) {
        left.decorators = decorators;
        this.resetStartLocationFromNode(left, decorators[0]);
      }
      const elt = this.parseMaybeDefault(left.loc.start, left);
      return elt;
    }
    parseFunctionParamType(param) {
      return param;
    }
    parseMaybeDefault(startLoc, left) {
      startLoc != null ? startLoc : startLoc = this.state.startLoc;
      left = left != null ? left : this.parseBindingAtom();
      if (!this.eat(29)) return left;
      const node2 = this.startNodeAt(startLoc);
      if (left.type === "VoidPattern") {
        this.raise(Errors.VoidPatternInitializer, left);
      }
      node2.left = left;
      node2.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node2, "AssignmentPattern");
    }
    isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding2) {
      switch (type) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return true;
        case "CallExpression":
          if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) {
            return true;
          }
      }
      return false;
    }
    isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    }
    checkLVal(expression, ancestor, binding2 = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {
      var _expression$extra;
      const type = expression.type;
      if (this.isObjectMethod(expression)) return;
      const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type === "MemberExpression") {
        if (isOptionalMemberExpression) {
          this.expectPlugin("optionalChainingAssign", expression.loc.start);
          if (ancestor.type !== "AssignmentExpression") {
            this.raise(Errors.InvalidLhsOptionalChaining, expression, {
              ancestor
            });
          }
        }
        if (binding2 !== 64) {
          this.raise(Errors.InvalidPropertyBindingPattern, expression);
        }
        return;
      }
      if (type === "Identifier") {
        this.checkIdentifier(expression, binding2, strictModeChanged);
        const {
          name
        } = expression;
        if (checkClashes) {
          if (checkClashes.has(name)) {
            this.raise(Errors.ParamDupe, expression);
          } else {
            checkClashes.add(name);
          }
        }
        return;
      } else if (type === "VoidPattern" && ancestor.type === "CatchClause") {
        this.raise(Errors.VoidPatternCatchClauseParam, expression);
      }
      const unwrappedExpression = unwrapParenthesizedExpression(expression);
      disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === "CallExpression" && (unwrappedExpression.callee.type === "Import" || unwrappedExpression.callee.type === "Super"));
      const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding2);
      if (validity === true) return;
      if (validity === false) {
        const ParseErrorClass = binding2 === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, expression, {
          ancestor
        });
        return;
      }
      let key, isParenthesizedExpression;
      if (typeof validity === "string") {
        key = validity;
        isParenthesizedExpression = type === "ParenthesizedExpression";
      } else {
        [key, isParenthesizedExpression] = validity;
      }
      const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
        type
      } : ancestor;
      const val = expression[key];
      if (Array.isArray(val)) {
        for (const child of val) {
          if (child) {
            this.checkLVal(child, nextAncestor, binding2, checkClashes, strictModeChanged, isParenthesizedExpression, true);
          }
        }
      } else if (val) {
        this.checkLVal(val, nextAncestor, binding2, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);
      }
    }
    checkIdentifier(at3, bindingType, strictModeChanged = false) {
      if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at3.name, this.inModule) : isStrictBindOnlyReservedWord(at3.name))) {
        if (bindingType === 64) {
          this.raise(Errors.StrictEvalArguments, at3, {
            referenceName: at3.name
          });
        } else {
          this.raise(Errors.StrictEvalArgumentsBinding, at3, {
            bindingName: at3.name
          });
        }
      }
      if (bindingType & 8192 && at3.name === "let") {
        this.raise(Errors.LetInLexicalBinding, at3);
      }
      if (!(bindingType & 64)) {
        this.declareNameFromIdentifier(at3, bindingType);
      }
    }
    declareNameFromIdentifier(identifier2, binding2) {
      this.scope.declareName(identifier2.name, binding2, identifier2.loc.start);
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node2.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern) break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, node2);
      }
    }
    checkCommaAfterRest(close) {
      if (!this.match(12)) {
        return false;
      }
      this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
      return true;
    }
  }
  const keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;
  function nonNull(x2) {
    if (x2 == null) {
      throw new Error(`Unexpected ${x2} value.`);
    }
    return x2;
  }
  function assert2(x2) {
    if (!x2) {
      throw new Error("Assert fail");
    }
  }
  const TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({
      methodName
    }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName
    }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind
    }) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier
    }) => `Accessibility modifier already seen: '${modifier}'.`,
    DuplicateModifier: ({
      modifier
    }) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({
      token
    }) => `'${token}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers
    }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier
    }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: ({
      token
    }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
    InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
    InvalidModifierOnTypeMember: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier
    }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
    InvalidModifiersOrder: ({
      orderedModifiers
    }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier
    }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName
    }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
    UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`
  });
  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return void 0;
    }
  }
  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }
  function tsIsVarianceAnnotations(modifier) {
    return modifier === "in" || modifier === "out";
  }
  var typescript2 = (superClass) => class TypeScriptParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
      this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      });
      this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        return false;
      }
      return this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      if (this.match(106)) {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      return this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
        return void 0;
      }
      const modifier = this.state.value;
      if (allowedModifiers.includes(modifier)) {
        if (hasSeenStaticModifier && this.match(106)) {
          return void 0;
        }
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
          return void 0;
        }
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }
      }
      return void 0;
    }
    tsParseModifiers({
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember
    }, modified) {
      const enforceOrder = (loc, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(TSErrors.InvalidModifiersOrder, loc, {
            orderedModifiers: [before, after]
          });
        }
      };
      const incompatible = (loc, modifier, mod1, mod2) => {
        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
          this.raise(TSErrors.IncompatibleModifiers, loc, {
            modifiers: [mod1, mod2]
          });
        }
      };
      for (; ; ) {
        const {
          startLoc
        } = this.state;
        const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
        if (!modifier) break;
        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, modifier, "override");
            enforceOrder(startLoc, modifier, modifier, "static");
            enforceOrder(startLoc, modifier, modifier, "readonly");
            modified.accessibility = modifier;
          }
        } else if (tsIsVarianceAnnotations(modifier)) {
          if (modified[modifier]) {
            this.raise(TSErrors.DuplicateModifier, startLoc, {
              modifier
            });
          }
          modified[modifier] = true;
          enforceOrder(startLoc, modifier, "in", "out");
        } else {
          if (hasOwnProperty.call(modified, modifier)) {
            this.raise(TSErrors.DuplicateModifier, startLoc, {
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, "static", "readonly");
            enforceOrder(startLoc, modifier, "static", "override");
            enforceOrder(startLoc, modifier, "override", "readonly");
            enforceOrder(startLoc, modifier, "abstract", "override");
            incompatible(startLoc, modifier, "declare", "override");
            incompatible(startLoc, modifier, "static", "abstract");
          }
          modified[modifier] = true;
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(errorTemplate, startLoc, {
            modifier
          });
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(kind, parseElement) {
      const result = [];
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }
      return result;
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = [];
      let trailingCommaPos = -1;
      for (; ; ) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        trailingCommaPos = -1;
        const element = parseElement();
        if (element == null) {
          return void 0;
        }
        result.push(element);
        if (this.eat(12)) {
          trailingCommaPos = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        if (expectSuccess) {
          this.expect(12);
        }
        return void 0;
      }
      if (refTrailingCommaPos) {
        refTrailingCommaPos.value = trailingCommaPos;
      }
      return result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(0);
        } else {
          this.expect(47);
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
      if (bracket) {
        this.expect(3);
      } else {
        this.expect(48);
      }
      return result;
    }
    tsParseImportType() {
      const node2 = this.startNode();
      this.expect(83);
      this.expect(10);
      if (!this.match(134)) {
        this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
        {
          node2.argument = super.parseExprAtom();
        }
      } else {
        {
          node2.argument = this.parseStringLiteral(this.state.value);
        }
      }
      if (this.eat(12)) {
        node2.options = this.tsParseImportTypeOptions();
      } else {
        node2.options = null;
      }
      this.expect(11);
      if (this.eat(16)) {
        node2.qualifier = this.tsParseEntityName(1 | 2);
      }
      if (this.match(47)) {
        {
          node2.typeParameters = this.tsParseTypeArguments();
        }
      }
      return this.finishNode(node2, "TSImportType");
    }
    tsParseImportTypeOptions() {
      const node2 = this.startNode();
      this.expect(5);
      const withProperty = this.startNode();
      if (this.isContextual(76)) {
        withProperty.method = false;
        withProperty.key = this.parseIdentifier(true);
        withProperty.computed = false;
        withProperty.shorthand = false;
      } else {
        this.unexpected(null, 76);
      }
      this.expect(14);
      withProperty.value = this.tsParseImportTypeWithPropertyValue();
      node2.properties = [this.finishObjectProperty(withProperty)];
      this.eat(12);
      this.expect(8);
      return this.finishNode(node2, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      const node2 = this.startNode();
      const properties = [];
      this.expect(5);
      while (!this.match(8)) {
        const type = this.state.type;
        if (tokenIsIdentifier(type) || type === 134) {
          properties.push(super.parsePropertyDefinition(null));
        } else {
          this.unexpected();
        }
        this.eat(12);
      }
      node2.properties = properties;
      this.next();
      return this.finishNode(node2, "ObjectExpression");
    }
    tsParseEntityName(flags) {
      let entity;
      if (flags & 1 && this.match(78)) {
        if (flags & 2) {
          entity = this.parseIdentifier(true);
        } else {
          const node2 = this.startNode();
          this.next();
          entity = this.finishNode(node2, "ThisExpression");
        }
      } else {
        entity = this.parseIdentifier(!!(flags & 1));
      }
      while (this.eat(16)) {
        const node2 = this.startNodeAtNode(entity);
        node2.left = entity;
        node2.right = this.parseIdentifier(!!(flags & 1));
        entity = this.finishNode(node2, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node2 = this.startNode();
      node2.typeName = this.tsParseEntityName(1);
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        {
          node2.typeParameters = this.tsParseTypeArguments();
        }
      }
      return this.finishNode(node2, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node2 = this.startNodeAtNode(lhs);
      node2.parameterName = lhs;
      node2.typeAnnotation = this.tsParseTypeAnnotation(false);
      node2.asserts = false;
      return this.finishNode(node2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "TSThisType");
    }
    tsParseTypeQuery() {
      const node2 = this.startNode();
      this.expect(87);
      if (this.match(83)) {
        node2.exprName = this.tsParseImportType();
      } else {
        {
          node2.exprName = this.tsParseEntityName(1 | 2);
        }
      }
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        {
          node2.typeParameters = this.tsParseTypeArguments();
        }
      }
      return this.finishNode(node2, "TSTypeQuery");
    }
    tsParseTypeParameter(parseModifiers) {
      const node2 = this.startNode();
      parseModifiers(node2);
      node2.name = this.tsParseTypeParameterName();
      node2.constraint = this.tsEatThenParseType(81);
      node2.default = this.tsEatThenParseType(29);
      return this.finishNode(node2, "TSTypeParameter");
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47)) {
        return this.tsParseTypeParameters(parseModifiers);
      }
    }
    tsParseTypeParameters(parseModifiers) {
      const node2 = this.startNode();
      if (this.match(47) || this.match(143)) {
        this.next();
      } else {
        this.unexpected();
      }
      const refTrailingCommaPos = {
        value: -1
      };
      node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeParameters, node2);
      }
      if (refTrailingCommaPos.value !== -1) {
        this.addExtra(node2, "trailingComma", refTrailingCommaPos.value);
      }
      return this.finishNode(node2, "TSTypeParameterDeclaration");
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19;
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";
      signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      this.expect(10);
      signature[paramsKey] = this.tsParseBindingListForSignature();
      if (returnTokenRequired) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }
    tsParseBindingListForSignature() {
      const list = super.parseBindingList(11, 41, 2);
      for (const pattern of list) {
        const {
          type
        } = pattern;
        if (type === "AssignmentPattern" || type === "TSParameterProperty") {
          this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
            type
          });
        }
      }
      return list;
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator()) {
        this.expect(13);
      }
    }
    tsParseSignatureMember(kind, node2) {
      this.tsFillSignature(14, node2);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node2, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next();
      if (tokenIsIdentifier(this.state.type)) {
        this.next();
        return this.match(14);
      }
      return false;
    }
    tsTryParseIndexSignature(node2) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return;
      }
      this.expect(0);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(3);
      node2.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type) node2.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node2, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node2, readonly) {
      if (this.eat(17)) node2.optional = true;
      if (this.match(10) || this.match(47)) {
        if (readonly) {
          this.raise(TSErrors.ReadonlyForMethodSignature, node2);
        }
        const method = node2;
        if (method.kind && this.match(47)) {
          this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
        }
        this.tsFillSignature(14, method);
        this.tsParseTypeMemberSemicolon();
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        if (method.kind === "get") {
          if (method[paramsKey].length > 0) {
            this.raise(Errors.BadGetterArity, this.state.curPosition());
            if (this.isThisParam(method[paramsKey][0])) {
              this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
            }
          }
        } else if (method.kind === "set") {
          if (method[paramsKey].length !== 1) {
            this.raise(Errors.BadSetterArity, this.state.curPosition());
          } else {
            const firstParameter = method[paramsKey][0];
            if (this.isThisParam(firstParameter)) {
              this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
            }
            if (firstParameter.type === "Identifier" && firstParameter.optional) {
              this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
            }
            if (firstParameter.type === "RestElement") {
              this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
            }
          }
          if (method[returnTypeKey]) {
            this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
          }
        } else {
          method.kind = "method";
        }
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = node2;
        if (readonly) property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type) property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node2 = this.startNode();
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
      }
      if (this.match(77)) {
        const id = this.startNode();
        this.next();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2);
        } else {
          node2.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node2, false);
        }
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, node2);
      const idx = this.tsTryParseIndexSignature(node2);
      if (idx) {
        return idx;
      }
      super.parsePropertyName(node2);
      if (!node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier()) {
        node2.kind = node2.key.name;
        super.parsePropertyName(node2);
        if (!this.match(10) && !this.match(47)) {
          this.unexpected(null, 10);
        }
      }
      return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly);
    }
    tsParseTypeLiteral() {
      const node2 = this.startNode();
      node2.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node2, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(8);
      return members;
    }
    tsIsStartOfMappedType() {
      this.next();
      if (this.eat(53)) {
        return this.isContextual(122);
      }
      if (this.isContextual(122)) {
        this.next();
      }
      if (!this.match(0)) {
        return false;
      }
      this.next();
      if (!this.tsIsIdentifier()) {
        return false;
      }
      this.next();
      return this.match(58);
    }
    tsParseMappedType() {
      const node2 = this.startNode();
      this.expect(5);
      if (this.match(53)) {
        node2.readonly = this.state.value;
        this.next();
        this.expectContextual(122);
      } else if (this.eatContextual(122)) {
        node2.readonly = true;
      }
      this.expect(0);
      {
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsExpectThenParseType(58);
        node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      }
      node2.nameType = this.eatContextual(93) ? this.tsParseType() : null;
      this.expect(3);
      if (this.match(53)) {
        node2.optional = this.state.value;
        this.next();
        this.expect(17);
      } else if (this.eat(17)) {
        node2.optional = true;
      }
      node2.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(8);
      return this.finishNode(node2, "TSMappedType");
    }
    tsParseTupleType() {
      const node2 = this.startNode();
      node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      node2.elementTypes.forEach((elementNode) => {
        const {
          type
        } = elementNode;
        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
        }
        seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
      });
      return this.finishNode(node2, "TSTupleType");
    }
    tsParseTupleElementType() {
      const restStartLoc = this.state.startLoc;
      const rest = this.eat(21);
      const {
        startLoc
      } = this.state;
      let labeled;
      let label;
      let optional;
      let type;
      const isWord = tokenIsKeywordOrIdentifier(this.state.type);
      const chAfterWord = isWord ? this.lookaheadCharCode() : null;
      if (chAfterWord === 58) {
        labeled = true;
        optional = false;
        label = this.parseIdentifier(true);
        this.expect(14);
        type = this.tsParseType();
      } else if (chAfterWord === 63) {
        optional = true;
        const wordName = this.state.value;
        const typeOrLabel = this.tsParseNonArrayType();
        if (this.lookaheadCharCode() === 58) {
          labeled = true;
          label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
          this.expect(17);
          this.expect(14);
          type = this.tsParseType();
        } else {
          labeled = false;
          type = typeOrLabel;
          this.expect(17);
        }
      } else {
        type = this.tsParseType();
        optional = this.eat(17);
        labeled = this.eat(14);
      }
      if (labeled) {
        let labeledNode;
        if (label) {
          labeledNode = this.startNodeAt(startLoc);
          labeledNode.optional = optional;
          labeledNode.label = label;
          labeledNode.elementType = type;
          if (this.eat(17)) {
            labeledNode.optional = true;
            this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
          }
        } else {
          labeledNode = this.startNodeAt(startLoc);
          labeledNode.optional = optional;
          this.raise(TSErrors.InvalidTupleMemberLabel, type);
          labeledNode.label = type;
          labeledNode.elementType = this.tsParseType();
        }
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAt(startLoc);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(restStartLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }
      return type;
    }
    tsParseParenthesizedType() {
      const node2 = this.startNode();
      this.expect(10);
      node2.typeAnnotation = this.tsParseType();
      this.expect(11);
      return this.finishNode(node2, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node2 = this.startNode();
      if (type === "TSConstructorType") {
        node2.abstract = !!abstract;
        if (abstract) this.next();
        this.next();
      }
      this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2));
      return this.finishNode(node2, type);
    }
    tsParseLiteralTypeNode() {
      const node2 = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          node2.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(node2, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        const node2 = this.startNode();
        node2.literal = super.parseTemplate(false);
        return this.finishNode(node2, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      if (this.state.inType) return this.tsParseType();
      return super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const node2 = this.startNode();
            const nextToken = this.lookahead();
            if (nextToken.type !== 135 && nextToken.type !== 136) {
              this.unexpected();
            }
            node2.literal = this.parseMaybeUnary();
            return this.finishNode(node2, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, nodeType);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      const {
        startLoc
      } = this.state;
      let type = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
        if (this.match(3)) {
          const node2 = this.startNodeAt(startLoc);
          node2.elementType = type;
          this.expect(3);
          type = this.finishNode(node2, "TSArrayType");
        } else {
          const node2 = this.startNodeAt(startLoc);
          node2.objectType = type;
          node2.indexType = this.tsParseType();
          this.expect(3);
          type = this.finishNode(node2, "TSIndexedAccessType");
        }
      }
      return type;
    }
    tsParseTypeOperator() {
      const node2 = this.startNode();
      const operator = this.state.value;
      this.next();
      node2.operator = operator;
      node2.typeAnnotation = this.tsParseTypeOperatorOrHigher();
      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node2);
      }
      return this.finishNode(node2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node2) {
      switch (node2.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(TSErrors.UnexpectedReadonly, node2);
      }
    }
    tsParseInferType() {
      const node2 = this.startNode();
      this.expectContextual(115);
      const typeParameter = this.startNode();
      typeParameter.name = this.tsParseTypeParameterName();
      typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
      node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node2, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
          return constraint;
        }
      }
    }
    tsParseTypeOperatorOrHigher() {
      const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
      return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node2 = this.startNode();
      const hasLeadingOperator = this.eat(operator);
      const types3 = [];
      do {
        types3.push(parseConstituentType());
      } while (this.eat(operator));
      if (types3.length === 1 && !hasLeadingOperator) {
        return types3[0];
      }
      node2.types = types3;
      return this.finishNode(node2, kind);
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      if (this.match(47)) {
        return true;
      }
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78)) {
        this.next();
        return true;
      }
      if (this.match(5)) {
        const {
          errors
        } = this.state;
        const previousErrorCount = errors.length;
        try {
          this.parseObjectLike(8, true);
          return errors.length === previousErrorCount;
        } catch (_unused) {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors
        } = this.state;
        const previousErrorCount = errors.length;
        try {
          super.parseBindingList(3, 93, 1);
          return errors.length === previousErrorCount;
        } catch (_unused2) {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();
      if (this.match(11) || this.match(21)) {
        return true;
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
          return true;
        }
        if (this.match(11)) {
          this.next();
          if (this.match(19)) {
            return true;
          }
        }
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node2 = this.startNode();
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          if (thisTypePredicate.type === "TSThisType") {
            node2.parameterName = thisTypePredicate;
            node2.asserts = true;
            node2.typeAnnotation = null;
            thisTypePredicate = this.finishNode(node2, "TSTypePredicate");
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node2);
            thisTypePredicate.asserts = true;
          }
          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }
          node2.parameterName = this.parseIdentifier();
          node2.asserts = asserts;
          node2.typeAnnotation = null;
          t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const type = this.tsParseTypeAnnotation(false);
        node2.parameterName = typePredicateVariable;
        node2.typeAnnotation = type;
        node2.asserts = asserts;
        t.typeAnnotation = this.finishNode(node2, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeOrTypePredicateAnnotation(14);
      }
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeAnnotation();
      }
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109) {
        return false;
      }
      const containsEsc = this.state.containsEsc;
      this.next();
      if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
        return false;
      }
      if (containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
          reservedWord: "asserts"
        });
      }
      return true;
    }
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon) this.expect(14);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert2(this.state.inType);
      const type = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
        return type;
      }
      const node2 = this.startNodeAtNode(type);
      node2.checkType = type;
      node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
      this.expect(17);
      node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      this.expect(14);
      node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      return this.finishNode(node2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }
      if (this.match(77)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
      }
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
      }
      const node2 = this.startNode();
      node2.typeAnnotation = this.tsInType(() => {
        this.next();
        return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
      });
      this.expect(48);
      node2.expression = this.parseMaybeUnary();
      return this.finishNode(node2, "TSTypeAssertion");
    }
    tsParseHeritageClause(token) {
      const originalStartLoc = this.state.startLoc;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          const node2 = this.startNode();
          node2.expression = this.tsParseEntityName(1 | 2);
          if (this.match(47)) {
            node2.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node2, "TSExpressionWithTypeArguments");
        }
      });
      if (!delimitedList.length) {
        this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
          token
        });
      }
      return delimitedList;
    }
    tsParseInterfaceDeclaration(node2, properties = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129);
      if (properties.declare) node2.declare = true;
      if (tokenIsIdentifier(this.state.type)) {
        node2.id = this.parseIdentifier();
        this.checkIdentifier(node2.id, 130);
      } else {
        node2.id = null;
        this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
      }
      node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (this.eat(81)) {
        node2.extends = this.tsParseHeritageClause("extends");
      }
      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node2.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node2, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node2) {
      node2.id = this.parseIdentifier();
      this.checkIdentifier(node2.id, 2);
      node2.typeAnnotation = this.tsInType(() => {
        node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
        this.expect(29);
        if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {
          const node3 = this.startNode();
          this.next();
          return this.finishNode(node3, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      });
      this.semicolon();
      return this.finishNode(node2, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(cb) {
      if (this.curContext() !== types2.brace) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      } else {
        return cb();
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsEatThenParseType(token) {
      if (this.match(token)) {
        return this.tsNextThenParseType();
      }
    }
    tsExpectThenParseType(token) {
      return this.tsInType(() => {
        this.expect(token);
        return this.tsParseType();
      });
    }
    tsNextThenParseType() {
      return this.tsInType(() => {
        this.next();
        return this.tsParseType();
      });
    }
    tsParseEnumMember() {
      const node2 = this.startNode();
      node2.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
      if (this.eat(29)) {
        node2.initializer = super.parseMaybeAssignAllowIn();
      }
      return this.finishNode(node2, "TSEnumMember");
    }
    tsParseEnumDeclaration(node2, properties = {}) {
      if (properties.const) node2.const = true;
      if (properties.declare) node2.declare = true;
      this.expectContextual(126);
      node2.id = this.parseIdentifier();
      this.checkIdentifier(node2.id, node2.const ? 8971 : 8459);
      {
        this.expect(5);
        node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
      }
      return this.finishNode(node2, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      const node2 = this.startNode();
      this.expect(5);
      node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(8);
      return this.finishNode(node2, "TSEnumBody");
    }
    tsParseModuleBlock() {
      const node2 = this.startNode();
      this.scope.enter(0);
      this.expect(5);
      super.parseBlockOrModuleBlockBody(node2.body = [], void 0, true, 8);
      this.scope.exit();
      return this.finishNode(node2, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
      node2.id = this.parseIdentifier();
      if (!nested) {
        this.checkIdentifier(node2.id, 1024);
      }
      if (this.eat(16)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node2.body = inner;
      } else {
        this.scope.enter(1024);
        this.prodParam.enter(0);
        node2.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }
      return this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node2) {
      if (this.isContextual(112)) {
        node2.kind = "global";
        {
          node2.global = true;
        }
        node2.id = this.parseIdentifier();
      } else if (this.match(134)) {
        node2.kind = "module";
        node2.id = super.parseStringLiteral(this.state.value);
      } else {
        this.unexpected();
      }
      if (this.match(5)) {
        this.scope.enter(1024);
        this.prodParam.enter(0);
        node2.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, isExport) {
      {
        node2.isExport = isExport || false;
      }
      node2.id = maybeDefaultIdentifier || this.parseIdentifier();
      this.checkIdentifier(node2.id, 4096);
      this.expect(29);
      const moduleReference = this.tsParseModuleReference();
      if (node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
        this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
      }
      node2.moduleReference = moduleReference;
      this.semicolon();
      return this.finishNode(node2, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      const node2 = this.startNode();
      this.expectContextual(119);
      this.expect(10);
      if (!this.match(134)) {
        this.unexpected();
      }
      node2.expression = super.parseExprAtom();
      this.expect(11);
      this.sawUnambiguousESM = true;
      return this.finishNode(node2, "TSExternalModuleReference");
    }
    tsLookAhead(f2) {
      const state = this.state.clone();
      const res = f2();
      this.state = state;
      return res;
    }
    tsTryParseAndCatch(f2) {
      const result = this.tryParse((abort) => f2() || abort());
      if (result.aborted || !result.node) return;
      if (result.error) this.state = result.failState;
      return result.node;
    }
    tsTryParse(f2) {
      const state = this.state.clone();
      const result = f2();
      if (result !== void 0 && result !== false) {
        return result;
      }
      this.state = state;
    }
    tsTryParseDeclare(node2) {
      if (this.isLineTerminator()) {
        return;
      }
      const startType = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (startType) {
          case 68:
            node2.declare = true;
            return super.parseFunctionStatement(node2, false, false);
          case 80:
            node2.declare = true;
            return this.parseClass(node2, true, false);
          case 126:
            return this.tsParseEnumDeclaration(node2, {
              declare: true
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(node2);
          case 100:
            if (this.state.containsEsc) {
              return;
            }
          case 75:
          case 74:
            if (!this.match(75) || !this.isLookaheadContextual("enum")) {
              node2.declare = true;
              return this.parseVarStatement(node2, this.state.value, true);
            }
            this.expect(75);
            return this.tsParseEnumDeclaration(node2, {
              const: true,
              declare: true
            });
          case 107:
            if (this.isUsing()) {
              this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare");
              node2.declare = true;
              return this.parseVarStatement(node2, "using", true);
            }
            break;
          case 96:
            if (this.isAwaitUsing()) {
              this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare");
              node2.declare = true;
              this.next();
              return this.parseVarStatement(node2, "await using", true);
            }
            break;
          case 129: {
            const result = this.tsParseInterfaceDeclaration(node2, {
              declare: true
            });
            if (result) return result;
          }
          default:
            if (tokenIsIdentifier(startType)) {
              return this.tsParseDeclaration(node2, this.state.type, true, null);
            }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);
    }
    tsParseDeclaration(node2, type, next, decorators) {
      switch (type) {
        case 124:
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
            return this.tsParseAbstractDeclaration(node2, decorators);
          }
          break;
        case 127:
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(134)) {
              return this.tsParseAmbientExternalModuleDeclaration(node2);
            } else if (tokenIsIdentifier(this.state.type)) {
              node2.kind = "module";
              return this.tsParseModuleOrNamespaceDeclaration(node2);
            }
          }
          break;
        case 128:
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            node2.kind = "namespace";
            return this.tsParseModuleOrNamespaceDeclaration(node2);
          }
          break;
        case 130:
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseTypeAliasDeclaration(node2);
          }
          break;
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak()) return false;
        this.next();
        return true;
      }
      return !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startLoc) {
      if (!this.match(47)) return;
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const res = this.tsTryParseAndCatch(() => {
        const node2 = this.startNodeAt(startLoc);
        node2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        super.parseFunctionParams(node2);
        node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(19);
        return node2;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      if (!res) return;
      return super.parseArrowExpression(res, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47) return;
      return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const node2 = this.startNode();
      node2.params = this.tsInType(() => this.tsInTopLevelContext(() => {
        this.expect(47);
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeArguments, node2);
      } else if (!this.state.inType && this.curContext() === types2.brace) {
        this.reScan_lt_gt();
      }
      this.expect(48);
      return this.finishNode(node2, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type);
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart()) return false;
      return super.isExportDefaultSpecifier();
    }
    parseBindingElement(flags, decorators) {
      const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
      const modified = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, modified);
      const accessibility = modified.accessibility;
      const override = modified.override;
      const readonly = modified.readonly;
      if (!(flags & 4) && (accessibility || readonly || override)) {
        this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
      }
      const left = this.parseMaybeDefault();
      if (flags & 2) {
        this.parseFunctionParamType(left);
      }
      const elt = this.parseMaybeDefault(left.loc.start, left);
      if (accessibility || readonly || override) {
        const pp2 = this.startNodeAt(startLoc);
        if (decorators.length) {
          pp2.decorators = decorators;
        }
        if (accessibility) pp2.accessibility = accessibility;
        if (readonly) pp2.readonly = readonly;
        if (override) pp2.override = override;
        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(TSErrors.UnsupportedParameterPropertyKind, pp2);
        }
        pp2.parameter = elt;
        return this.finishNode(pp2, "TSParameterProperty");
      }
      if (decorators.length) {
        left.decorators = decorators;
      }
      return elt;
    }
    isSimpleParameter(node2) {
      return node2.type === "TSParameterProperty" && super.isSimpleParameter(node2.parameter) || super.isSimpleParameter(node2);
    }
    tsDisallowOptionalPattern(node2) {
      for (const param of node2.params) {
        if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
          this.raise(TSErrors.PatternIsOptional, param);
        }
      }
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      super.setArrowFunctionParameters(node2, params, trailingCommaLoc);
      this.tsDisallowOptionalPattern(node2);
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
      }
      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
        return this.finishNode(node2, bodilessType);
      }
      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
        this.raise(TSErrors.DeclareFunctionHasImplementation, node2);
        if (node2.declare) {
          return super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod);
        }
      }
      this.tsDisallowOptionalPattern(node2);
      return super.parseFunctionBodyAndFinish(node2, type, isMethod);
    }
    registerFunctionStatementId(node2) {
      if (!node2.body && node2.id) {
        this.checkIdentifier(node2.id, 1024);
      } else {
        super.registerFunctionStatementId(node2);
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node2) => {
        if ((node2 == null ? void 0 : node2.type) === "TSTypeCastExpression") {
          this.raise(TSErrors.UnexpectedTypeAnnotation, node2.typeAnnotation);
        }
      });
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList);
      return exprList;
    }
    parseArrayLike(close, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, isTuple, refExpressionErrors);
      if (node2.type === "ArrayExpression") {
        this.tsCheckForInvalidTypeCasts(node2.elements);
      }
      return node2;
    }
    parseSubscript(base2, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startLoc);
        nonNullExpression.expression = base2;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true;
          return base2;
        }
        state.optionalChainMember = isOptionalCall = true;
        this.next();
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base2)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
            if (asyncArrowFn) {
              state.stop = true;
              return asyncArrowFn;
            }
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (!typeArguments) return;
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition();
            return;
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = super.parseTaggedTemplateExpression(base2, startLoc, state);
            {
              result2.typeParameters = typeArguments;
            }
            return result2;
          }
          if (!noCalls && this.eat(10)) {
            const node3 = this.startNodeAt(startLoc);
            node3.callee = base2;
            node3.arguments = this.parseCallExpressionArguments();
            this.tsCheckForInvalidTypeCasts(node3.arguments);
            {
              node3.typeParameters = typeArguments;
            }
            if (state.optionalChainMember) {
              node3.optional = isOptionalCall;
            }
            return this.finishCallExpression(node3, state.optionalChainMember);
          }
          const tokenType = this.state.type;
          if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
            return;
          }
          const node2 = this.startNodeAt(startLoc);
          node2.expression = base2;
          {
            node2.typeParameters = typeArguments;
          }
          return this.finishNode(node2, "TSInstantiationExpression");
        });
        if (missingParenErrorLoc) {
          this.unexpected(missingParenErrorLoc, 10);
        }
        if (result) {
          if (result.type === "TSInstantiationExpression") {
            if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            if (!this.match(16) && !this.match(18)) {
              result.expression = super.stopParseSubscript(base2, state);
            }
          }
          return result;
        }
      }
      return super.parseSubscript(base2, startLoc, noCalls, state);
    }
    parseNewCallee(node2) {
      var _callee$extra;
      super.parseNewCallee(node2);
      const {
        callee
      } = node2;
      if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
        {
          node2.typeParameters = callee.typeParameters;
        }
        node2.callee = callee.expression;
      }
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      let isSatisfies;
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
        const node2 = this.startNodeAt(leftStartLoc);
        node2.expression = left;
        node2.typeAnnotation = this.tsInType(() => {
          this.next();
          if (this.match(75)) {
            if (isSatisfies) {
              this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                keyword: "const"
              });
            }
            return this.tsParseTypeReference();
          }
          return this.tsParseType();
        });
        this.finishNode(node2, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node2, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
      if (!this.state.isAmbientContext) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding2);
      }
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2);
      if (node2.module && node2.importKind !== "value") {
        this.raise(TSErrors.ImportReflectionHasImportType, node2.specifiers[0].loc.start);
      }
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return true;
      if (this.isContextual(130)) {
        const ch = this.lookaheadCharCode();
        return isExport ? ch === 123 || ch === 42 : ch !== 61;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      super.applyImportPhase(node2, isExport, phase, loc);
      if (isExport) {
        node2.exportKind = phase === "type" ? "type" : "value";
      } else {
        node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImport(node2) {
      if (this.match(134)) {
        node2.importKind = "value";
        return super.parseImport(node2);
      }
      let importNode;
      if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
        node2.importKind = "value";
        return this.tsParseImportEqualsDeclaration(node2);
      } else if (this.isContextual(130)) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, false);
        if (this.lookaheadCharCode() === 61) {
          return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier);
        } else {
          importNode = super.parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier);
        }
      } else {
        importNode = super.parseImport(node2);
      }
      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
      }
      return importNode;
    }
    parseExport(node2, decorators) {
      if (this.match(83)) {
        const nodeImportEquals = node2;
        this.next();
        let maybeDefaultIdentifier = null;
        if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
          maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
        } else {
          nodeImportEquals.importKind = "value";
        }
        const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
        {
          return declaration;
        }
      } else if (this.eat(29)) {
        const assign = node2;
        assign.expression = super.parseExpression();
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const decl = node2;
        this.expectContextual(128);
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        return super.parseExport(node2, decorators);
      }
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        cls.abstract = true;
        return this.parseClass(cls, true, true);
      }
      if (this.match(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result) return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      const {
        isAmbientContext
      } = this.state;
      const declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext);
      if (!isAmbientContext) return declaration;
      if (!node2.declare && (kind === "using" || kind === "await using")) {
        this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node2, kind);
        return declaration;
      }
      for (const {
        id,
        init
      } of declaration.declarations) {
        if (!init) continue;
        if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
        } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
          this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
        }
      }
      return declaration;
    }
    parseStatementContent(flags, decorators) {
      if (!this.state.containsEsc) {
        switch (this.state.type) {
          case 75: {
            if (this.isLookaheadContextual("enum")) {
              const node2 = this.startNode();
              this.expect(75);
              return this.tsParseEnumDeclaration(node2, {
                const: true
              });
            }
            break;
          }
          case 124:
          case 125: {
            if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
              const token = this.state.type;
              const node2 = this.startNode();
              this.next();
              const declaration = token === 125 ? this.tsTryParseDeclare(node2) : this.tsParseAbstractDeclaration(node2, decorators);
              if (declaration) {
                if (token === 125) {
                  declaration.declare = true;
                }
                return declaration;
              } else {
                node2.expression = this.createIdentifier(this.startNodeAt(node2.loc.start), token === 125 ? "declare" : "abstract");
                this.semicolon(false);
                return this.finishNode(node2, "ExpressionStatement");
              }
            }
            break;
          }
          case 126:
            return this.tsParseEnumDeclaration(this.startNode());
          case 112: {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 123) {
              const node2 = this.startNode();
              return this.tsParseAmbientExternalModuleDeclaration(node2);
            }
            break;
          }
          case 129: {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result) return result;
            break;
          }
          case 127: {
            if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
              const node2 = this.startNode();
              this.next();
              return this.tsParseDeclaration(node2, 127, false, decorators);
            }
            break;
          }
          case 128: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              const node2 = this.startNode();
              this.next();
              return this.tsParseDeclaration(node2, 128, false, decorators);
            }
            break;
          }
          case 130: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              const node2 = this.startNode();
              this.next();
              return this.tsParseTypeAliasDeclaration(node2);
            }
            break;
          }
        }
      }
      return super.parseStatementContent(flags, decorators);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier;
        }
        return !!member[modifier];
      });
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(classBody, member, state) {
      const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: modifiers,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }, member);
      const callParseClassMemberWithIsStatic = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          this.next();
          this.next();
          if (this.tsHasSomeModifiers(member, modifiers)) {
            this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
          }
          super.parseClassStaticBlock(classBody, member);
        } else {
          this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
        }
      };
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
      } else {
        callParseClassMemberWithIsStatic();
      }
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx);
        if (member.abstract) {
          this.raise(TSErrors.IndexSignatureHasAbstract, member);
        }
        if (member.accessibility) {
          this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
            modifier: member.accessibility
          });
        }
        if (member.declare) {
          this.raise(TSErrors.IndexSignatureHasDeclare, member);
        }
        if (member.override) {
          this.raise(TSErrors.IndexSignatureHasOverride, member);
        }
        return;
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(TSErrors.OverrideNotInSubClass, member);
        }
      }
      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(17);
      if (optional) methodOrProp.optional = true;
      if (methodOrProp.readonly && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
      }
      if (methodOrProp.declare && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
      }
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart()) return true;
      return super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors);
          return expr;
        }
      }
      return super.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseParenItem(node2, startLoc) {
      const newNode = super.parseParenItem(node2, startLoc);
      if (this.eat(17)) {
        newNode.optional = true;
        this.resetEndLocation(node2);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = node2;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node2;
    }
    parseExportDeclaration(node2) {
      if (!this.state.isAmbientContext && this.isContextual(125)) {
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node2));
      }
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual(125);
      if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      }
      const isIdentifier = tokenIsIdentifier(this.state.type);
      const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node2);
      if (!declaration) return null;
      if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
        node2.exportKind = "type";
      }
      if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
        this.resetStartLocation(declaration, startLoc);
        declaration.declare = true;
      }
      return declaration;
    }
    parseClassId(node2, isStatement, optionalId, bindingType) {
      if ((!isStatement || optionalId) && this.isContextual(113)) {
        return;
      }
      super.parseClassId(node2, isStatement, optionalId, node2.declare ? 1024 : 8331);
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (typeParameters) node2.typeParameters = typeParameters;
    }
    parseClassPropertyAnnotation(node2) {
      if (!node2.optional) {
        if (this.eat(35)) {
          node2.definite = true;
        } else if (this.eat(17)) {
          node2.optional = true;
        }
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) node2.typeAnnotation = type;
    }
    parseClassProperty(node2) {
      this.parseClassPropertyAnnotation(node2);
      if (this.state.isAmbientContext && !(node2.readonly && !node2.typeAnnotation) && this.match(29)) {
        this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
      }
      if (node2.abstract && this.match(29)) {
        const {
          key
        } = node2;
        this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: key.type === "Identifier" && !node2.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
        });
      }
      return super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      if (node2.abstract) {
        this.raise(TSErrors.PrivateElementHasAbstract, node2);
      }
      if (node2.accessibility) {
        this.raise(TSErrors.PrivateElementHasAccessibility, node2, {
          modifier: node2.accessibility
        });
      }
      this.parseClassPropertyAnnotation(node2);
      return super.parseClassPrivateProperty(node2);
    }
    parseClassAccessorProperty(node2) {
      this.parseClassPropertyAnnotation(node2);
      if (node2.optional) {
        this.raise(TSErrors.AccessorCannotBeOptional, node2);
      }
      return super.parseClassAccessorProperty(node2);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters && isConstructor) {
        this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
      }
      const {
        declare = false,
        kind
      } = method;
      if (declare && (kind === "get" || kind === "set")) {
        this.raise(TSErrors.DeclareAccessor, method, {
          kind
        });
      }
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      if (node2.type === "TSDeclareMethod") return;
      if (node2.type === "MethodDefinition" && node2.value.body == null) {
        return;
      }
      super.declareClassPrivateMethodInScope(node2, kind);
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2);
      if (node2.superClass && (this.match(47) || this.match(51))) {
        {
          node2.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
      }
      if (this.eatContextual(113)) {
        node2.implements = this.tsParseHeritageClause("implements");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters) prop.typeParameters = typeParameters;
      return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    }
    parseFunctionParams(node2, isConstructor) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters) node2.typeParameters = typeParameters;
      super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
        decl.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeAnnotation();
      }
      return super.parseAsyncArrowFromCallExpression(node2, call);
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
      let state;
      let jsx3;
      let typeCast;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        state = this.state.clone();
        jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx3.error) return jsx3.node;
        const {
          context: context2
        } = this.state;
        const currentContext = context2[context2.length - 1];
        if (currentContext === types2.j_oTag || currentContext === types2.j_expr) {
          context2.pop();
        }
      }
      if (!((_jsx = jsx3) != null && _jsx.error) && !this.match(47)) {
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      if (!state || state === this.state) state = this.state.clone();
      let typeParameters;
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          abort();
        }
        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }
        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted) {
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if (!jsx3) {
        assert2(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!typeCast.error) return typeCast.node;
      }
      if ((_jsx2 = jsx3) != null && _jsx2.node) {
        this.state = jsx3.failState;
        return jsx3.node;
      }
      if (arrow.node) {
        this.state = arrow.failState;
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }
      throw ((_jsx3 = jsx3) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
    }
    reportReservedArrowTypeParam(node2) {
      var _node$extra2;
      if (node2.params.length === 1 && !node2.params[0].constraint && !((_node$extra2 = node2.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedArrowTypeParam, node2);
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      if (!this.hasPlugin("jsx") && this.match(47)) {
        return this.tsParseTypeAssertion();
      }
      return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          if (this.canInsertSemicolon() || !this.match(19)) abort();
          return returnType;
        });
        if (result.aborted) return;
        if (!result.thrown) {
          if (result.error) this.state = result.failState;
          node2.returnType = result.node;
        }
      }
      return super.parseArrow(node2);
    }
    parseFunctionParamType(param) {
      if (this.eat(17)) {
        param.optional = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }
    isAssignable(node2, isBinding2) {
      switch (node2.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node2.expression, isBinding2);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(node2, isBinding2);
      }
    }
    toAssignable(node2, isLHS = false) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(node2, isLHS);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          if (isLHS) {
            this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node2);
          } else {
            this.raise(TSErrors.UnexpectedTypeCastInParameter, node2);
          }
          this.toAssignable(node2.expression, isLHS);
          break;
        case "AssignmentExpression":
          if (!isLHS && node2.left.type === "TSTypeCastExpression") {
            node2.left = this.typeCastToParameter(node2.left);
          }
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node2, isLHS) {
      switch (node2.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isLHS);
          break;
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(node2.expression, false);
          break;
        default:
          super.checkToRestConversion(node2, allowPattern);
      }
    }
    isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding2) {
      switch (type) {
        case "TSTypeCastExpression":
          return true;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (binding2 !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
        default:
          return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding2);
      }
    }
    parseBindingAtom() {
      if (this.state.type === 78) {
        return this.parseIdentifier(true);
      }
      return super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(expr, startLoc) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const call = super.parseMaybeDecoratorArguments(expr, startLoc);
          {
            call.typeParameters = typeArguments;
          }
          return call;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(expr, startLoc);
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
        this.next();
        return false;
      }
      return super.checkCommaAfterRest(close);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(startLoc, left) {
      const node2 = super.parseMaybeDefault(startLoc, left);
      if (node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start) {
        this.raise(TSErrors.TypeAnnotationAfterAssign, node2.typeAnnotation);
      }
      return node2;
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (code2 === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(code2);
    }
    reScan_lt_gt() {
      const {
        type
      } = this.state;
      if (type === 47) {
        this.state.pos -= 1;
        this.readToken_lt();
      } else if (type === 48) {
        this.state.pos -= 1;
        this.readToken_gt();
      }
    }
    reScan_lt() {
      const {
        type
      } = this.state;
      if (type === 51) {
        this.state.pos -= 2;
        this.finishOp(47, 1);
        return 47;
      }
      return type;
    }
    toAssignableListItem(exprList, index, isLHS) {
      const node2 = exprList[index];
      if (node2.type === "TSTypeCastExpression") {
        exprList[index] = this.typeCastToParameter(node2);
      }
      super.toAssignableListItem(exprList, index, isLHS);
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation;
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end);
      return node2.expression;
    }
    shouldParseArrow(params) {
      if (this.match(14)) {
        return params.every((expr) => this.isAssignable(expr, true));
      }
      return super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        if (typeArguments) {
          {
            node2.typeParameters = typeArguments;
          }
        }
      }
      return super.jsxParseOpeningElementAfterName(node2);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const firstParam = params[0];
      const hasContextParam = firstParam && this.isThisParam(firstParam);
      return hasContextParam ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }
      return param;
    }
    tsInAmbientContext(cb) {
      const {
        isAmbientContext: oldIsAmbientContext,
        strict: oldStrict
      } = this.state;
      this.state.isAmbientContext = true;
      this.state.strict = false;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
        this.state.strict = oldStrict;
      }
    }
    parseClass(node2, isStatement, optionalId) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node2.abstract;
      try {
        return super.parseClass(node2, isStatement, optionalId);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node2, decorators) {
      if (this.match(80)) {
        node2.abstract = true;
        return this.maybeTakeDecorators(decorators, this.parseClass(node2, true, false));
      } else if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) {
          node2.abstract = true;
          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node2);
          return this.tsParseInterfaceDeclaration(node2);
        } else {
          return null;
        }
      }
      throw this.unexpected(null, 80);
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      const method = super.parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      if (method.abstract || method.type === "TSAbstractMethodDefinition") {
        const hasEstreePlugin = this.hasPlugin("estree");
        const methodFn = hasEstreePlugin ? method.value : method;
        if (methodFn.body) {
          const {
            key
          } = method;
          this.raise(TSErrors.AbstractMethodHasImplementation, method, {
            methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
      }
      return method;
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier();
      return typeName.name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.parse();
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.getExpression();
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      if (!isString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport);
        return this.finishNode(node2, "ExportSpecifier");
      }
      node2.exportKind = "value";
      return super.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly);
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (!importedIsString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
        return this.finishNode(specifier, "ImportSpecifier");
      }
      specifier.importKind = "value";
      return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    }
    parseTypeOnlyImportExportSpecifier(node2, isImport, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport ? "imported" : "local";
      const rightOfAsKey = isImport ? "local" : "exported";
      let leftOfAs = node2[leftOfAsKey];
      let rightOfAs;
      let hasTypeSpecifier = false;
      let canParseAsKeyword = true;
      const loc = leftOfAs.loc.start;
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier();
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier();
          if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            canParseAsKeyword = false;
          } else {
            rightOfAs = secondAs;
            canParseAsKeyword = false;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          canParseAsKeyword = false;
          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        } else {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        hasTypeSpecifier = true;
        if (isImport) {
          leftOfAs = this.parseIdentifier(true);
          if (!this.isContextual(93)) {
            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
          }
        } else {
          leftOfAs = this.parseModuleExportName();
        }
      }
      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
        this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
      }
      node2[leftOfAsKey] = leftOfAs;
      node2[rightOfAsKey] = rightOfAs;
      const kindKey = isImport ? "importKind" : "exportKind";
      node2[kindKey] = hasTypeSpecifier ? "type" : "value";
      if (canParseAsKeyword && this.eatContextual(93)) {
        node2[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
      }
      if (!node2[rightOfAsKey]) {
        node2[rightOfAsKey] = this.cloneIdentifier(node2[leftOfAsKey]);
      }
      if (isImport) {
        this.checkIdentifier(node2[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
      }
    }
    fillOptionalPropertiesForTSESLint(node2) {
      var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
      switch (node2.type) {
        case "ExpressionStatement":
          (_node$directive = node2.directive) != null ? _node$directive : node2.directive = void 0;
          return;
        case "RestElement":
          node2.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          (_node$decorators = node2.decorators) != null ? _node$decorators : node2.decorators = [];
          (_node$optional = node2.optional) != null ? _node$optional : node2.optional = false;
          (_node$typeAnnotation = node2.typeAnnotation) != null ? _node$typeAnnotation : node2.typeAnnotation = void 0;
          return;
        case "TSParameterProperty":
          (_node$accessibility = node2.accessibility) != null ? _node$accessibility : node2.accessibility = void 0;
          (_node$decorators2 = node2.decorators) != null ? _node$decorators2 : node2.decorators = [];
          (_node$override = node2.override) != null ? _node$override : node2.override = false;
          (_node$readonly = node2.readonly) != null ? _node$readonly : node2.readonly = false;
          (_node$static = node2.static) != null ? _node$static : node2.static = false;
          return;
        case "TSEmptyBodyFunctionExpression":
          node2.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          (_node$declare = node2.declare) != null ? _node$declare : node2.declare = false;
          (_node$returnType = node2.returnType) != null ? _node$returnType : node2.returnType = void 0;
          (_node$typeParameters = node2.typeParameters) != null ? _node$typeParameters : node2.typeParameters = void 0;
          return;
        case "Property":
          (_node$optional2 = node2.optional) != null ? _node$optional2 : node2.optional = false;
          return;
        case "TSMethodSignature":
        case "TSPropertySignature":
          (_node$optional3 = node2.optional) != null ? _node$optional3 : node2.optional = false;
        case "TSIndexSignature":
          (_node$accessibility2 = node2.accessibility) != null ? _node$accessibility2 : node2.accessibility = void 0;
          (_node$readonly2 = node2.readonly) != null ? _node$readonly2 : node2.readonly = false;
          (_node$static2 = node2.static) != null ? _node$static2 : node2.static = false;
          return;
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          (_node$declare2 = node2.declare) != null ? _node$declare2 : node2.declare = false;
          (_node$definite = node2.definite) != null ? _node$definite : node2.definite = false;
          (_node$readonly3 = node2.readonly) != null ? _node$readonly3 : node2.readonly = false;
          (_node$typeAnnotation2 = node2.typeAnnotation) != null ? _node$typeAnnotation2 : node2.typeAnnotation = void 0;
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          (_node$accessibility3 = node2.accessibility) != null ? _node$accessibility3 : node2.accessibility = void 0;
          (_node$decorators3 = node2.decorators) != null ? _node$decorators3 : node2.decorators = [];
          (_node$override2 = node2.override) != null ? _node$override2 : node2.override = false;
          (_node$optional4 = node2.optional) != null ? _node$optional4 : node2.optional = false;
          return;
        case "ClassExpression":
          (_node$id = node2.id) != null ? _node$id : node2.id = null;
        case "ClassDeclaration":
          (_node$abstract = node2.abstract) != null ? _node$abstract : node2.abstract = false;
          (_node$declare3 = node2.declare) != null ? _node$declare3 : node2.declare = false;
          (_node$decorators4 = node2.decorators) != null ? _node$decorators4 : node2.decorators = [];
          (_node$implements = node2.implements) != null ? _node$implements : node2.implements = [];
          (_node$superTypeArgume = node2.superTypeArguments) != null ? _node$superTypeArgume : node2.superTypeArguments = void 0;
          (_node$typeParameters2 = node2.typeParameters) != null ? _node$typeParameters2 : node2.typeParameters = void 0;
          return;
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          (_node$declare4 = node2.declare) != null ? _node$declare4 : node2.declare = false;
          return;
        case "VariableDeclarator":
          (_node$definite2 = node2.definite) != null ? _node$definite2 : node2.definite = false;
          return;
        case "TSEnumDeclaration":
          (_node$const = node2.const) != null ? _node$const : node2.const = false;
          (_node$declare5 = node2.declare) != null ? _node$declare5 : node2.declare = false;
          return;
        case "TSEnumMember":
          (_node$computed = node2.computed) != null ? _node$computed : node2.computed = false;
          return;
        case "TSImportType":
          (_node$qualifier = node2.qualifier) != null ? _node$qualifier : node2.qualifier = null;
          (_node$options = node2.options) != null ? _node$options : node2.options = null;
          return;
        case "TSInterfaceDeclaration":
          (_node$declare6 = node2.declare) != null ? _node$declare6 : node2.declare = false;
          (_node$extends = node2.extends) != null ? _node$extends : node2.extends = [];
          return;
        case "TSMappedType":
          (_node$optional5 = node2.optional) != null ? _node$optional5 : node2.optional = false;
          (_node$readonly4 = node2.readonly) != null ? _node$readonly4 : node2.readonly = void 0;
          return;
        case "TSModuleDeclaration":
          (_node$declare7 = node2.declare) != null ? _node$declare7 : node2.declare = false;
          (_node$global = node2.global) != null ? _node$global : node2.global = node2.kind === "global";
          return;
        case "TSTypeParameter":
          (_node$const2 = node2.const) != null ? _node$const2 : node2.const = false;
          (_node$in = node2.in) != null ? _node$in : node2.in = false;
          (_node$out = node2.out) != null ? _node$out : node2.out = false;
          return;
      }
    }
    chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {
      if (isIdentifierStart(ch)) {
        keywordAndTSRelationalOperator.lastIndex = pos;
        if (keywordAndTSRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      } else if (ch === 92) {
        return true;
      } else {
        return false;
      }
    }
    nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);
    }
    nextTokenIsIdentifierOrStringLiteralOnSameLine() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;
    }
  };
  function isPossiblyLiteralEnum(expression) {
    if (expression.type !== "MemberExpression") return false;
    const {
      computed,
      property
    } = expression;
    if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  }
  function isValidAmbientConstInitializer(expression, estree2) {
    var _expression$extra;
    const {
      type
    } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
      return false;
    }
    if (estree2) {
      if (type === "Literal") {
        const {
          value
        } = expression;
        if (typeof value === "string" || typeof value === "boolean") {
          return true;
        }
      }
    } else {
      if (type === "StringLiteral" || type === "BooleanLiteral") {
        return true;
      }
    }
    if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
      return true;
    }
    if (type === "TemplateLiteral" && expression.expressions.length === 0) {
      return true;
    }
    if (isPossiblyLiteralEnum(expression)) {
      return true;
    }
    return false;
  }
  function isNumber(expression, estree2) {
    if (estree2) {
      return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
    }
    return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  }
  function isNegativeNumber(expression, estree2) {
    if (expression.type === "UnaryExpression") {
      const {
        operator,
        argument
      } = expression;
      if (operator === "-" && isNumber(argument, estree2)) {
        return true;
      }
    }
    return false;
  }
  function isUncomputedMemberExpressionChain(expression) {
    if (expression.type === "Identifier") return true;
    if (expression.type !== "MemberExpression" || expression.computed) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  }
  const PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders2 = (superClass) => class PlaceholdersParserMixin extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(133)) {
        const node2 = this.startNode();
        this.next();
        this.assertNoSpace();
        node2.name = super.parseIdentifier(true);
        this.assertNoSpace();
        this.expect(133);
        return this.finishPlaceholder(node2, expectedNode);
      }
    }
    finishPlaceholder(node2, expectedNode) {
      let placeholder = node2;
      if (!placeholder.expectedNode || !placeholder.type) {
        placeholder = this.finishNode(placeholder, "Placeholder");
      }
      placeholder.expectedNode = expectedNode;
      return placeholder;
    }
    getTokenFromCode(code2) {
      if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        this.finishOp(133, 2);
      } else {
        super.getTokenFromCode(code2);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    }
    parseIdentifier(liberal) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
      if (word !== void 0) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding2);
      }
    }
    cloneIdentifier(node2) {
      const cloned = super.cloneIdentifier(node2);
      if (cloned.type === "Placeholder") {
        cloned.expectedNode = node2.expectedNode;
      }
      return cloned;
    }
    cloneStringLiteral(node2) {
      if (node2.type === "Placeholder") {
        return this.cloneIdentifier(node2);
      }
      return super.cloneStringLiteral(node2);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(type, disallowCallExpression, isParenthesized, binding2) {
      return type === "Placeholder" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding2);
    }
    toAssignable(node2, isLHS) {
      if (node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression") {
        node2.expectedNode = "Pattern";
      } else {
        super.toAssignable(node2, isLHS);
      }
    }
    chStartsBindingIdentifier(ch, pos) {
      if (super.chStartsBindingIdentifier(ch, pos)) {
        return true;
      }
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
        return true;
      }
      return false;
    }
    verifyBreakContinue(node2, isBreak) {
      if (node2.label && node2.label.type === "Placeholder") return;
      super.verifyBreakContinue(node2, isBreak);
    }
    parseExpressionStatement(node2, expr) {
      var _expr$extra;
      if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
        return super.parseExpressionStatement(node2, expr);
      }
      if (this.match(14)) {
        const stmt = node2;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
        return this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      const stmtPlaceholder = node2;
      stmtPlaceholder.name = expr.name;
      return this.finishPlaceholder(stmtPlaceholder, "Statement");
    }
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    parseFunctionId(requireId) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    }
    parseClass(node2, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");
      if (placeholder) {
        if (this.match(81) || this.match(133) || this.match(5)) {
          node2.id = placeholder;
        } else if (optionalId || !isStatement) {
          node2.id = null;
          node2.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node2, type);
        } else {
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
        }
      } else {
        this.parseClassId(node2, isStatement, optionalId);
      }
      super.parseClassSuper(node2);
      node2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node2.superClass, oldStrict);
      return this.finishNode(node2, type);
    }
    parseExport(node2, decorators) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseExport(node2, decorators);
      const node22 = node2;
      if (!this.isContextual(98) && !this.match(12)) {
        node22.specifiers = [];
        node22.source = null;
        node22.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node22, "ExportNamedDeclaration");
      }
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node22.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node22, decorators);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      var _specifiers;
      if ((_specifiers = node2.specifiers) != null && _specifiers.length) {
        return true;
      }
      return super.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
    }
    checkExport(node2) {
      const {
        specifiers
      } = node2;
      if (specifiers != null && specifiers.length) {
        node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder");
      }
      super.checkExport(node2);
      node2.specifiers = specifiers;
    }
    parseImport(node2) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseImport(node2);
      node2.specifiers = [];
      if (!this.isContextual(98) && !this.match(12)) {
        node2.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      }
      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      node2.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
      if (this.eat(12)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node2);
        if (!hasStarImport) this.parseNamedImportSpecifiers(node2);
      }
      this.expectContextual(98);
      node2.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
        this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
      }
    }
  };
  var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc;
        const node2 = this.startNode();
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName();
          const identifier2 = this.createIdentifier(node2, name);
          this.castNodeTo(identifier2, "V8IntrinsicIdentifier");
          if (this.match(10)) {
            return identifier2;
          }
        }
        this.unexpected(v8IntrinsicStartLoc);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
  };
  const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
  const TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
  function validatePlugins(pluginsMap) {
    if (pluginsMap.has("decorators")) {
      if (pluginsMap.has("decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }
      const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      }
      const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
      if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
        throw new Error("'allowCallParenthesized' must be a boolean.");
      }
    }
    if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }
    if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }
    if (pluginsMap.has("pipelineOperator")) {
      var _pluginsMap$get2;
      const proposal = pluginsMap.get("pipelineOperator").proposal;
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      if (proposal === "hack") {
        if (pluginsMap.has("placeholders")) {
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        }
        if (pluginsMap.has("v8intrinsic")) {
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        }
        const topicToken = pluginsMap.get("pipelineOperator").topicToken;
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        {
          var _pluginsMap$get;
          if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        }
      } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
      }
    }
    if (pluginsMap.has("moduleAttributes")) {
      {
        if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
          throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
        }
        const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
        if (moduleAttributesVersionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
      }
    }
    if (pluginsMap.has("importAssertions")) {
      if (pluginsMap.has("deprecatedImportAssert")) {
        throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
      }
    }
    if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
      {
        pluginsMap.set("deprecatedImportAssert", {});
      }
    }
    if (pluginsMap.has("recordAndTuple")) {
      {
        const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
          if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
            throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
          }
        }
      }
    }
    if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
      const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
    if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }
    if (pluginsMap.has("discardBinding") && pluginsMap.get("discardBinding").syntaxType !== "void") {
      throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
    }
  }
  const mixinPlugins = {
    estree,
    jsx: jsx2,
    flow: flow2,
    typescript: typescript2,
    v8intrinsic,
    placeholders: placeholders2
  };
  const mixinPluginNames = Object.keys(mixinPlugins);
  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, sawProto, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return sawProto;
      }
      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;
      if (name === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, key);
          return true;
        }
        if (sawProto) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProtoLoc === null) {
              refExpressionErrors.doubleProtoLoc = key.loc.start;
            }
          } else {
            this.raise(Errors.DuplicateProto, key);
          }
        }
        return true;
      }
      return sawProto;
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      if (this.match(140)) {
        throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
      }
      const expr = this.parseExpression();
      if (!this.match(140)) {
        throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
          unexpected: this.input.codePointAt(this.state.start)
        });
      }
      this.finalizeRemainingComments();
      expr.comments = this.comments;
      expr.errors = this.state.errors;
      if (this.optionFlags & 256) {
        expr.tokens = this.tokens;
      }
      return expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        const node2 = this.startNodeAt(startLoc);
        node2.expressions = [expr];
        while (this.eat(12)) {
          node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }
        this.toReferencedList(node2.expressions);
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors) {
      refExpressionErrors.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startLoc = this.state.startLoc;
      const isYield = this.isContextual(108);
      if (isYield) {
        if (this.prodParam.hasYield) {
          this.next();
          let left2 = this.parseYield(startLoc);
          if (afterLeftParse) {
            left2 = afterLeftParse.call(this, left2, startLoc);
          }
          return left2;
        }
      }
      let ownExpressionErrors;
      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }
      const {
        type
      } = this.state;
      if (type === 10 || tokenIsIdentifier(type)) {
        this.state.potentialArrowAt = this.state.start;
      }
      let left = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startLoc);
      }
      if (tokenIsAssignment(this.state.type)) {
        const node2 = this.startNodeAt(startLoc);
        const operator = this.state.value;
        node2.operator = operator;
        if (this.match(29)) {
          this.toAssignable(left, true);
          node2.left = left;
          const startIndex = startLoc.index;
          if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
            refExpressionErrors.doubleProtoLoc = null;
          }
          if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
            refExpressionErrors.shorthandAssignLoc = null;
          }
          if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
            this.checkDestructuringPrivate(refExpressionErrors);
            refExpressionErrors.privateKeyLoc = null;
          }
          if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {
            refExpressionErrors.voidPatternLoc = null;
          }
        } else {
          node2.left = left;
        }
        this.next();
        node2.right = this.parseMaybeAssign();
        this.checkLVal(left, this.finishNode(node2, "AssignmentExpression"), void 0, void 0, void 0, void 0, operator === "||=" || operator === "&&=" || operator === "??=");
        return node2;
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (isYield) {
        const {
          type: type2
        } = this.state;
        const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
        if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
          this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
          return this.parseYield(startLoc);
        }
      }
      return left;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        const node2 = this.startNodeAt(startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssignAllowIn();
        this.expect(14);
        node2.alternate = this.parseMaybeAssign();
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      if (this.isPrivateName(left)) {
        const value = this.getPrivateNameSV(left);
        if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
          this.raise(Errors.PrivateInExpectedIn, left, {
            identifierName: value
          });
        }
        this.classScope.usePrivateName(value, left.loc.start);
      }
      const op2 = this.state.type;
      if (tokenIsOperator(op2) && (this.prodParam.hasIn || !this.match(58))) {
        let prec = tokenOperatorPrecedence(op2);
        if (prec > minPrec) {
          if (op2 === 39) {
            this.expectPlugin("pipelineOperator");
            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }
            this.checkPipelineAtInfixOperator(left, leftStartLoc);
          }
          const node2 = this.startNodeAt(leftStartLoc);
          node2.left = left;
          node2.operator = this.state.value;
          const logical = op2 === 41 || op2 === 42;
          const coalesce = op2 === 40;
          if (coalesce) {
            prec = tokenOperatorPrecedence(42);
          }
          this.next();
          if (op2 === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait) {
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
            }
          }
          node2.right = this.parseExprOpRightExpr(op2, prec);
          const finishedNode = this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
            throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
          }
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left;
    }
    parseExprOpRightExpr(op2, prec) {
      const startLoc = this.state.startLoc;
      switch (op2) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                return this.parseHackPipeBody();
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108)) {
                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
              }
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op2, prec), startLoc);
            });
          }
        default:
          return this.parseExprOpBaseRightExpr(op2, prec);
      }
    }
    parseExprOpBaseRightExpr(op2, prec) {
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op2) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
      var _body$extra;
      const {
        startLoc
      } = this.state;
      const body = this.parseMaybeAssign();
      const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
      if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
        this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
          type: body.type
        });
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipeTopicUnused, startLoc);
      }
      return body;
    }
    checkExponentialAfterUnary(node2) {
      if (this.match(57)) {
        this.raise(Errors.UnexpectedTokenUnaryExponentiation, node2.argument);
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual(96);
      if (isAwait && this.recordAwaitIfAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startLoc);
        if (!sawUnary) this.checkExponentialAfterUnary(expr2);
        return expr2;
      }
      const update = this.match(34);
      const node2 = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node2.operator = this.state.value;
        node2.prefix = true;
        if (this.match(72)) {
          this.expectPlugin("throwExpressions");
        }
        const isDelete = this.match(89);
        this.next();
        node2.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (this.state.strict && isDelete) {
          const arg = node2.argument;
          if (arg.type === "Identifier") {
            this.raise(Errors.StrictDelete, node2);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(Errors.DeletePrivateField, node2);
          }
        }
        if (!update) {
          if (!sawUnary) {
            this.checkExponentialAfterUnary(node2);
          }
          return this.finishNode(node2, "UnaryExpression");
        }
      }
      const expr = this.parseUpdate(node2, update, refExpressionErrors);
      if (isAwait) {
        const {
          type
        } = this.state;
        const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
        if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
          this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
          return this.parseAwait(startLoc);
        }
      }
      return expr;
    }
    parseUpdate(node2, update, refExpressionErrors) {
      if (update) {
        const updateExpressionNode = node2;
        this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
        return node2;
      }
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
      while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
        const node3 = this.startNodeAt(startLoc);
        node3.operator = this.state.value;
        node3.prefix = false;
        node3.argument = expr;
        this.next();
        this.checkLVal(expr, expr = this.finishNode(node3, "UpdateExpression"));
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base2, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
        stop: false
      };
      do {
        base2 = this.parseSubscript(base2, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);
      return base2;
    }
    parseSubscript(base2, startLoc, noCalls, state) {
      const {
        type
      } = this.state;
      if (!noCalls && type === 15) {
        return this.parseBind(base2, startLoc, noCalls, state);
      } else if (tokenIsTemplate(type)) {
        return this.parseTaggedTemplateExpression(base2, startLoc, state);
      }
      let optional = false;
      if (type === 18) {
        if (noCalls) {
          this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
          if (this.lookaheadCharCode() === 40) {
            return this.stopParseSubscript(base2, state);
          }
        }
        state.optionalChainMember = optional = true;
        this.next();
      }
      if (!noCalls && this.match(10)) {
        return this.parseCoverCallAndAsyncArrowHead(base2, startLoc, state, optional);
      } else {
        const computed = this.eat(0);
        if (computed || optional || this.eat(16)) {
          return this.parseMember(base2, startLoc, state, computed, optional);
        } else {
          return this.stopParseSubscript(base2, state);
        }
      }
    }
    stopParseSubscript(base2, state) {
      state.stop = true;
      return base2;
    }
    parseMember(base2, startLoc, state, computed, optional) {
      const node2 = this.startNodeAt(startLoc);
      node2.object = base2;
      node2.computed = computed;
      if (computed) {
        node2.property = this.parseExpression();
        this.expect(3);
      } else if (this.match(139)) {
        if (base2.type === "Super") {
          this.raise(Errors.SuperPrivateField, startLoc);
        }
        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
        node2.property = this.parsePrivateName();
      } else {
        node2.property = this.parseIdentifier(true);
      }
      if (state.optionalChainMember) {
        node2.optional = optional;
        return this.finishNode(node2, "OptionalMemberExpression");
      } else {
        return this.finishNode(node2, "MemberExpression");
      }
    }
    parseBind(base2, startLoc, noCalls, state) {
      const node2 = this.startNodeAt(startLoc);
      node2.object = base2;
      this.next();
      node2.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node2, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base2, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      const node2 = this.startNodeAt(startLoc);
      node2.callee = base2;
      const {
        maybeAsyncArrow,
        optionalChainMember
      } = state;
      if (maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }
      if (optionalChainMember) {
        node2.optional = optional;
      }
      if (optional) {
        node2.arguments = this.parseCallExpressionArguments();
      } else {
        node2.arguments = this.parseCallExpressionArguments(base2.type !== "Super", node2, refExpressionErrors);
      }
      let finishedNode = this.finishCallExpression(node2, optionalChainMember);
      if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
      } else {
        if (maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }
        this.toReferencedArguments(finishedNode);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return finishedNode;
    }
    toReferencedArguments(node2, isParenthesizedExpr) {
      this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base2, startLoc, state) {
      const node2 = this.startNodeAt(startLoc);
      node2.tag = base2;
      node2.quasi = this.parseTemplate(true);
      if (state.optionalChainMember) {
        this.raise(Errors.OptionalChainingNoTemplate, startLoc);
      }
      return this.finishNode(node2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base2) {
      return base2.type === "Identifier" && base2.name === "async" && this.state.lastTokEndLoc.index === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.offsetToSourcePos(base2.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(node2, optional) {
      if (node2.callee.type === "Import") {
        if (node2.arguments.length === 0 || node2.arguments.length > 2) {
          this.raise(Errors.ImportCallArity, node2);
        } else {
          for (const arg of node2.arguments) {
            if (arg.type === "SpreadElement") {
              this.raise(Errors.ImportCallSpreadArgument, arg);
            }
          }
        }
      }
      return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      while (!this.eat(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(11)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));
      }
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node2, call) {
      var _call$extra;
      this.resetPreviousNodeTrailingComments(call);
      this.expect(19);
      this.parseArrowExpression(node2, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
      if (call.innerComments) {
        setInnerComments(node2, call.innerComments);
      }
      if (call.callee.trailingComments) {
        setInnerComments(node2, call.callee.trailingComments);
      }
      return node2;
    }
    parseNoCallExpr() {
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    parseExprAtom(refExpressionErrors) {
      let node2;
      let decorators = null;
      const {
        type
      } = this.state;
      switch (type) {
        case 79:
          return this.parseSuper();
        case 83:
          node2 = this.startNode();
          this.next();
          if (this.match(16)) {
            return this.parseImportMetaPropertyOrPhaseCall(node2);
          }
          if (this.match(10)) {
            if (this.optionFlags & 512) {
              return this.parseImportCall(node2);
            } else {
              return this.finishNode(node2, "Import");
            }
          } else {
            this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
            return this.finishNode(node2, "Import");
          }
        case 78:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case 90: {
          return this.parseDo(this.startNode(), false);
        }
        case 56:
        case 31: {
          this.readRegexp();
          return this.parseRegExpLiteral(this.state.value);
        }
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case 0: {
          return this.parseArrayLike(3, false, refExpressionErrors);
        }
        case 5: {
          return this.parseObjectLike(8, false, false, refExpressionErrors);
        }
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          node2 = this.startNode();
          this.next();
          node2.object = null;
          const callee = node2.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression") {
            return this.finishNode(node2, "BindExpression");
          } else {
            throw this.raise(Errors.UnsupportedBind, callee);
          }
        }
        case 139: {
          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          });
          return this.parsePrivateName();
        }
        case 33: {
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        }
        case 32: {
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        }
        case 37:
        case 38: {
          return this.parseTopicReference("hack");
        }
        case 44:
        case 54:
        case 27: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            return this.parseTopicReference(pipeProposal);
          }
          throw this.unexpected();
        }
        case 47: {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
            throw this.expectOnePlugin(["jsx", "flow", "typescript"]);
          }
          throw this.unexpected();
        }
        default:
          {
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            } else if (type === 2 || type === 1) {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, true);
            } else if (type === 6 || type === 7) {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
          }
          if (tokenIsIdentifier(type)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
              return this.parseModuleExpression();
            }
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: type2
              } = this.state;
              if (type2 === 68) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              } else if (tokenIsIdentifier(type2)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (type2 === 90) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }
            if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }
            return id;
          } else {
            throw this.unexpected();
          }
      }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal) {
        this.state.type = topicTokenType;
        this.state.value = topicTokenValue;
        this.state.pos--;
        this.state.end--;
        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
        return this.parseTopicReference(pipeProposal);
      }
      throw this.unexpected();
    }
    parseTopicReference(pipeProposal) {
      const node2 = this.startNode();
      const startLoc = this.state.startLoc;
      const tokenType = this.state.type;
      this.next();
      return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        if (pipeProposal === "hack") {
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnbound, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node2, "TopicReference");
        } else {
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node2, "PipelinePrimaryTopicReference");
        }
      } else {
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
      }
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack": {
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        }
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
      }
    }
    parseAsyncArrowUnaryFunction(node2) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
      }
      this.expect(19);
      return this.parseArrowExpression(node2, params, true);
    }
    parseDo(node2, isAsync) {
      this.expectPlugin("doExpressions");
      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }
      node2.async = isAsync;
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      if (isAsync) {
        this.prodParam.enter(2);
        node2.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node2.body = this.parseBlock();
      }
      this.state.labels = oldLabels;
      return this.finishNode(node2, "DoExpression");
    }
    parseSuper() {
      const node2 = this.startNode();
      this.next();
      if (this.match(10) && !this.scope.allowDirectSuper) {
        {
          if (!(this.optionFlags & 16)) {
            this.raise(Errors.SuperNotAllowed, node2);
          }
        }
      } else if (!this.scope.allowSuper) {
        {
          if (!(this.optionFlags & 16)) {
            this.raise(Errors.UnexpectedSuper, node2);
          }
        }
      }
      if (!this.match(10) && !this.match(0) && !this.match(16)) {
        this.raise(Errors.UnsupportedSuper, node2);
      }
      return this.finishNode(node2, "Super");
    }
    parsePrivateName() {
      const node2 = this.startNode();
      const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
      const name = this.state.value;
      this.next();
      node2.id = this.createIdentifier(id, name);
      return this.finishNode(node2, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node2 = this.startNode();
      this.next();
      if (this.prodParam.hasYield && this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
        this.next();
        if (this.match(103)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
        return this.parseMetaProperty(node2, meta, "sent");
      }
      return this.parseFunction(node2);
    }
    parseMetaProperty(node2, meta, propertyName) {
      node2.meta = meta;
      const containsEsc = this.state.containsEsc;
      node2.property = this.parseIdentifier(true);
      if (node2.property.name !== propertyName || containsEsc) {
        this.raise(Errors.UnsupportedMetaProperty, node2.property, {
          target: meta.name,
          onlyValidPropertyName: propertyName
        });
      }
      return this.finishNode(node2, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(node2) {
      this.next();
      if (this.isContextual(105) || this.isContextual(97)) {
        const isSource = this.isContextual(105);
        this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
        this.next();
        node2.phase = isSource ? "source" : "defer";
        return this.parseImportCall(node2);
      } else {
        const id = this.createIdentifierAt(this.startNodeAtNode(node2), "import", this.state.lastTokStartLoc);
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node2, id, "meta");
      }
    }
    parseLiteralAtNode(value, type, node2) {
      this.addExtra(node2, "rawValue", value);
      this.addExtra(node2, "raw", this.input.slice(this.offsetToSourcePos(node2.start), this.state.end));
      node2.value = value;
      this.next();
      return this.finishNode(node2, type);
    }
    parseLiteral(value, type) {
      const node2 = this.startNode();
      return this.parseLiteralAtNode(value, type, node2);
    }
    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
      {
        return this.parseLiteral(value, "BigIntLiteral");
      }
    }
    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
      const node2 = this.startNode();
      this.addExtra(node2, "raw", this.input.slice(this.offsetToSourcePos(node2.start), this.state.end));
      node2.pattern = value.pattern;
      node2.flags = value.flags;
      this.next();
      return this.finishNode(node2, "RegExpLiteral");
    }
    parseBooleanLiteral(value) {
      const node2 = this.startNode();
      node2.value = value;
      this.next();
      return this.finishNode(node2, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors();
      let first = true;
      let spreadStartLoc;
      let optionalCommaStartLoc;
      while (!this.match(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
          if (this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
        }
        if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStartLoc = this.state.startLoc;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
          if (!this.checkCommaAfterRest(41)) {
            break;
          }
        } else {
          exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));
        }
      }
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startLoc);
      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }
      this.expressionScope.exit();
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStartLoc);
      }
      if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
      if (spreadStartLoc) this.unexpected(spreadStartLoc);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        this.resetEndLocation(val, innerEndLoc);
      } else {
        val = exprList[0];
      }
      return this.wrapParenthesis(startLoc, val);
    }
    wrapParenthesis(startLoc, expression) {
      if (!(this.optionFlags & 1024)) {
        this.addExtra(expression, "parenthesized", true);
        this.addExtra(expression, "parenStart", startLoc.index);
        this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
        return expression;
      }
      const parenExpression = this.startNodeAt(startLoc);
      parenExpression.expression = expression;
      return this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node2) {
      if (this.eat(19)) {
        return node2;
      }
    }
    parseParenItem(node2, startLoc) {
      return node2;
    }
    parseNewOrNewTarget() {
      const node2 = this.startNode();
      this.next();
      if (this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node2, meta, "target");
        if (!this.scope.allowNewTarget) {
          this.raise(Errors.UnexpectedNewTarget, metaProp);
        }
        return metaProp;
      }
      return this.parseNew(node2);
    }
    parseNew(node2) {
      this.parseNewCallee(node2);
      if (this.eat(10)) {
        const args = this.parseExprList(11);
        this.toReferencedList(args);
        node2.arguments = args;
      } else {
        node2.arguments = [];
      }
      return this.finishNode(node2, "NewExpression");
    }
    parseNewCallee(node2) {
      const isImport = this.match(83);
      const callee = this.parseNoCallExpr();
      node2.callee = callee;
      if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
        this.raise(Errors.ImportCallNotNewExpression, callee);
      }
    }
    parseTemplateElement(isTagged) {
      const {
        start,
        startLoc,
        end,
        value
      } = this.state;
      const elemStart = start + 1;
      const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      if (value === null) {
        if (!isTagged) {
          this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
        }
      }
      const isTail = this.match(24);
      const endOffset = isTail ? -1 : -2;
      const elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
        cooked: value === null ? null : value.slice(1, endOffset)
      };
      elem.tail = isTail;
      this.next();
      const finishedNode = this.finishNode(elem, "TemplateElement");
      this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
      return finishedNode;
    }
    parseTemplate(isTagged) {
      const node2 = this.startNode();
      let curElt = this.parseTemplateElement(isTagged);
      const quasis = [curElt];
      const substitutions = [];
      while (!curElt.tail) {
        substitutions.push(this.parseTemplateSubstitution());
        this.readTemplateContinuation();
        quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      node2.expressions = substitutions;
      node2.quasis = quasis;
      return this.finishNode(node2, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      let sawProto = false;
      let first = true;
      const node2 = this.startNode();
      node2.properties = [];
      this.next();
      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            this.addTrailingCommaExtraToNode(node2);
            break;
          }
        }
        let prop;
        if (isPattern) {
          prop = this.parseBindingProperty();
        } else {
          prop = this.parsePropertyDefinition(refExpressionErrors);
          sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
        }
        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(Errors.InvalidRecordProperty, prop);
        }
        {
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
        }
        node2.properties.push(prop);
      }
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";
      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }
      return this.finishNode(node2, type);
    }
    addTrailingCommaExtraToNode(node2) {
      this.addExtra(node2, "trailingComma", this.state.lastTokStartLoc.index);
      this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
      let decorators = [];
      if (this.match(26)) {
        if (this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
      }
      const prop = this.startNode();
      let isAsync = false;
      let isAccessor = false;
      let startLoc;
      if (this.match(21)) {
        if (decorators.length) this.unexpected();
        return this.parseSpread();
      }
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      prop.method = false;
      if (refExpressionErrors) {
        startLoc = this.state.startLoc;
      }
      let isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      const containsEsc = this.state.containsEsc;
      this.parsePropertyName(prop, refExpressionErrors);
      if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const {
          key
        } = prop;
        const keyName = key.name;
        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(55);
          this.parsePropertyName(prop);
        }
        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;
          if (this.match(55)) {
            isGenerator = true;
            this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
              kind: keyName
            });
            this.next();
          }
          this.parsePropertyName(prop);
        }
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length !== paramCount) {
        this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
      }
      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(Errors.BadSetterRestParameter, method);
      }
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(finishedProp);
        return finishedProp;
      }
      if (isAsync || isGenerator || this.match(10)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;
      if (this.eat(14)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);
        return this.finishObjectProperty(prop);
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
        } else if (this.match(29)) {
          const shorthandAssignLoc = this.state.startLoc;
          if (refExpressionErrors != null) {
            if (refExpressionErrors.shorthandAssignLoc === null) {
              refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
            }
          } else {
            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
          }
          prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
        } else {
          prop.value = this.cloneIdentifier(prop.key);
        }
        prop.shorthand = true;
        return this.finishObjectProperty(prop);
      }
    }
    finishObjectProperty(node2) {
      return this.finishNode(node2, "ObjectProperty");
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node2 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (!node2) this.unexpected();
      return node2;
    }
    parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(3);
      } else {
        const {
          type,
          value
        } = this.state;
        let key;
        if (tokenIsKeywordOrIdentifier(type)) {
          key = this.parseIdentifier(true);
        } else {
          switch (type) {
            case 135:
              key = this.parseNumericLiteral(value);
              break;
            case 134:
              key = this.parseStringLiteral(value);
              break;
            case 136:
              key = this.parseBigIntLiteral(value);
              break;
            case 139: {
              const privateKeyLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.privateKeyLoc === null) {
                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
                }
              } else {
                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
              }
              key = this.parsePrivateName();
              break;
            }
            default:
              if (type === 137) {
                key = this.parseDecimalLiteral(value);
                break;
              }
              this.unexpected();
          }
        }
        prop.key = key;
        if (type !== 139) {
          prop.computed = false;
        }
      }
    }
    initFunction(node2, isAsync) {
      node2.id = null;
      node2.generator = false;
      node2.async = isAsync;
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      this.initFunction(node2, isAsync);
      node2.generator = isGenerator;
      this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));
      this.prodParam.enter(functionFlags(isAsync, node2.generator));
      this.parseFunctionParams(node2, isConstructor);
      const finishedNode = this.parseFunctionBodyAndFinish(node2, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return finishedNode;
    }
    parseArrayLike(close, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
      this.scope.enter(514 | 4);
      let flags = functionFlags(isAsync, false);
      if (!this.match(5) && this.prodParam.hasIn) {
        flags |= 8;
      }
      this.prodParam.enter(flags);
      this.initFunction(node2, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node2, params, trailingCommaLoc);
      }
      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node2, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node2, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, false);
      node2.params = params;
    }
    parseFunctionBodyAndFinish(node2, type, isMethod = false) {
      this.parseFunctionBody(node2, false, isMethod);
      return this.finishNode(node2, type);
    }
    parseFunctionBody(node2, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(5);
      this.expressionScope.enter(newExpressionScope());
      if (isExpression) {
        node2.body = this.parseMaybeAssign();
        this.checkParams(node2, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | 4);
        node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node2.params);
          if (hasStrictModeDirective && nonSimple) {
            this.raise(Errors.IllegalLanguageModeDirective, (node2.kind === "method" || node2.kind === "constructor") && !!node2.key ? node2.key.loc.end : node2);
          }
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
          if (this.state.strict && node2.id) {
            this.checkIdentifier(node2.id, 65, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(node2) {
      return node2.type === "Identifier";
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) {
        if (!this.isSimpleParameter(params[i])) return false;
      }
      return true;
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
      const formalParameters = {
        type: "FormalParameters"
      };
      for (const param of node2.params) {
        this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
      }
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(12)) {
        if (!allowEmpty) {
          this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
            unexpected: ","
          });
        }
        elt = null;
      } else if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication");
        if (!allowPlaceholder) {
          this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
        }
        const node2 = this.startNode();
        this.next();
        elt = this.finishNode(node2, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
      }
      return elt;
    }
    parseIdentifier(liberal) {
      const node2 = this.startNode();
      const name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node2, name);
    }
    createIdentifier(node2, name) {
      node2.name = name;
      node2.loc.identifierName = name;
      return this.finishNode(node2, "Identifier");
    }
    createIdentifierAt(node2, name, endLoc) {
      node2.name = name;
      node2.loc.identifierName = name;
      return this.finishNodeAt(node2, "Identifier", endLoc);
    }
    parseIdentifierName(liberal) {
      let name;
      const {
        startLoc,
        type
      } = this.state;
      if (tokenIsKeywordOrIdentifier(type)) {
        name = this.state.value;
      } else {
        this.unexpected();
      }
      const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
      if (liberal) {
        if (tokenIsKeyword2) {
          this.replaceToken(132);
        }
      } else {
        this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
      }
      this.next();
      return name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
      if (word.length > 10) {
        return;
      }
      if (!canBeReservedWord(word)) {
        return;
      }
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, startLoc, {
          keyword: word
        });
        return;
      }
      const reservedTest = !this.state.strict ? isReservedWord : isBinding2 ? isStrictBindReservedWord : isStrictReservedWord;
      if (reservedTest(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, startLoc, {
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, startLoc);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, startLoc);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(startLoc);
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, startLoc);
          return;
        }
      }
    }
    recordAwaitIfAllowed() {
      const isAwaitAllowed = this.prodParam.hasAwait;
      if (isAwaitAllowed && !this.scope.inFunction) {
        this.state.hasTopLevelAwait = true;
      }
      return isAwaitAllowed;
    }
    parseAwait(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node2);
      if (this.eat(55)) {
        this.raise(Errors.ObsoleteAwaitStar, node2);
      }
      if (!this.scope.inFunction && !(this.optionFlags & 1)) {
        if (this.isAmbiguousPrefixOrIdentifier()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }
      if (!this.state.soloAwait) {
        node2.argument = this.parseMaybeUnary(null, true);
      }
      return this.finishNode(node2, "AwaitExpression");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return true;
      const {
        type
      } = this.state;
      return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    }
    parseYield(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node2);
      let delegating = false;
      let argument = null;
      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(55);
        switch (this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating) break;
          default:
            argument = this.parseMaybeAssign();
        }
      }
      node2.delegate = delegating;
      node2.argument = argument;
      return this.finishNode(node2, "YieldExpression");
    }
    parseImportCall(node2) {
      this.next();
      node2.source = this.parseMaybeAssignAllowIn();
      node2.options = null;
      if (this.eat(12)) {
        if (!this.match(11)) {
          node2.options = this.parseMaybeAssignAllowIn();
          if (this.eat(12)) {
            this.addTrailingCommaExtraToNode(node2.options);
            if (!this.match(11)) {
              do {
                this.parseMaybeAssignAllowIn();
              } while (this.eat(12) && !this.match(11));
              this.raise(Errors.ImportCallArity, node2);
            }
          }
        } else {
          this.addTrailingCommaExtraToNode(node2.source);
        }
      }
      this.expect(11);
      return this.finishNode(node2, "ImportExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartLoc) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (left.type === "SequenceExpression") {
          this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
        }
      }
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        const bodyNode = this.startNodeAt(startLoc);
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        const bodyNode = this.startNodeAt(startLoc);
        this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
        bodyNode.expression = childExpr;
        return this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19)) {
        throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipelineTopicUnused, startLoc);
      }
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = 8 & ~flags;
      if (prodParamToSet) {
        this.prodParam.enter(flags | 8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = 8 & flags;
      if (prodParamToClear) {
        this.prodParam.enter(flags & -9);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node2 = this.startNode();
      this.next();
      if (!this.match(5)) {
        this.unexpected(null, 5);
      }
      const program = this.startNodeAt(this.state.endLoc);
      this.next();
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        node2.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node2, "ModuleExpression");
    }
    parseVoidPattern(refExpressionErrors) {
      this.expectPlugin("discardBinding");
      const node2 = this.startNode();
      if (refExpressionErrors != null) {
        refExpressionErrors.voidPatternLoc = this.state.startLoc;
      }
      this.next();
      return this.finishNode(node2, "VoidPattern");
    }
    parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
      if (refExpressionErrors != null && this.match(88)) {
        const nextCode = this.lookaheadCharCode();
        if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {
          return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
        }
      }
      return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
    }
    parsePropertyNamePrefixOperator(prop) {
    }
  }
  const loopLabel = {
    kind: 1
  }, switchLabel = {
    kind: 2
  };
  const loneSurrogate = /[\uD800-\uDFFF]/u;
  const keywordRelationalOperator = /in(?:stanceof)?/y;
  function babel7CompatTokens(tokens, input, startIndex) {
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      const {
        type
      } = token;
      if (typeof type === "number") {
        {
          if (type === 139) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
            i++;
            continue;
          }
          if (tokenIsTemplate(type)) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const backquoteEnd = start + 1;
            const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            if (input.charCodeAt(start - startIndex) === 96) {
              startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            } else {
              startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            }
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            if (type === 24) {
              templateElementEnd = end - 1;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
              templateValue = value === null ? null : value.slice(1, -1);
              endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            } else {
              templateElementEnd = end - 2;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
              templateValue = value === null ? null : value.slice(1, -2);
              endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            }
            tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken);
            i += 2;
            continue;
          }
        }
        token.type = getExportedToken(type);
      }
    }
    return tokens;
  }
  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program, 140, this.options.sourceType === "module" ? "module" : "script");
      file.comments = this.comments;
      if (this.optionFlags & 256) {
        file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
      }
      return this.finishNode(file, "File");
    }
    parseProgram(program, end, sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);
      if (this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
          for (const [localName, at3] of Array.from(this.scope.undefinedExports)) {
            this.raise(Errors.ModuleExportUndefined, at3, {
              localName
            });
          }
        }
        this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let finishedProgram;
      if (end === 140) {
        finishedProgram = this.finishNode(program, "Program");
      } else {
        finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
      }
      return finishedProgram;
    }
    stmtToDirective(stmt) {
      const directive = this.castNodeTo(stmt, "Directive");
      const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
      const expressionValue = directiveLiteral.value;
      const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      this.addExtra(directiveLiteral, "expressionValue", expressionValue);
      directive.value = directiveLiteral;
      delete stmt.expression;
      return directive;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) {
        return null;
      }
      const node2 = this.startNode();
      node2.value = this.state.value;
      this.next();
      return this.finishNode(node2, "InterpreterDirective");
    }
    isLet() {
      if (!this.isContextual(100)) {
        return false;
      }
      return this.hasFollowingBindingAtom();
    }
    isUsing() {
      if (!this.isContextual(107)) {
        return false;
      }
      return this.nextTokenIsIdentifierOnSameLine();
    }
    isForUsing() {
      if (!this.isContextual(107)) {
        return false;
      }
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      if (this.isUnparsedContextual(next, "of")) {
        const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
        if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
          return false;
        }
      }
      if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, "void")) {
        return true;
      }
      return false;
    }
    nextTokenIsIdentifierOnSameLine() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next);
    }
    isAwaitUsing() {
      if (!this.isContextual(96)) {
        return false;
      }
      let next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        const nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next)) {
          return true;
        }
      }
      return false;
    }
    chStartsBindingIdentifier(ch, pos) {
      if (isIdentifierStart(ch)) {
        keywordRelationalOperator.lastIndex = pos;
        if (keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      } else if (ch === 92) {
        return true;
      } else {
        return false;
      }
    }
    chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
      const next = this.nextTokenStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    parseStatementListItem() {
      return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
      let flags = 0;
      if (this.options.annexB && !this.state.strict) {
        flags |= 4;
        if (allowLabeledFunction) {
          flags |= 8;
        }
      }
      return this.parseStatementLike(flags);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
      let decorators = null;
      if (this.match(26)) {
        decorators = this.parseDecorators(true);
      }
      return this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
      const startType = this.state.type;
      const node2 = this.startNode();
      const allowDeclaration = !!(flags & 2);
      const allowFunctionDeclaration = !!(flags & 4);
      const topLevel = flags & 1;
      switch (startType) {
        case 60:
          return this.parseBreakContinueStatement(node2, true);
        case 63:
          return this.parseBreakContinueStatement(node2, false);
        case 64:
          return this.parseDebuggerStatement(node2);
        case 90:
          return this.parseDoWhileStatement(node2);
        case 91:
          return this.parseForStatement(node2);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          if (!allowFunctionDeclaration) {
            this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
          }
          return this.parseFunctionStatement(node2, false, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          if (!allowDeclaration) this.unexpected();
          return this.parseClass(this.maybeTakeDecorators(decorators, node2), true);
        case 69:
          return this.parseIfStatement(node2);
        case 70:
          return this.parseReturnStatement(node2);
        case 71:
          return this.parseSwitchStatement(node2);
        case 72:
          return this.parseThrowStatement(node2);
        case 73:
          return this.parseTryStatement(node2);
        case 96:
          if (this.isAwaitUsing()) {
            if (!this.allowsUsing()) {
              this.raise(Errors.UnexpectedUsingDeclaration, node2);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, node2);
            } else if (!this.recordAwaitIfAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, node2);
            }
            this.next();
            return this.parseVarStatement(node2, "await using");
          }
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
            break;
          }
          if (!this.allowsUsing()) {
            this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
          } else if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          }
          return this.parseVarStatement(node2, "using");
        case 100: {
          if (this.state.containsEsc) {
            break;
          }
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh !== 91) {
            if (!allowDeclaration && this.hasFollowingLineBreak()) break;
            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
              break;
            }
          }
        }
        case 75: {
          if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          }
        }
        case 74: {
          const kind = this.state.value;
          return this.parseVarStatement(node2, kind);
        }
        case 92:
          return this.parseWhileStatement(node2);
        case 76:
          return this.parseWithStatement(node2);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node2);
        case 83: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }
        case 82: {
          if (!(this.optionFlags & 8) && !topLevel) {
            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
          }
          this.next();
          let result;
          if (startType === 83) {
            result = this.parseImport(node2);
          } else {
            result = this.parseExport(node2, decorators);
          }
          this.assertModuleNodeAllowed(result);
          return result;
        }
        default: {
          if (this.isAsyncFunction()) {
            if (!allowDeclaration) {
              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !allowDeclaration && allowFunctionDeclaration);
          }
        }
      }
      const maybeName = this.state.value;
      const expr = this.parseExpression();
      if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
        return this.parseLabeledStatement(node2, maybeName, expr, flags);
      } else {
        return this.parseExpressionStatement(node2, expr, decorators);
      }
    }
    assertModuleNodeAllowed(node2) {
      if (!(this.optionFlags & 8) && !this.inModule) {
        this.raise(Errors.ImportOutsideModule, node2);
      }
    }
    decoratorsEnabledBeforeExport() {
      if (this.hasPlugin("decorators-legacy")) return true;
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      if (maybeDecorators) {
        var _classNode$decorators;
        if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
          if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
            this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
          }
          classNode.decorators.unshift(...maybeDecorators);
        } else {
          classNode.decorators = maybeDecorators;
        }
        this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
        if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
      }
      return classNode;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(allowExport) {
      const decorators = [];
      do {
        decorators.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) {
        if (!allowExport) {
          this.unexpected();
        }
        if (!this.decoratorsEnabledBeforeExport()) {
          this.raise(Errors.DecoratorExportClass, this.state.startLoc);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
      }
      return decorators;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const node2 = this.startNode();
      this.next();
      if (this.hasPlugin("decorators")) {
        const startLoc = this.state.startLoc;
        let expr;
        if (this.match(10)) {
          const startLoc2 = this.state.startLoc;
          this.next();
          expr = this.parseExpression();
          this.expect(11);
          expr = this.wrapParenthesis(startLoc2, expr);
          const paramsStartLoc = this.state.startLoc;
          node2.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
          if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node2.expression !== expr) {
            this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
          }
        } else {
          expr = this.parseIdentifier(false);
          while (this.eat(16)) {
            const node3 = this.startNodeAt(startLoc);
            node3.object = expr;
            if (this.match(139)) {
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              node3.property = this.parsePrivateName();
            } else {
              node3.property = this.parseIdentifier(true);
            }
            node3.computed = false;
            expr = this.finishNode(node3, "MemberExpression");
          }
          node2.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
        }
      } else {
        node2.expression = this.parseExprSubscripts();
      }
      return this.finishNode(node2, "Decorator");
    }
    parseMaybeDecoratorArguments(expr, startLoc) {
      if (this.eat(10)) {
        const node2 = this.startNodeAt(startLoc);
        node2.callee = expr;
        node2.arguments = this.parseCallExpressionArguments();
        this.toReferencedList(node2.arguments);
        return this.finishNode(node2, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node2, isBreak) {
      this.next();
      if (this.isLineTerminator()) {
        node2.label = null;
      } else {
        node2.label = this.parseIdentifier();
        this.semicolon();
      }
      this.verifyBreakContinue(node2, isBreak);
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node2, isBreak) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === 1)) {
            break;
          }
          if (node2.label && isBreak) break;
        }
      }
      if (i === this.state.labels.length) {
        const type = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, node2, {
          type
        });
      }
    }
    parseDebuggerStatement(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const val = this.parseExpression();
      this.expect(11);
      return val;
    }
    parseDoWhileStatement(node2) {
      this.next();
      this.state.labels.push(loopLabel);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      this.expect(92);
      node2.test = this.parseHeaderExpression();
      this.eat(13);
      return this.finishNode(node2, "DoWhileStatement");
    }
    parseForStatement(node2) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
        awaitAt = this.state.startLoc;
        this.next();
      }
      this.scope.enter(0);
      this.expect(10);
      if (this.match(13)) {
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      const startsWithLet = this.isContextual(100);
      {
        const startsWithAwaitUsing = this.isAwaitUsing();
        const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
        const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          let kind;
          if (startsWithAwaitUsing) {
            kind = "await using";
            if (!this.recordAwaitIfAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
            }
            this.next();
          } else {
            kind = this.state.value;
          }
          this.next();
          this.parseVar(initNode, true, kind);
          const init2 = this.finishNode(initNode, "VariableDeclaration");
          const isForIn = this.match(58);
          if (isForIn && starsWithUsingDeclaration) {
            this.raise(Errors.ForInUsing, init2);
          }
          if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
            return this.parseForIn(node2, init2, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init2);
        }
      }
      const startsWithAsync = this.isContextual(95);
      const refExpressionErrors = new ExpressionErrors();
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual(102);
      if (isForOf) {
        if (startsWithLet) {
          this.raise(Errors.ForOfLet, init);
        }
        if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
          this.raise(Errors.ForOfAsync, init);
        }
      }
      if (isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.toAssignable(init, true);
        const type = isForOf ? "ForOfStatement" : "ForInStatement";
        this.checkLVal(init, {
          type
        });
        return this.parseForIn(node2, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init);
    }
    parseFunctionStatement(node2, isAsync, isHangingDeclaration) {
      this.next();
      return this.parseFunction(node2, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    parseIfStatement(node2) {
      this.next();
      node2.test = this.parseHeaderExpression();
      node2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
      node2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
      return this.finishNode(node2, "IfStatement");
    }
    parseReturnStatement(node2) {
      if (!this.prodParam.hasReturn) {
        this.raise(Errors.IllegalReturn, this.state.startLoc);
      }
      this.next();
      if (this.isLineTerminator()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    }
    parseSwitchStatement(node2) {
      this.next();
      node2.discriminant = this.parseHeaderExpression();
      const cases = node2.cases = [];
      this.expect(5);
      this.state.labels.push(switchLabel);
      this.scope.enter(256);
      let cur;
      for (let sawDefault; !this.match(8); ) {
        if (this.match(61) || this.match(65)) {
          const isCase = this.match(61);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(14);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatementListItem());
          } else {
            this.unexpected();
          }
        }
      }
      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    }
    parseThrowStatement(node2) {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
      this.checkLVal(param, {
        type: "CatchClause"
      }, 9);
      return param;
    }
    parseTryStatement(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.match(62)) {
        const clause = this.startNode();
        this.next();
        if (this.match(10)) {
          this.expect(10);
          clause.param = this.parseCatchClauseParam();
          this.expect(11);
        } else {
          clause.param = null;
          this.scope.enter(0);
        }
        clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(67) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(Errors.NoCatchOrFinally, node2);
      }
      return this.finishNode(node2, "TryStatement");
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      this.next();
      this.parseVar(node2, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    }
    parseWhileStatement(node2) {
      this.next();
      node2.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    }
    parseWithStatement(node2) {
      if (this.state.strict) {
        this.raise(Errors.StrictWith, this.state.startLoc);
      }
      this.next();
      node2.object = this.parseHeaderExpression();
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      return this.finishNode(node2, "WithStatement");
    }
    parseEmptyStatement(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    }
    parseLabeledStatement(node2, maybeName, expr, flags) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(Errors.LabelRedeclaration, expr, {
            labelName: maybeName
          });
        }
      }
      const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart === node2.start) {
          label.statementStart = this.sourceToOffsetPos(this.state.start);
          label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.sourceToOffsetPos(this.state.start)
      });
      node2.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
      this.state.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    }
    parseExpressionStatement(node2, expr, decorators) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node2 = this.startNode();
      if (allowDirectives) {
        this.state.strictErrors.clear();
      }
      this.expect(5);
      if (createNewLexicalScope) {
        this.scope.enter(0);
      }
      this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse);
      if (createNewLexicalScope) {
        this.scope.exit();
      }
      return this.finishNode(node2, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node2.body = [];
      const directives = node2.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;
      while (!this.match(end)) {
        const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);
            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }
            continue;
          }
          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
      if (!oldStrict) {
        this.setStrict(false);
      }
      this.next();
    }
    parseFor(node2, init) {
      node2.init = init;
      this.semicolon(false);
      node2.test = this.match(13) ? null : this.parseExpression();
      this.semicolon(false);
      node2.update = this.match(11) ? null : this.parseExpression();
      this.expect(11);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node2, "ForStatement");
    }
    parseForIn(node2, init, awaitAt) {
      const isForIn = this.match(58);
      this.next();
      if (isForIn) {
        if (awaitAt !== null) this.unexpected(awaitAt);
      } else {
        node2.await = awaitAt !== null;
      }
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(Errors.ForInOfLoopInitializer, init, {
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
      }
      if (init.type === "AssignmentPattern") {
        this.raise(Errors.InvalidLhs, init, {
          ancestor: {
            type: "ForStatement"
          }
        });
      }
      node2.left = init;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(11);
      node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node2, isFor, kind, allowMissingInitializer = false) {
      const declarations = node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);
        decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        if (decl.init === null && !allowMissingInitializer) {
          if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "destructuring"
            });
          } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind
            });
          }
        }
        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(12)) break;
      }
      return node2;
    }
    parseVarId(decl, kind) {
      const id = this.parseBindingAtom();
      if (kind === "using" || kind === "await using") {
        if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
          this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
        }
      } else {
        if (id.type === "VoidPattern") {
          this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
        }
      }
      this.checkLVal(id, {
        type: "VariableDeclarator"
      }, kind === "var" ? 5 : 8201);
      decl.id = id;
    }
    parseAsyncFunctionExpression(node2) {
      return this.parseFunction(node2, 8);
    }
    parseFunction(node2, flags = 0) {
      const hangingDeclaration = flags & 2;
      const isDeclaration = !!(flags & 1);
      const requireId = isDeclaration && !(flags & 4);
      const isAsync = !!(flags & 8);
      this.initFunction(node2, isAsync);
      if (this.match(55)) {
        if (hangingDeclaration) {
          this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
        }
        this.next();
        node2.generator = true;
      }
      if (isDeclaration) {
        node2.id = this.parseFunctionId(requireId);
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(514);
      this.prodParam.enter(functionFlags(isAsync, node2.generator));
      if (!isDeclaration) {
        node2.id = this.parseFunctionId();
      }
      this.parseFunctionParams(node2, false);
      this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node2, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();
      if (isDeclaration && !hangingDeclaration) {
        this.registerFunctionStatementId(node2);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node2;
    }
    parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node2, isConstructor) {
      this.expect(10);
      this.expressionScope.enter(newParameterDeclarationScope());
      node2.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
      this.expressionScope.exit();
    }
    registerFunctionStatementId(node2) {
      if (!node2.id) return;
      this.scope.declareName(node2.id.name, !this.options.annexB || this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node2.id.loc.start);
    }
    parseClass(node2, isStatement, optionalId) {
      this.next();
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node2, isStatement, optionalId);
      this.parseClassSuper(node2);
      node2.body = this.parseClassBody(!!node2.superClass, oldStrict);
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(key) {
      return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && this.nameIsConstructor(method.key);
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(5);
      this.withSmartMixTopicForbiddingContext(() => {
        while (!this.match(8)) {
          if (this.eat(13)) {
            if (decorators.length > 0) {
              throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
            }
            continue;
          }
          if (this.match(26)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }
          this.parseClassMember(classBody, member, state);
          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(Errors.DecoratorConstructor, member);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();
      if (decorators.length) {
        throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
      }
      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }
      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const accessorProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;
      this.parsePropertyNamePrefixOperator(member);
      if (this.eat(55)) {
        method.kind = "method";
        const isPrivateName = this.match(139);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(method);
        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
        }
        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }
      const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
      const key = this.parseClassElementName(member);
      const maybeContextualKw = isContextual ? key.name : null;
      const isPrivate = this.isPrivateName(key);
      const maybeQuestionTokenStartLoc = this.state.startLoc;
      this.parsePostMemberNameModifiers(publicMember);
      if (this.isClassMethod()) {
        method.kind = "method";
        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;
        if (isConstructor) {
          publicMethod.kind = "constructor";
          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(Errors.DuplicateConstructor, key);
          }
          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(Errors.OverrideOnConstructor, key);
          }
          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }
        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        const isGenerator = this.eat(55);
        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStartLoc);
        }
        method.kind = "method";
        const isPrivate2 = this.match(139);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAsync, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = maybeContextualKw;
        const isPrivate2 = this.match(139);
        this.parseClassElementName(publicMethod);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }
        this.checkGetterSetterParams(publicMethod);
      } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors");
        this.resetPreviousNodeTrailingComments(key);
        const isPrivate2 = this.match(139);
        this.parseClassElementName(publicProp);
        this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
    parseClassElementName(member) {
      const {
        type,
        value
      } = this.state;
      if ((type === 132 || type === 134) && member.static && value === "prototype") {
        this.raise(Errors.StaticPrototype, this.state.startLoc);
      }
      if (type === 139) {
        if (value === "constructor") {
          this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
        }
        const key = this.parsePrivateName();
        member.key = key;
        return key;
      }
      this.parsePropertyName(member);
      return member.key;
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(576 | 128 | 16);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(0);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));
      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(Errors.DecoratorStaticBlock, member);
      }
    }
    pushClassProperty(classBody, prop) {
      if (!prop.computed && this.nameIsConstructor(prop.key)) {
        this.raise(Errors.ConstructorClassField, prop.key);
      }
      classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node2 = this.parseClassPrivateProperty(prop);
      classBody.body.push(node2);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
      if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
        this.raise(Errors.ConstructorClassField, prop.key);
      }
      const node2 = this.parseClassAccessorProperty(prop);
      classBody.body.push(node2);
      if (isPrivate) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
      }
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node2 = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node2);
      const kind = node2.kind === "get" ? node2.static ? 6 : 2 : node2.kind === "set" ? node2.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(node2, kind);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassPrivateProperty");
    }
    parseClassProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassProperty");
    }
    parseClassAccessorProperty(node2) {
      this.parseInitializer(node2);
      this.semicolon();
      return this.finishNode(node2, "ClassAccessorProperty");
    }
    parseInitializer(node2) {
      this.scope.enter(576 | 16);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(0);
      node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
    parseClassId(node2, isStatement, optionalId, bindingType = 8331) {
      if (tokenIsIdentifier(this.state.type)) {
        node2.id = this.parseIdentifier();
        if (isStatement) {
          this.declareNameFromIdentifier(node2.id, bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node2.id = null;
        } else {
          throw this.raise(Errors.MissingClassName, this.state.startLoc);
        }
      }
    }
    parseClassSuper(node2) {
      node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node2, decorators) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, true);
      const hasDefault = this.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
      const parseAfterDefault = !hasDefault || this.eat(12);
      const hasStar = parseAfterDefault && this.eatExportStar(node2);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
      const isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        }
        this.parseExportFrom(node2, true);
        this.sawUnambiguousESM = true;
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
        this.unexpected(null, 5);
      }
      if (hasNamespace && parseAfterNamespace) {
        this.unexpected(null, 98);
      }
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        }
        this.parseExportFrom(node2, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node2);
      }
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        const node22 = node2;
        this.checkExport(node22, true, false, !!node22.source);
        if (((_node2$declaration = node22.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, node22.declaration, node22);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        }
        this.sawUnambiguousESM = true;
        return this.finishNode(node22, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const node22 = node2;
        const decl = this.parseExportDefaultExpression();
        node22.declaration = decl;
        if (decl.type === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, decl, node22);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        }
        this.checkExport(node22, true, true);
        this.sawUnambiguousESM = true;
        return this.finishNode(node22, "ExportDefaultDeclaration");
      }
      throw this.unexpected(null, 5);
    }
    eatExportStar(node2) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
        const id = maybeDefaultIdentifier || this.parseIdentifier(true);
        const specifier = this.startNodeAtNode(id);
        specifier.exported = id;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      if (this.isContextual(93)) {
        var _ref, _ref$specifiers;
        (_ref$specifiers = (_ref = node2).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(node2) {
      if (this.match(5)) {
        const node22 = node2;
        if (!node22.specifiers) node22.specifiers = [];
        const isTypeExport = node22.exportKind === "type";
        node22.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
        node22.source = null;
        if (this.hasPlugin("importAssertions")) {
          node22.assertions = [];
        } else {
          node22.attributes = [];
        }
        node22.declaration = null;
        return true;
      }
      return false;
    }
    maybeParseExportDeclaration(node2) {
      if (this.shouldParseExportDeclaration()) {
        node2.specifiers = [];
        node2.source = null;
        if (this.hasPlugin("importAssertions")) {
          node2.assertions = [];
        } else {
          node2.attributes = [];
        }
        node2.declaration = this.parseExportDeclaration(node2);
        return true;
      }
      return false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return false;
      const next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      if (this.match(68)) {
        this.next();
        return this.parseFunction(expr, 1 | 4);
      } else if (this.isAsyncFunction()) {
        this.next();
        this.next();
        return this.parseFunction(expr, 1 | 4 | 8);
      }
      if (this.match(80)) {
        return this.parseClass(expr, true, true);
      }
      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
        }
        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      }
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {
        throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
      }
      const res = this.parseMaybeAssignAllowIn();
      this.semicolon();
      return res;
    }
    parseExportDeclaration(node2) {
      if (this.match(80)) {
        const node3 = this.parseClass(this.startNode(), true, false);
        return node3;
      }
      return this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (tokenIsIdentifier(type)) {
        if (type === 95 && !this.state.containsEsc || type === 100) {
          return false;
        }
        if ((type === 130 || type === 129) && !this.state.containsEsc) {
          const next2 = this.nextTokenStart();
          const nextChar = this.input.charCodeAt(next2);
          if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith("from", next2)) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(65)) {
        return false;
      }
      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
        return true;
      }
      if (this.match(65) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return false;
    }
    parseExportFrom(node2, expect) {
      if (this.eatContextual(98)) {
        node2.source = this.parseImportSource();
        this.checkExport(node2);
        this.maybeParseImportAttributes(node2);
        this.checkJSONModuleImport(node2);
      } else if (expect) {
        this.unexpected();
      }
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (type === 26) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return true;
        }
      }
      if (this.isUsing()) {
        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
        return true;
      }
      if (this.isAwaitUsing()) {
        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
        return true;
      }
      return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node2, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          this.checkDuplicateExports(node2, "default");
          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node2.declaration;
            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
            }
          }
        } else if ((_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
          for (const specifier of node2.specifiers) {
            const {
              exported
            } = specifier;
            const exportName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportName);
            if (!isFrom && specifier.local) {
              const {
                local
              } = specifier;
              if (local.type !== "Identifier") {
                this.raise(Errors.ExportBindingIsString, specifier, {
                  localName: local.value,
                  exportName
                });
              } else {
                this.checkReservedWord(local.name, local.loc.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node2.declaration) {
          const decl = node2.declaration;
          if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
            const {
              id
            } = decl;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node2, id.name);
          } else if (decl.type === "VariableDeclaration") {
            for (const declaration of decl.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }
    }
    checkDeclaration(node2) {
      if (node2.type === "Identifier") {
        this.checkDuplicateExports(node2, node2.name);
      } else if (node2.type === "ObjectPattern") {
        for (const prop of node2.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node2.type === "ArrayPattern") {
        for (const elem of node2.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node2.type === "ObjectProperty") {
        this.checkDeclaration(node2.value);
      } else if (node2.type === "RestElement") {
        this.checkDeclaration(node2.argument);
      } else if (node2.type === "AssignmentPattern") {
        this.checkDeclaration(node2.left);
      }
    }
    checkDuplicateExports(node2, exportName) {
      if (this.exportedIdentifiers.has(exportName)) {
        if (exportName === "default") {
          this.raise(Errors.DuplicateDefaultExport, node2);
        } else {
          this.raise(Errors.DuplicateExport, node2, {
            exportName
          });
        }
      }
      this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
      const nodes = [];
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.eat(8)) break;
        }
        const isMaybeTypeOnly = this.isContextual(130);
        const isString = this.match(134);
        const node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        nodes.push(this.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      if (this.eatContextual(93)) {
        node2.exported = this.parseModuleExportName();
      } else if (isString) {
        node2.exported = this.cloneStringLiteral(node2.local);
      } else if (!node2.exported) {
        node2.exported = this.cloneIdentifier(node2.local);
      }
      return this.finishNode(node2, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        const result = this.parseStringLiteral(this.state.value);
        const surrogate = loneSurrogate.exec(result.value);
        if (surrogate) {
          this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
            surrogateCharCode: surrogate[0].charCodeAt(0)
          });
        }
        return result;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(node2) {
      if (node2.assertions != null) {
        return node2.assertions.some(({
          key,
          value
        }) => {
          return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
      }
      return false;
    }
    checkImportReflection(node2) {
      const {
        specifiers
      } = node2;
      const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node2.phase === "source") {
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
        }
      } else if (node2.phase === "defer") {
        if (singleBindingType !== "ImportNamespaceSpecifier") {
          this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
        }
      } else if (node2.module) {
        var _node$assertions;
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
        }
        if (((_node$assertions = node2.assertions) == null ? void 0 : _node$assertions.length) > 0) {
          this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
        }
      }
    }
    checkJSONModuleImport(node2) {
      if (this.isJSONModuleImport(node2) && node2.type !== "ExportAllDeclaration") {
        const {
          specifiers
        } = node2;
        if (specifiers != null) {
          const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
            let imported;
            if (specifier.type === "ExportSpecifier") {
              imported = specifier.local;
            } else if (specifier.type === "ImportSpecifier") {
              imported = specifier.imported;
            }
            if (imported !== void 0) {
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            }
          });
          if (nonDefaultNamedSpecifier !== void 0) {
            this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
          }
        }
      }
    }
    isPotentialImportPhase(isExport) {
      if (isExport) return false;
      return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      if (isExport) {
        return;
      }
      if (phase === "module") {
        this.expectPlugin("importReflection", loc);
        node2.module = true;
      } else if (this.hasPlugin("importReflection")) {
        node2.module = false;
      }
      if (phase === "source") {
        this.expectPlugin("sourcePhaseImports", loc);
        node2.phase = "source";
      } else if (phase === "defer") {
        this.expectPlugin("deferredImportEvaluation", loc);
        node2.phase = "defer";
      } else if (this.hasPlugin("sourcePhaseImports")) {
        node2.phase = null;
      }
    }
    parseMaybeImportPhase(node2, isExport) {
      if (!this.isPotentialImportPhase(isExport)) {
        this.applyImportPhase(node2, isExport, null);
        return null;
      }
      const phaseIdentifier = this.startNode();
      const phaseIdentifierName = this.parseIdentifierName(true);
      const {
        type
      } = this.state;
      const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      if (isImportPhase) {
        this.applyImportPhase(node2, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
        return null;
      } else {
        this.applyImportPhase(node2, isExport, null);
        return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
      }
    }
    isPrecedingIdImportPhase(phase) {
      const {
        type
      } = this.state;
      return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    }
    parseImport(node2) {
      if (this.match(134)) {
        return this.parseImportSourceAndAttributes(node2);
      }
      return this.parseImportSpecifiersAndAfter(node2, this.parseMaybeImportPhase(node2, false));
    }
    parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier) {
      node2.specifiers = [];
      const hasDefault = this.maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier);
      const parseNext = !hasDefault || this.eat(12);
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node2);
      this.expectContextual(98);
      return this.parseImportSourceAndAttributes(node2);
    }
    parseImportSourceAndAttributes(node2) {
      var _node$specifiers2;
      (_node$specifiers2 = node2.specifiers) != null ? _node$specifiers2 : node2.specifiers = [];
      node2.source = this.parseImportSource();
      this.maybeParseImportAttributes(node2);
      this.checkImportReflection(node2);
      this.checkJSONModuleImport(node2);
      this.semicolon();
      this.sawUnambiguousESM = true;
      return this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      if (!this.match(134)) this.unexpected();
      return this.parseExprAtom();
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = this.parseIdentifier();
      node2.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    finishImportSpecifier(specifier, type, bindingType = 8201) {
      this.checkLVal(specifier.local, {
        type
      }, bindingType);
      return this.finishNode(specifier, type);
    }
    parseImportAttributes() {
      this.expect(5);
      const attrs = [];
      const attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.match(8)) {
          break;
        }
        const node2 = this.startNode();
        const keyName = this.state.value;
        if (attrNames.has(keyName)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
            key: keyName
          });
        }
        attrNames.add(keyName);
        if (this.match(134)) {
          node2.key = this.parseStringLiteral(keyName);
        } else {
          node2.key = this.parseIdentifier(true);
        }
        this.expect(14);
        if (!this.match(134)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        node2.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      this.expect(8);
      return attrs;
    }
    parseModuleAttributes() {
      const attrs = [];
      const attributes = /* @__PURE__ */ new Set();
      do {
        const node2 = this.startNode();
        node2.key = this.parseIdentifier(true);
        if (node2.key.name !== "type") {
          this.raise(Errors.ModuleAttributeDifferentFromType, node2.key);
        }
        if (attributes.has(node2.key.name)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, node2.key, {
            key: node2.key.name
          });
        }
        attributes.add(node2.key.name);
        this.expect(14);
        if (!this.match(134)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        node2.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    }
    maybeParseImportAttributes(node2) {
      let attributes;
      {
        var useWith = false;
      }
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
          return;
        }
        this.next();
        if (this.hasPlugin("moduleAttributes")) {
          attributes = this.parseModuleAttributes();
          this.addExtra(node2, "deprecatedWithLegacySyntax", true);
        } else {
          attributes = this.parseImportAttributes();
        }
        {
          useWith = true;
        }
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
        }
        if (!this.hasPlugin("importAssertions")) {
          this.addExtra(node2, "deprecatedAssertSyntax", true);
        }
        this.next();
        attributes = this.parseImportAttributes();
      } else {
        attributes = [];
      }
      if (!useWith && this.hasPlugin("importAssertions")) {
        node2.assertions = attributes;
      } else {
        node2.attributes = attributes;
      }
    }
    maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        specifier.local = maybeDefaultIdentifier;
        node2.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
        return true;
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier");
        return true;
      }
      return false;
    }
    maybeParseStarImportSpecifier(node2) {
      if (this.match(55)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual(93);
        this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier");
        return true;
      }
      return false;
    }
    parseNamedImportSpecifiers(node2) {
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(14)) {
            throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
          }
          this.expect(12);
          if (this.eat(8)) break;
        }
        const specifier = this.startNode();
        const importedIsString = this.match(134);
        const isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node2.importKind === "type" || node2.importKind === "typeof", isMaybeTypeOnly, void 0);
        node2.specifiers.push(importSpecifier);
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        const {
          imported
        } = specifier;
        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, specifier, {
            importName: imported.value
          });
        }
        this.checkReservedWord(imported.name, specifier.loc.start, true, true);
        if (!specifier.local) {
          specifier.local = this.cloneIdentifier(imported);
        }
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }
  class Parser extends StatementParser {
    constructor(options2, input, pluginsMap) {
      const normalizedOptions = getOptions(options2);
      super(normalizedOptions, input);
      this.options = normalizedOptions;
      this.initializeScopes();
      this.plugins = pluginsMap;
      this.filename = normalizedOptions.sourceFilename;
      this.startIndex = normalizedOptions.startIndex;
      let optionFlags = 0;
      if (normalizedOptions.allowAwaitOutsideFunction) {
        optionFlags |= 1;
      }
      if (normalizedOptions.allowReturnOutsideFunction) {
        optionFlags |= 2;
      }
      if (normalizedOptions.allowImportExportEverywhere) {
        optionFlags |= 8;
      }
      if (normalizedOptions.allowSuperOutsideMethod) {
        optionFlags |= 16;
      }
      if (normalizedOptions.allowUndeclaredExports) {
        optionFlags |= 64;
      }
      if (normalizedOptions.allowNewTargetOutsideFunction) {
        optionFlags |= 4;
      }
      if (normalizedOptions.allowYieldOutsideFunction) {
        optionFlags |= 32;
      }
      if (normalizedOptions.ranges) {
        optionFlags |= 128;
      }
      if (normalizedOptions.tokens) {
        optionFlags |= 256;
      }
      if (normalizedOptions.createImportExpressions) {
        optionFlags |= 512;
      }
      if (normalizedOptions.createParenthesizedExpressions) {
        optionFlags |= 1024;
      }
      if (normalizedOptions.errorRecovery) {
        optionFlags |= 2048;
      }
      if (normalizedOptions.attachComment) {
        optionFlags |= 4096;
      }
      if (normalizedOptions.annexB) {
        optionFlags |= 8192;
      }
      this.optionFlags = optionFlags;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      const result = this.parseTopLevel(file, program);
      result.errors = this.state.errors;
      result.comments.length = this.state.commentsLen;
      return result;
    }
  }
  function parse2(input, options2) {
    var _options;
    if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options2 = Object.assign({}, options2);
      try {
        options2.sourceType = "module";
        const parser2 = getParser(options2, input);
        const ast = parser2.parse();
        if (parser2.sawUnambiguousESM) {
          return ast;
        }
        if (parser2.ambiguousScriptDifferentAst) {
          try {
            options2.sourceType = "script";
            return getParser(options2, input).parse();
          } catch (_unused) {
          }
        } else {
          ast.program.sourceType = "script";
        }
        return ast;
      } catch (moduleError) {
        try {
          options2.sourceType = "script";
          return getParser(options2, input).parse();
        } catch (_unused2) {
        }
        throw moduleError;
      }
    } else {
      return getParser(options2, input).parse();
    }
  }
  function parseExpression(input, options2) {
    const parser2 = getParser(options2, input);
    if (parser2.options.strictMode) {
      parser2.state.strict = true;
    }
    return parser2.getExpression();
  }
  function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes2 = {};
    for (const typeName of Object.keys(internalTokenTypes)) {
      tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    return tokenTypes2;
  }
  const tokTypes = generateExportedTokenTypes(tt3);
  function getParser(options2, input) {
    let cls = Parser;
    const pluginsMap = /* @__PURE__ */ new Map();
    if (options2 != null && options2.plugins) {
      for (const plugin of options2.plugins) {
        let name, opts;
        if (typeof plugin === "string") {
          name = plugin;
        } else {
          [name, opts] = plugin;
        }
        if (!pluginsMap.has(name)) {
          pluginsMap.set(name, opts || {});
        }
      }
      validatePlugins(pluginsMap);
      cls = getParserClass(pluginsMap);
    }
    return new cls(options2, input, pluginsMap);
  }
  const parserClassCache = /* @__PURE__ */ new Map();
  function getParserClass(pluginsMap) {
    const pluginList = [];
    for (const name of mixinPluginNames) {
      if (pluginsMap.has(name)) {
        pluginList.push(name);
      }
    }
    const key = pluginList.join("|");
    let cls = parserClassCache.get(key);
    if (!cls) {
      cls = Parser;
      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }
      parserClassCache.set(key, cls);
    }
    return cls;
  }
  lib$1.parse = parse2;
  lib$1.parseExpression = parseExpression;
  lib$1.tokTypes = tokTypes;
  return lib$1;
}
var hasRequiredReplacement;
function requireReplacement() {
  if (hasRequiredReplacement) return replacement;
  hasRequiredReplacement = 1;
  Object.defineProperty(replacement, "__esModule", {
    value: true
  });
  replacement._replaceWith = _replaceWith;
  replacement.replaceExpressionWithStatements = replaceExpressionWithStatements;
  replacement.replaceInline = replaceInline;
  replacement.replaceWith = replaceWith;
  replacement.replaceWithMultiple = replaceWithMultiple;
  replacement.replaceWithSourceString = replaceWithSourceString;
  var _codeFrame = requireLib$3();
  var _index = requireLib();
  var _index2 = requirePath();
  var _cache = requireCache();
  var _modification = requireModification();
  var _parser = requireLib$2();
  var _t2 = requireLib$5();
  var _context = requireContext();
  const {
    FUNCTION_TYPES,
    arrowFunctionExpression,
    assignmentExpression,
    awaitExpression,
    blockStatement,
    buildUndefinedNode,
    callExpression,
    cloneNode: cloneNode2,
    conditionalExpression,
    expressionStatement,
    getBindingIdentifiers: getBindingIdentifiers2,
    identifier: identifier2,
    inheritLeadingComments: inheritLeadingComments2,
    inheritTrailingComments: inheritTrailingComments2,
    inheritsComments: inheritsComments2,
    isBlockStatement,
    isEmptyStatement,
    isExpression,
    isExpressionStatement,
    isIfStatement,
    isProgram,
    isStatement,
    isVariableDeclaration,
    removeComments: removeComments2,
    returnStatement,
    sequenceExpression,
    validate: validate2,
    yieldExpression
  } = _t2;
  function replaceWithMultiple(nodes) {
    var _getCachedPaths;
    _context.resync.call(this);
    const verifiedNodes = _modification._verifyNodeList.call(this, nodes);
    inheritLeadingComments2(verifiedNodes[0], this.node);
    inheritTrailingComments2(verifiedNodes[verifiedNodes.length - 1], this.node);
    (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
    return paths;
  }
  function replaceWithSourceString(replacement2) {
    _context.resync.call(this);
    let ast;
    try {
      replacement2 = `(${replacement2})`;
      ast = (0, _parser.parse)(replacement2);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement2, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }
      throw err;
    }
    const expressionAST = ast.program.body[0].expression;
    _index.default.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
  }
  function replaceWith(replacementPath) {
    _context.resync.call(this);
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    let replacement2 = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
    if (!replacement2) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement2) {
      return [this];
    }
    if (this.isProgram() && !isProgram(replacement2)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement2)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement2 === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    let nodePath = "";
    if (this.isNodeType("Statement") && isExpression(replacement2)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement2) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement2 = expressionStatement(replacement2);
        nodePath = "expression";
      }
    }
    if (this.isNodeType("Expression") && isStatement(replacement2)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement2)) {
        return this.replaceExpressionWithStatements([replacement2]);
      }
    }
    const oldNode = this.node;
    if (oldNode) {
      inheritsComments2(replacement2, oldNode);
      removeComments2(oldNode);
    }
    _replaceWith.call(this, replacement2);
    this.type = replacement2.type;
    _context.setScope.call(this);
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node2) {
    var _getCachedPaths2;
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      validate2(this.parent, this.key, [node2]);
    } else {
      validate2(this.parent, this.key, node2);
    }
    this.debug(`Replace with ${node2 == null ? void 0 : node2.type}`);
    (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node2, this).delete(this.node);
    this.node = node2;
    this.container[this.key] = node2;
  }
  function replaceExpressionWithStatements(nodes) {
    _context.resync.call(this);
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions2(nodes, declars);
    if (nodesAsSingleExpression) {
      for (const id of declars) this.scope.push({
        id
      });
      return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
    }
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
    const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
    const container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    const callee = this.get("callee");
    callee.get("body").scope.hoistVariables((id) => this.scope.push({
      id
    }));
    const completionRecords = callee.getCompletionRecords();
    for (const path2 of completionRecords) {
      if (!path2.isExpressionStatement()) continue;
      const loop = path2.findParent((path3) => path3.isLoop());
      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");
        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode2(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier2(uid.name);
        }
        path2.get("expression").replaceWith(assignmentExpression("=", cloneNode2(uid), path2.node.expression));
      } else {
        path2.replaceWith(returnStatement(path2.node.expression));
      }
    }
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
    if (needToAwaitFunction) {
      newCallee.set("async", true);
      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }
    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }
    return newCallee.get("body.body");
  }
  function gatherSequenceExpressions2(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!isEmptyStatement(node2)) {
        ensureLastUndefined = false;
      }
      if (isExpression(node2)) {
        exprs.push(node2);
      } else if (isExpressionStatement(node2)) {
        exprs.push(node2.expression);
      } else if (isVariableDeclaration(node2)) {
        if (node2.kind !== "var") return;
        for (const declar of node2.declarations) {
          const bindings = getBindingIdentifiers2(declar);
          for (const key of Object.keys(bindings)) {
            declars.push(cloneNode2(bindings[key]));
          }
          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if (isIfStatement(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions2([node2.consequent], declars) : buildUndefinedNode();
        const alternate = node2.alternate ? gatherSequenceExpressions2([node2.alternate], declars) : buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(conditionalExpression(node2.test, consequent, alternate));
      } else if (isBlockStatement(node2)) {
        const body = gatherSequenceExpressions2(node2.body, declars);
        if (!body) return;
        exprs.push(body);
      } else if (isEmptyStatement(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) exprs.push(buildUndefinedNode());
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }
  function replaceInline(nodes) {
    _context.resync.call(this);
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = _modification._verifyNodeList.call(this, nodes);
        const paths = _modification._containerInsertAfter.call(this, nodes);
        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }
  return replacement;
}
var evaluation = {};
var hasRequiredEvaluation;
function requireEvaluation() {
  if (hasRequiredEvaluation) return evaluation;
  hasRequiredEvaluation = 1;
  Object.defineProperty(evaluation, "__esModule", {
    value: true
  });
  evaluation.evaluate = evaluate;
  evaluation.evaluateTruthy = evaluateTruthy;
  const VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
  const VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
  const INVALID_METHODS = ["random"];
  function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
  }
  function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
  }
  function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
  }
  function evaluateTruthy() {
    const res = this.evaluate();
    if (res.confident) return !!res.value;
  }
  function deopt(path2, state) {
    if (!state.confident) return;
    state.deoptPath = path2;
    state.confident = false;
  }
  const Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
  function evaluateCached(path2, state) {
    const {
      node: node2
    } = path2;
    const {
      seen
    } = state;
    if (seen.has(node2)) {
      const existing = seen.get(node2);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path2, state);
        return;
      }
    } else {
      const item = {
        resolved: false
      };
      seen.set(node2, item);
      const val = _evaluate(path2, state);
      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }
  function _evaluate(path2, state) {
    if (!state.confident) return;
    if (path2.isSequenceExpression()) {
      const exprs = path2.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }
    if (path2.isStringLiteral() || path2.isNumericLiteral() || path2.isBooleanLiteral()) {
      return path2.node.value;
    }
    if (path2.isNullLiteral()) {
      return null;
    }
    if (path2.isTemplateLiteral()) {
      return evaluateQuasis(path2, path2.node.quasis, state);
    }
    if (path2.isTaggedTemplateExpression() && path2.get("tag").isMemberExpression()) {
      const object = path2.get("tag.object");
      const {
        node: {
          name
        }
      } = object;
      const property = path2.get("tag.property");
      if (object.isIdentifier() && name === "String" && !path2.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path2, path2.node.quasi.quasis, state, true);
      }
    }
    if (path2.isConditionalExpression()) {
      const testResult = evaluateCached(path2.get("test"), state);
      if (!state.confident) return;
      if (testResult) {
        return evaluateCached(path2.get("consequent"), state);
      } else {
        return evaluateCached(path2.get("alternate"), state);
      }
    }
    if (path2.isExpressionWrapper()) {
      return evaluateCached(path2.get("expression"), state);
    }
    if (path2.isMemberExpression() && !path2.parentPath.isCallExpression({
      callee: path2.node
    })) {
      const property = path2.get("property");
      const object = path2.get("object");
      if (object.isLiteral()) {
        const value = object.node.value;
        const type = typeof value;
        let key = null;
        if (path2.node.computed) {
          key = evaluateCached(property, state);
          if (!state.confident) return;
        } else if (property.isIdentifier()) {
          key = property.node.name;
        }
        if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
          return value[key];
        }
      }
    }
    if (path2.isReferencedIdentifier()) {
      const binding2 = path2.scope.getBinding(path2.node.name);
      if (binding2) {
        if (binding2.constantViolations.length > 0 || path2.node.start < binding2.path.node.end) {
          deopt(binding2.path, state);
          return;
        }
        const bindingPathScope = binding2.path.scope;
        if (binding2.kind === "var" && bindingPathScope !== binding2.scope) {
          let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
          for (let scope2 = bindingPathScope.parent; scope2; scope2 = scope2.parent) {
            var _scope$path$parentPat;
            if (scope2 === path2.scope) {
              if (hasUnsafeBlock) {
                deopt(binding2.path, state);
                return;
              }
              break;
            }
            if ((_scope$path$parentPat = scope2.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {
              hasUnsafeBlock = true;
            }
          }
        }
        if (binding2.hasValue) {
          return binding2.value;
        }
      }
      const name = path2.node.name;
      if (Globals.has(name)) {
        if (!binding2) {
          return Globals.get(name);
        }
        deopt(binding2.path, state);
        return;
      }
      const resolved = path2.resolve();
      if (resolved === path2) {
        deopt(path2, state);
        return;
      }
      const value = evaluateCached(resolved, state);
      if (typeof value === "object" && value !== null && binding2.references > 1) {
        deopt(resolved, state);
        return;
      }
      return value;
    }
    if (path2.isUnaryExpression({
      prefix: true
    })) {
      if (path2.node.operator === "void") {
        return void 0;
      }
      const argument = path2.get("argument");
      if (path2.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }
      const arg = evaluateCached(argument, state);
      if (!state.confident) return;
      switch (path2.node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg;
      }
    }
    if (path2.isArrayExpression()) {
      const arr = [];
      const elems = path2.get("elements");
      for (const elem of elems) {
        const elemValue = elem.evaluate();
        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          deopt(elemValue.deopt, state);
          return;
        }
      }
      return arr;
    }
    if (path2.isObjectExpression()) {
      const obj = {};
      const props = path2.get("properties");
      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          deopt(prop, state);
          return;
        }
        const keyPath = prop.get("key");
        let key;
        if (prop.node.computed) {
          key = keyPath.evaluate();
          if (!key.confident) {
            deopt(key.deopt, state);
            return;
          }
          key = key.value;
        } else if (keyPath.isIdentifier()) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get("value");
        let value = valuePath.evaluate();
        if (!value.confident) {
          deopt(value.deopt, state);
          return;
        }
        value = value.value;
        obj[key] = value;
      }
      return obj;
    }
    if (path2.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left = evaluateCached(path2.get("left"), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right = evaluateCached(path2.get("right"), state);
      const rightConfident = state.confident;
      switch (path2.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;
        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
        case "??":
          state.confident = leftConfident && (left != null || rightConfident);
          if (!state.confident) return;
          return left != null ? left : right;
      }
    }
    if (path2.isBinaryExpression()) {
      const left = evaluateCached(path2.get("left"), state);
      if (!state.confident) return;
      const right = evaluateCached(path2.get("right"), state);
      if (!state.confident) return;
      switch (path2.node.operator) {
        case "-":
          return left - right;
        case "+":
          return left + right;
        case "/":
          return left / right;
        case "*":
          return left * right;
        case "%":
          return left % right;
        case "**":
          return Math.pow(left, right);
        case "<":
          return left < right;
        case ">":
          return left > right;
        case "<=":
          return left <= right;
        case ">=":
          return left >= right;
        case "==":
          return left == right;
        case "!=":
          return left != right;
        case "===":
          return left === right;
        case "!==":
          return left !== right;
        case "|":
          return left | right;
        case "&":
          return left & right;
        case "^":
          return left ^ right;
        case "<<":
          return left << right;
        case ">>":
          return left >> right;
        case ">>>":
          return left >>> right;
      }
    }
    if (path2.isCallExpression()) {
      const callee = path2.get("callee");
      let context2;
      let func;
      if (callee.isIdentifier() && !path2.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
        func = commonjsGlobal[callee.node.name];
      }
      if (callee.isMemberExpression()) {
        const object = callee.get("object");
        const property = callee.get("property");
        if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
          context2 = commonjsGlobal[object.node.name];
          const key = property.node.name;
          if (hasOwnProperty.call(context2, key)) {
            func = context2[key];
          }
        }
        if (object.isLiteral() && property.isIdentifier()) {
          const type = typeof object.node.value;
          if (type === "string" || type === "number") {
            context2 = object.node.value;
            func = context2[property.node.name];
          }
        }
      }
      if (func) {
        const args = path2.get("arguments").map((arg) => evaluateCached(arg, state));
        if (!state.confident) return;
        return func.apply(context2, args);
      }
    }
    deopt(path2, state);
  }
  function evaluateQuasis(path2, quasis, state, raw = false) {
    let str = "";
    let i = 0;
    const exprs = path2.isTemplateLiteral() ? path2.get("expressions") : path2.get("quasi.expressions");
    for (const elem of quasis) {
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }
    if (!state.confident) return;
    return str;
  }
  function evaluate() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    };
    let value = evaluateCached(this, state);
    if (!state.confident) value = void 0;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value
    };
  }
  return evaluation;
}
var conversion = {};
var lib = {};
var formatters = {};
var hasRequiredFormatters;
function requireFormatters() {
  if (hasRequiredFormatters) return formatters;
  hasRequiredFormatters = 1;
  Object.defineProperty(formatters, "__esModule", {
    value: true
  });
  formatters.statements = formatters.statement = formatters.smart = formatters.program = formatters.expression = void 0;
  var _t2 = requireLib$5();
  const {
    assertExpressionStatement
  } = _t2;
  function makeStatementFormatter(fn2) {
    return {
      code: (str) => `/* @babel/template */;
${str}`,
      validate: () => {
      },
      unwrap: (ast) => {
        return fn2(ast.program.body.slice(1));
      }
    };
  }
  formatters.smart = makeStatementFormatter((body) => {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  formatters.statements = makeStatementFormatter((body) => body);
  formatters.statement = makeStatementFormatter((body) => {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  const expression = formatters.expression = {
    code: (str) => `(
${str}
)`,
    validate: (ast) => {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: ({
      program
    }) => {
      const [stmt] = program.body;
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  formatters.program = {
    code: (str) => str,
    validate: () => {
    },
    unwrap: (ast) => ast.program
  };
  return formatters;
}
var builder = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  Object.defineProperty(options, "__esModule", {
    value: true
  });
  options.merge = merge;
  options.normalizeReplacements = normalizeReplacements;
  options.validate = validate2;
  const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function merge(a2, b2) {
    const {
      placeholderWhitelist = a2.placeholderWhitelist,
      placeholderPattern = a2.placeholderPattern,
      preserveComments = a2.preserveComments,
      syntacticPlaceholders = a2.syntacticPlaceholders
    } = b2;
    return {
      parser: Object.assign({}, a2.parser, b2.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    };
  }
  function validate2(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }
    const _ref = opts || {}, {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = _ref, parser2 = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    return {
      parser: parser2,
      placeholderWhitelist: placeholderWhitelist || void 0,
      placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
      preserveComments: preserveComments == null ? void 0 : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement2, i) => {
        acc["$" + i] = replacement2;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || void 0;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  return options;
}
var string = {};
var parse$2 = {};
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$2;
  hasRequiredParse = 1;
  Object.defineProperty(parse$2, "__esModule", {
    value: true
  });
  parse$2.default = parseAndBuildMetadata;
  var _t2 = requireLib$5();
  var _parser = requireLib$2();
  var _codeFrame = requireLib$3();
  const {
    isCallExpression,
    isExpressionStatement,
    isFunction,
    isIdentifier,
    isJSXIdentifier,
    isNewExpression,
    isPlaceholder,
    isStatement,
    isStringLiteral,
    removePropertiesDeep: removePropertiesDeep2,
    traverse: traverse2
  } = _t2;
  const PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep2(ast, {
      preserveComments
    });
    formatter.validate(ast);
    const state = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders
    };
    traverse2(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  }
  function placeholderVisitorHandler(node2, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node2)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      }
      name = node2.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node2) || isJSXIdentifier(node2)) {
      name = node2.name;
    } else if (isStringLiteral(node2)) {
      name = node2.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    const {
      node: parent,
      key
    } = ancestors[ancestors.length - 1];
    let type;
    if (isStringLiteral(node2) || isPlaceholder(node2, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node2)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node2) && isPlaceholder(node2)) {
      type = "statement";
    } else {
      type = "other";
    }
    const {
      placeholders: placeholders2,
      placeholderNames
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    placeholders2.push({
      name,
      type,
      resolve: (ast) => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }
  function resolveAncestors(ast, ancestors) {
    let parent = ast;
    for (let i = 0; i < ancestors.length - 1; i++) {
      const {
        key: key2,
        index: index2
      } = ancestors[i];
      if (index2 === void 0) {
        parent = parent[key2];
      } else {
        parent = parent[key2][index2];
      }
    }
    const {
      key,
      index
    } = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index
    };
  }
  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowAwaitOutsideFunction: true,
      allowReturnOutsideFunction: true,
      allowNewTargetOutsideFunction: true,
      allowSuperOutsideMethod: true,
      allowYieldOutsideFunction: true,
      sourceType: "module"
    }, parserOpts, {
      plugins
    });
    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  }
  return parse$2;
}
var populate = {};
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  Object.defineProperty(populate, "__esModule", {
    value: true
  });
  populate.default = populatePlaceholders;
  var _t2 = requireLib$5();
  const {
    blockStatement,
    cloneNode: cloneNode2,
    emptyStatement,
    expressionStatement,
    identifier: identifier2,
    isStatement,
    isStringLiteral,
    stringLiteral,
    validate: validate2
  } = _t2;
  function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode2(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach((placeholder) => {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      });
      Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach((placeholder) => {
      try {
        var _ref;
        applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
        throw e;
      }
    });
    return ast;
  }
  function applyReplacement(placeholder, ast, replacement2) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement2)) {
        replacement2 = replacement2.map((node2) => cloneNode2(node2));
      } else if (typeof replacement2 === "object") {
        replacement2 = cloneNode2(replacement2);
      }
    }
    const {
      parent,
      key,
      index
    } = placeholder.resolve(ast);
    if (placeholder.type === "string") {
      if (typeof replacement2 === "string") {
        replacement2 = stringLiteral(replacement2);
      }
      if (!replacement2 || !isStringLiteral(replacement2)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === void 0) {
        if (!replacement2) {
          replacement2 = emptyStatement();
        } else if (Array.isArray(replacement2)) {
          replacement2 = blockStatement(replacement2);
        } else if (typeof replacement2 === "string") {
          replacement2 = expressionStatement(identifier2(replacement2));
        } else if (!isStatement(replacement2)) {
          replacement2 = expressionStatement(replacement2);
        }
      } else {
        if (replacement2 && !Array.isArray(replacement2)) {
          if (typeof replacement2 === "string") {
            replacement2 = identifier2(replacement2);
          }
          if (!isStatement(replacement2)) {
            replacement2 = expressionStatement(replacement2);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement2 === "string") {
        replacement2 = identifier2(replacement2);
      }
      if (index === void 0) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement2 === "string") {
        replacement2 = identifier2(replacement2);
      }
      if (Array.isArray(replacement2)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    function set(parent2, key2, value) {
      const node2 = parent2[key2];
      parent2[key2] = value;
      if (node2.type === "Identifier" || node2.type === "Placeholder") {
        if (node2.typeAnnotation) {
          value.typeAnnotation = node2.typeAnnotation;
        }
        if (node2.optional) {
          value.optional = node2.optional;
        }
        if (node2.decorators) {
          value.decorators = node2.decorators;
        }
      }
    }
    if (index === void 0) {
      validate2(parent, key, replacement2);
      set(parent, key, replacement2);
    } else {
      const items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement2 == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement2)) {
          items.splice(index, 1, ...replacement2);
        } else {
          set(items, index, replacement2);
        }
      } else {
        set(items, index, replacement2);
      }
      validate2(parent, key, items);
      parent[key] = items;
    }
  }
  return populate;
}
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string.default = stringTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg) => {
      const replacements = (0, _options.normalizeReplacements)(arg);
      if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
  }
  return string;
}
var literal = {};
var hasRequiredLiteral;
function requireLiteral() {
  if (hasRequiredLiteral) return literal;
  hasRequiredLiteral = 1;
  Object.defineProperty(literal, "__esModule", {
    value: true
  });
  literal.default = literalTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function literalTemplate(formatter, tpl, opts) {
    const {
      metadata,
      names
    } = buildLiteralData(formatter, tpl, opts);
    return (arg) => {
      const defaultReplacements = {};
      arg.forEach((replacement2, i) => {
        defaultReplacements[names[i]] = replacement2;
      });
      return (arg2) => {
        const replacements = (0, _options.normalizeReplacements)(arg2);
        if (replacements) {
          Object.keys(replacements).forEach((key) => {
            if (hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }
  function buildLiteralData(formatter, tpl, opts) {
    let prefix = "BABEL_TPL$";
    const raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    const {
      names,
      code
    } = buildTemplateCode(tpl, prefix);
    const metadata = (0, _parse.default)(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata,
      names
    };
  }
  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for (let i = 1; i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value);
      code += value + tpl[i];
    }
    return {
      names,
      code
    };
  }
  return literal;
}
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", {
    value: true
  });
  builder.default = createTemplateBuilder;
  var _options = requireOptions();
  var _string = requireString();
  var _literal = requireLiteral();
  const NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = /* @__PURE__ */ new WeakMap();
    const templateAstCache = /* @__PURE__ */ new WeakMap();
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        let builder2 = templateFnCache.get(tpl);
        if (!builder2) {
          builder2 = (0, _literal.default)(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder2);
        }
        return extendedTrace(builder2(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          let builder2 = templateAstCache.get(tpl);
          if (!builder2) {
            builder2 = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder2);
          }
          return builder2(args)();
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }
    });
  }
  function extendedTrace(fn2) {
    let rootStack = "";
    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }
    return (arg) => {
      try {
        return fn2(arg);
      } catch (err) {
        err.stack += `
    =============
${rootStack}`;
        throw err;
      }
    };
  }
  return builder;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.statements = lib.statement = lib.smart = lib.program = lib.expression = lib.default = void 0;
  var formatters2 = requireFormatters();
  var _builder = requireBuilder();
  const smart = lib.smart = (0, _builder.default)(formatters2.smart);
  const statement = lib.statement = (0, _builder.default)(formatters2.statement);
  const statements2 = lib.statements = (0, _builder.default)(formatters2.statements);
  const expression = lib.expression = (0, _builder.default)(formatters2.expression);
  const program = lib.program = (0, _builder.default)(formatters2.program);
  lib.default = Object.assign(smart.bind(void 0), {
    smart,
    statement,
    statements: statements2,
    expression,
    program,
    ast: smart.ast
  });
  return lib;
}
var hasRequiredConversion;
function requireConversion() {
  if (hasRequiredConversion) return conversion;
  hasRequiredConversion = 1;
  Object.defineProperty(conversion, "__esModule", {
    value: true
  });
  conversion.arrowFunctionToExpression = arrowFunctionToExpression;
  conversion.ensureBlock = ensureBlock2;
  conversion.ensureFunctionName = ensureFunctionName;
  conversion.splitExportDeclaration = splitExportDeclaration;
  conversion.toComputedKey = toComputedKey2;
  conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  var _t2 = requireLib$5();
  var _template = requireLib$1();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    arrowFunctionExpression,
    assignmentExpression,
    binaryExpression,
    blockStatement,
    callExpression,
    conditionalExpression,
    expressionStatement,
    identifier: identifier2,
    isIdentifier,
    jsxIdentifier,
    logicalExpression,
    LOGICAL_OPERATORS,
    memberExpression,
    metaProperty,
    numericLiteral,
    objectExpression,
    restElement,
    returnStatement,
    sequenceExpression,
    spreadElement,
    stringLiteral,
    super: _super,
    thisExpression,
    toExpression: toExpression2,
    unaryExpression,
    toBindingIdentifierName: toBindingIdentifierName2,
    isFunction,
    isAssignmentPattern,
    isRestElement,
    getFunctionName: getFunctionName2,
    cloneNode: cloneNode2,
    variableDeclaration,
    variableDeclarator,
    exportNamedDeclaration,
    exportSpecifier,
    inherits: inherits2
  } = _t2;
  function toComputedKey2() {
    let key;
    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!this.node.computed) {
      if (isIdentifier(key)) key = stringLiteral(key.name);
    }
    return key;
  }
  function ensureBlock2() {
    const body = this.get("body");
    const bodyNode = body.node;
    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }
    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }
    if (body.isBlockStatement()) {
      return bodyNode;
    }
    const statements2 = [];
    let stringPath = "body";
    let key;
    let listKey;
    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements2.push(body.node);
    } else {
      stringPath += ".body.0";
      if (this.isFunction()) {
        key = "argument";
        statements2.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements2.push(expressionStatement(body.node));
      }
    }
    this.node.body = blockStatement(statements2);
    const parentPath = this.get(stringPath);
    _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  {
    conversion.arrowFunctionToShadowed = function() {
      if (!this.isArrowFunctionExpression()) return;
      this.arrowFunctionToExpression();
    };
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }
    hoistFunctionEnvironment(this);
  }
  function setType(path2, type) {
    path2.node.type = type;
  }
  function arrowFunctionToExpression({
    allowInsertArrow = true,
    allowInsertArrowWithRest = allowInsertArrow,
    noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }
    let self2 = this;
    if (!noNewArrows) {
      var _self$ensureFunctionN;
      self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
    }
    const {
      thisBinding,
      fnPath: fn2
    } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    fn2.ensureBlock();
    setType(fn2, "FunctionExpression");
    if (!noNewArrows) {
      const checkBinding = thisBinding ? null : fn2.scope.generateUidIdentifier("arrowCheckId");
      if (checkBinding) {
        fn2.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }
      fn2.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier2(checkBinding.name) : identifier2(thisBinding)])));
      fn2.replaceWith(callExpression(memberExpression(fn2.node, identifier2("bind")), [checkBinding ? identifier2(checkBinding.name) : thisExpression()]));
      return fn2.get("callee.object");
    }
    return fn2;
  }
  const getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      allSuperCalls
    }) {
      if (!child.get("callee").isSuper()) return;
      allSuperCalls.push(child);
    }
  });
  function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
      if (p.isArrowFunctionExpression()) {
        arrowParent != null ? arrowParent : arrowParent = p;
        return false;
      }
      return p.isFunction() || p.isProgram() || p.isClassProperty({
        static: false
      }) || p.isClassPrivateProperty({
        static: false
      });
    });
    const inConstructor = thisEnvFn.isClassMethod({
      kind: "constructor"
    });
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
      if (arrowParent) {
        thisEnvFn = arrowParent;
      } else if (allowInsertArrow) {
        fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression2(fnPath.node)), []));
        thisEnvFn = fnPath.get("callee");
        fnPath = thisEnvFn.get("body");
      } else {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
    }
    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    } = getScopeInformation(fnPath);
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      if (!allowInsertArrowWithRest) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const allSuperCalls = [];
      thisEnvFn.traverse(getSuperCallsVisitor, {
        allSuperCalls
      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach((superCall) => {
        const callee = identifier2(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
        const args = () => identifier2("arguments");
        if (thisEnvFn.scope.path.isProgram()) {
          return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
        } else {
          return args();
        }
      });
      argumentsPaths.forEach((argumentsChild) => {
        const argsRef = identifier2(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier2("new"), identifier2("target")));
      newTargetPaths.forEach((targetChild) => {
        const targetRef = identifier2(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
      flatSuperProps.forEach((superProp) => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name;
        const superParentPath = superProp.parentPath;
        const isAssignment = superParentPath.isAssignmentExpression({
          left: superProp.node
        });
        const isCall = superParentPath.isCallExpression({
          callee: superProp.node
        });
        const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
          tag: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          const value = superParentPath.node.right;
          args.push(value);
        }
        const call = callExpression(identifier2(superBinding), args);
        if (isCall) {
          superParentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier2("call")));
          thisPaths.push(superParentPath.get("arguments.0"));
        } else if (isAssignment) {
          superParentPath.replaceWith(call);
        } else if (isTaggedTemplate) {
          superProp.replaceWith(callExpression(memberExpression(call, identifier2("bind"), false), [thisExpression()]));
          thisPaths.push(superProp.get("arguments.0"));
        } else {
          superProp.replaceWith(call);
        }
      });
    }
    let thisBinding;
    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);
      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach((thisChild) => {
          const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier2(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }
    return {
      thisBinding,
      fnPath
    };
  }
  function isLogicalOp(op2) {
    return LOGICAL_OPERATORS.includes(op2);
  }
  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      const assignmentPath = superProp.parentPath;
      const op2 = assignmentPath.node.operator.slice(0, -1);
      const value = assignmentPath.node.right;
      const isLogicalAssignment = isLogicalOp(op2);
      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const {
          object,
          property
        } = superProp.node;
        assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op2, memberExpression(object, identifier2(tmp.name), true), value));
      } else {
        const object = superProp.node.object;
        const property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, property));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op2, memberExpression(object, identifier2(property.name)), value));
      }
      if (isLogicalAssignment) {
        assignmentPath.replaceWith(logicalExpression(op2, assignmentPath.node.left, assignmentPath.node.right));
      } else {
        assignmentPath.node.operator = "=";
      }
      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier2(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier2(tmp.name), numericLiteral(1)))];
      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier2(tmp.name));
      }
      updateExpr.replaceWith(sequenceExpression(parts));
      const left = updateExpr.get("expressions.0.right");
      const right = updateExpr.get("expressions.1.left");
      return [left, right];
    }
    return [superProp];
    function rightExpression(op2, left, right) {
      if (op2 === "=") {
        return assignmentExpression("=", left, right);
      } else {
        return binaryExpression(op2, left, right);
      }
    }
  }
  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }
  const assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      supers,
      thisBinding
    }) {
      if (!child.get("callee").isSuper()) return;
      if (supers.has(child.node)) return;
      supers.add(child.node);
      child.replaceWithMultiple([child.node, assignmentExpression("=", identifier2(thisBinding), identifier2("this"))]);
    }
  });
  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", (thisBinding) => {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
      thisEnvFn.traverse(assignSuperThisVisitor, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding
      });
    });
  }
  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier2(argsBinding.name))]));
    });
  }
  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op2 = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, `superprop_${op2}:${propName || ""}`, () => {
      const argsList = [];
      let fnBody;
      if (propName) {
        fnBody = memberExpression(_super(), identifier2(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier2(method.name), true);
      }
      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier2(valueIdent.name));
      }
      return arrowFunctionExpression(argsList, fnBody);
    });
  }
  function getBinding(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);
    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id,
        init: init(data)
      });
    }
    return data;
  }
  const getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
    ThisExpression(child, {
      thisPaths
    }) {
      thisPaths.push(child);
    },
    JSXIdentifier(child, {
      thisPaths
    }) {
      if (child.node.name !== "this") return;
      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression(child, {
      superCalls
    }) {
      if (child.get("callee").isSuper()) superCalls.push(child);
    },
    MemberExpression(child, {
      superProps
    }) {
      if (child.get("object").isSuper()) superProps.push(child);
    },
    Identifier(child, {
      argumentsPaths
    }) {
      if (!child.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let curr = child.scope;
      do {
        if (curr.hasOwnBinding("arguments")) {
          curr.rename("arguments");
          return;
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break;
        }
      } while (curr = curr.parent);
      argumentsPaths.push(child);
    },
    MetaProperty(child, {
      newTargetPaths
    }) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      })) return;
      if (!child.get("property").isIdentifier({
        name: "target"
      })) return;
      newTargetPaths.push(child);
    }
  });
  function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse(getScopeInformationVisitor, {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    };
  }
  function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
      throw new Error("Only default and named export declarations can be split.");
    }
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const declaration = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
      const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
      const scope2 = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      let id = declaration.node.id;
      let needBindingRegistration = false;
      if (!id) {
        needBindingRegistration = true;
        id = scope2.generateUidIdentifier("default");
        if (standaloneDeclaration || exportExpr) {
          declaration.node.id = cloneNode2(id);
        }
      } else if (exportExpr && scope2.hasBinding(id.name)) {
        needBindingRegistration = true;
        id = scope2.generateUidIdentifier(id.name);
      }
      const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode2(id), declaration.node)]);
      const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode2(id), identifier2("default"))]);
      this.insertAfter(updatedExportDeclaration);
      this.replaceWith(updatedDeclaration);
      if (needBindingRegistration) {
        scope2.registerDeclaration(this);
      }
      return this;
    } else if (this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map((name) => {
      return exportSpecifier(identifier2(name), identifier2(name));
    });
    const aliasDeclar = exportNamedDeclaration(null, specifiers);
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
  }
  const refersOuterBindingVisitor = {
    "ReferencedIdentifier|BindingIdentifier"(path2, state) {
      if (path2.node.name !== state.name) return;
      state.needsRename = true;
      path2.stop();
    },
    Scope(path2, state) {
      if (path2.scope.hasOwnBinding(state.name)) {
        path2.skip();
      }
    }
  };
  function ensureFunctionName(supportUnicodeId) {
    if (this.node.id) return this;
    const res = getFunctionName2(this.node, this.parent);
    if (res == null) return this;
    let {
      name
    } = res;
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
      return null;
    }
    if (name.startsWith("get ") || name.startsWith("set ")) {
      return null;
    }
    name = toBindingIdentifierName2(name.replace(/[/ ]/g, "_"));
    const id = identifier2(name);
    inherits2(id, res.originalNode);
    const state = {
      needsRename: false,
      name
    };
    const {
      scope: scope2
    } = this;
    const binding2 = scope2.getOwnBinding(name);
    if (binding2) {
      if (binding2.kind === "param") {
        state.needsRename = true;
      }
    } else if (scope2.parent.hasBinding(name) || scope2.hasGlobal(name)) {
      this.traverse(refersOuterBindingVisitor, state);
    }
    if (!state.needsRename) {
      this.node.id = id;
      {
        scope2.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
      scope2.rename(id.name);
      this.node.id = id;
      {
        scope2.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (!isFunction(this.node)) return null;
    const key = scope2.generateUidIdentifier(id.name);
    const params = [];
    for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
      params.push(scope2.generateUidIdentifier("x"));
    }
    const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode2(key)}.apply(this, arguments);
      }

      ${cloneNode2(id)}.toString = function () {
        return ${cloneNode2(key)}.toString();
      }

      return ${cloneNode2(id)};
    })(${toExpression2(this.node)})
  `;
    return this.replaceWith(call)[0].get("arguments.0");
  }
  function getFunctionArity(node2) {
    const count = node2.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
    return count === -1 ? node2.params.length : count;
  }
  return conversion;
}
var introspection = {};
var hasRequiredIntrospection;
function requireIntrospection() {
  if (hasRequiredIntrospection) return introspection;
  hasRequiredIntrospection = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports$1._resolve = _resolve;
    exports$1.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports$1.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports$1.getSource = getSource;
    exports$1.isCompletionRecord = isCompletionRecord;
    exports$1.isConstantExpression = isConstantExpression;
    exports$1.isInStrictMode = isInStrictMode;
    exports$1.isNodeType = isNodeType;
    exports$1.isStatementOrBlock = isStatementOrBlock;
    exports$1.isStatic = isStatic;
    exports$1.matchesPattern = matchesPattern2;
    exports$1.referencesImport = referencesImport;
    exports$1.resolve = resolve;
    exports$1.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t2 = requireLib$5();
    const {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType: isType2,
      matchesPattern: _matchesPattern
    } = _t2;
    function matchesPattern2(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports$1.has = function has(key) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports$1.is = exports$1.has;
      exports$1.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports$1.equals = function equals(key, value) {
        return this.node[key] === value;
      };
    }
    function isNodeType(type) {
      return isType2(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement2) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement2);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement2);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path2 = this;
      let first = true;
      do {
        const {
          type,
          container
        } = path2;
        if (!first && (path2.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path2.key !== container.length - 1) {
          return false;
        }
      } while ((path2 = path2.parentPath) && !path2.isProgram() && !path2.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding2 = this.scope.getBinding(this.node.name);
      if (!binding2 || binding2.kind !== "module") return false;
      const path2 = binding2.path;
      const parent = path2.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path2.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path2.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path2.isImportSpecifier() && isIdentifier(path2.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node2 = this.node;
      if (node2.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node2.start, node2.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path2) {
      return path2.isProgram() ? path2 : (path2.parentPath.scope.getFunctionParent() || path2.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path2 = paths[i];
        if (isExecutionUncertain(path2.parent.type, path2.parentKey)) {
          return true;
        }
      }
      return false;
    }
    const SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base2, target, cache2) {
      const funcParent = {
        this: getOuterFunction(base2),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, funcParent.target, cache2);
      }
      const paths = {
        target: target.getAncestry(),
        this: base2.getAncestry()
      };
      if (paths.target.includes(base2)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path2 = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path2);
        if (commonIndex.target >= 0) {
          commonPath = path2;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base2, target, cache2) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding2 = target.scope.getBinding(target.node.id.name);
      if (!binding2.references) return "before";
      const referencePaths = binding2.referencePaths;
      let allStatus;
      for (const path2 of referencePaths) {
        const childOfFunction = !!path2.find((path3) => path3.node === target.node);
        if (childOfFunction) continue;
        if (path2.key !== "callee" || !path2.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base2, path2, cache2);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, target, cache2) {
      let nodeMap = cache2.get(base2.node);
      let cached;
      if (!nodeMap) {
        cache2.set(base2.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        const binding2 = this.scope.getBinding(this.node.name);
        if (!binding2) return;
        if (!binding2.constant) return;
        if (binding2.kind === "module") return;
        if (binding2.path !== this) {
          const ret = binding2.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding2 = this.scope.getBinding(this.node.name);
        if (!binding2) return false;
        return binding2.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path2) => {
        if (path2.isProgram({
          sourceType: "module"
        })) return true;
        if (path2.isClass()) return true;
        if (path2.isArrowFunctionExpression() && !path2.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path2.isFunction()) {
          body = path2.node.body;
        } else if (path2.isProgram()) {
          body = path2.node;
        } else {
          return false;
        }
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
        return false;
      });
      return !!strictParent;
    }
  })(introspection);
  return introspection;
}
var family = {};
var hasRequiredFamily;
function requireFamily() {
  if (hasRequiredFamily) return family;
  hasRequiredFamily = 1;
  Object.defineProperty(family, "__esModule", {
    value: true
  });
  family._getKey = _getKey;
  family._getPattern = _getPattern;
  family.get = get;
  family.getAllNextSiblings = getAllNextSiblings;
  family.getAllPrevSiblings = getAllPrevSiblings;
  family.getAssignmentIdentifiers = getAssignmentIdentifiers2;
  family.getBindingIdentifierPaths = getBindingIdentifierPaths;
  family.getBindingIdentifiers = getBindingIdentifiers2;
  family.getCompletionRecords = getCompletionRecords;
  family.getNextSibling = getNextSibling;
  family.getOpposite = getOpposite;
  family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  family.getOuterBindingIdentifiers = getOuterBindingIdentifiers2;
  family.getPrevSibling = getPrevSibling;
  family.getSibling = getSibling;
  var _index = requirePath();
  var _t2 = requireLib$5();
  const {
    getAssignmentIdentifiers: _getAssignmentIdentifiers,
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    numericLiteral,
    unaryExpression
  } = _t2;
  const NORMAL_COMPLETION = 0;
  const BREAK_COMPLETION = 1;
  function NormalCompletion(path2) {
    return {
      type: NORMAL_COMPLETION,
      path: path2
    };
  }
  function BreakCompletion(path2) {
    return {
      type: BREAK_COMPLETION,
      path: path2
    };
  }
  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
    return null;
  }
  function addCompletionRecords(path2, records, context2) {
    if (path2) {
      records.push(..._getCompletionRecords(path2, context2));
    }
    return records;
  }
  function completionRecordForSwitch(cases, records, context2) {
    let lastNormalCompletions = [];
    for (let i = 0; i < cases.length; i++) {
      const casePath = cases[i];
      const caseCompletions = _getCompletionRecords(casePath, context2);
      const normalCompletions = [];
      const breakCompletions = [];
      for (const c2 of caseCompletions) {
        if (c2.type === NORMAL_COMPLETION) {
          normalCompletions.push(c2);
        }
        if (c2.type === BREAK_COMPLETION) {
          breakCompletions.push(c2);
        }
      }
      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }
      records.push(...breakCompletions);
    }
    records.push(...lastNormalCompletions);
    return records;
  }
  function normalCompletionToBreak(completions) {
    completions.forEach((c2) => {
      c2.type = BREAK_COMPLETION;
    });
  }
  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c2) => {
      if (c2.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c2.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c2.path.remove();
        }
      }
    });
  }
  function getStatementListCompletion(paths, context2) {
    const completions = [];
    if (context2.canHaveBreak) {
      let lastNormalCompletions = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        const newContext = Object.assign({}, context2, {
          inCaseClause: false
        });
        if (path2.isBlockStatement() && (context2.inCaseClause || context2.shouldPopulateBreak)) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }
        const statementCompletions = _getCompletionRecords(path2, newContext);
        if (statementCompletions.length > 0 && statementCompletions.every((c2) => c2.type === BREAK_COMPLETION)) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every((c2) => c2.path.isBreakStatement({
            label: null
          }))) {
            normalCompletionToBreak(lastNormalCompletions);
            completions.push(...lastNormalCompletions);
            if (lastNormalCompletions.some((c2) => c2.path.isDeclaration())) {
              completions.push(...statementCompletions);
              if (!context2.shouldPreserveBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            if (!context2.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            }
          } else {
            completions.push(...statementCompletions);
            if (!context2.shouldPopulateBreak && !context2.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }
          break;
        }
        if (i === paths.length - 1) {
          completions.push(...statementCompletions);
        } else {
          lastNormalCompletions = [];
          for (let i2 = 0; i2 < statementCompletions.length; i2++) {
            const c2 = statementCompletions[i2];
            if (c2.type === BREAK_COMPLETION) {
              completions.push(c2);
            }
            if (c2.type === NORMAL_COMPLETION) {
              lastNormalCompletions.push(c2);
            }
          }
        }
      }
    } else if (paths.length) {
      for (let i = paths.length - 1; i >= 0; i--) {
        const pathCompletions = _getCompletionRecords(paths[i], context2);
        if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
          completions.push(...pathCompletions);
          break;
        }
      }
    }
    return completions;
  }
  function _getCompletionRecords(path2, context2) {
    let records = [];
    if (path2.isIfStatement()) {
      records = addCompletionRecords(path2.get("consequent"), records, context2);
      records = addCompletionRecords(path2.get("alternate"), records, context2);
    } else if (path2.isDoExpression() || path2.isFor() || path2.isWhile() || path2.isLabeledStatement()) {
      return addCompletionRecords(path2.get("body"), records, context2);
    } else if (path2.isProgram() || path2.isBlockStatement()) {
      return getStatementListCompletion(path2.get("body"), context2);
    } else if (path2.isFunction()) {
      return _getCompletionRecords(path2.get("body"), context2);
    } else if (path2.isTryStatement()) {
      records = addCompletionRecords(path2.get("block"), records, context2);
      records = addCompletionRecords(path2.get("handler"), records, context2);
    } else if (path2.isCatchClause()) {
      return addCompletionRecords(path2.get("body"), records, context2);
    } else if (path2.isSwitchStatement()) {
      return completionRecordForSwitch(path2.get("cases"), records, context2);
    } else if (path2.isSwitchCase()) {
      return getStatementListCompletion(path2.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true,
        shouldPreserveBreak: context2.shouldPreserveBreak
      });
    } else if (path2.isBreakStatement()) {
      records.push(BreakCompletion(path2));
    } else {
      records.push(NormalCompletion(path2));
    }
    return records;
  }
  function getCompletionRecords(shouldPreserveBreak = false) {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false,
      shouldPreserveBreak
    });
    return records.map((r) => r.path);
  }
  function getSibling(key) {
    return _index.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }
    return siblings;
  }
  function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }
    return siblings;
  }
  function get(key, context2 = true) {
    if (context2 === true) context2 = this.context;
    const parts = key.split(".");
    if (parts.length === 1) {
      return _getKey.call(this, key, context2);
    } else {
      return _getPattern.call(this, parts, context2);
    }
  }
  function _getKey(key, context2) {
    const node2 = this.node;
    const container = node2[key];
    if (Array.isArray(container)) {
      return container.map((_2, i) => {
        return _index.default.get({
          listKey: key,
          parentPath: this,
          parent: node2,
          container,
          key: i
        }).setContext(context2);
      });
    } else {
      return _index.default.get({
        parentPath: this,
        parent: node2,
        container: node2,
        key
      }).setContext(context2);
    }
  }
  function _getPattern(parts, context2) {
    let path2 = this;
    for (const part of parts) {
      if (part === ".") {
        path2 = path2.parentPath;
      } else {
        if (Array.isArray(path2)) {
          path2 = path2[part];
        } else {
          path2 = path2.get(part, context2);
        }
      }
    }
    return path2;
  }
  function getAssignmentIdentifiers2() {
    return _getAssignmentIdentifiers(this.node);
  }
  function getBindingIdentifiers2(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers2(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path2 = this;
    const search = [path2];
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      const keys = _getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");
        if (declaration.isDeclaration()) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);
          if (Array.isArray(child)) {
            search.push(...child);
          } else if (child.node) {
            search.push(child);
          }
        }
      }
    }
    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }
  return family;
}
var comments = {};
var hasRequiredComments;
function requireComments() {
  if (hasRequiredComments) return comments;
  hasRequiredComments = 1;
  Object.defineProperty(comments, "__esModule", {
    value: true
  });
  comments.addComment = addComment2;
  comments.addComments = addComments2;
  comments.shareCommentsWithSiblings = shareCommentsWithSiblings;
  var _t2 = requireLib$5();
  const {
    addComment: _addComment,
    addComments: _addComments
  } = _t2;
  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    const node2 = this.node;
    if (!node2) return;
    const trailing = node2.trailingComments;
    const leading = node2.leadingComments;
    if (!trailing && !leading) return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    if (hasPrev) {
      if (leading) {
        prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
      }
      if (trailing && !hasNext) prev.addComments("trailing", trailing);
    }
    if (hasNext) {
      if (trailing) {
        next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
      }
      if (leading && !hasPrev) next.addComments("leading", leading);
    }
  }
  function removeIfExisting(list, toRemove) {
    if (!(toRemove != null && toRemove.length)) return list;
    const set = new Set(toRemove);
    return list.filter((el2) => {
      return !set.has(el2);
    });
  }
  function addComment2(type, content, line) {
    _addComment(this.node, type, content, line);
  }
  function addComments2(type, comments2) {
    _addComments(this.node, type, comments2);
  }
  return comments;
}
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  Object.defineProperty(path, "__esModule", {
    value: true
  });
  path.default = path.SHOULD_STOP = path.SHOULD_SKIP = path.REMOVED = void 0;
  var virtualTypes2 = requireVirtualTypes();
  var _debug = requireBrowser();
  var _index = requireLib();
  var _index2 = requireScope();
  var _t2 = requireLib$5();
  var t = _t2;
  var cache2 = requireCache();
  var _generator = requireLib$4();
  var NodePath_ancestry = requireAncestry();
  var NodePath_inference = requireInference();
  var NodePath_replacement = requireReplacement();
  var NodePath_evaluation = requireEvaluation();
  var NodePath_conversion = requireConversion();
  var NodePath_introspection = requireIntrospection();
  var _context = requireContext();
  var NodePath_context = _context;
  var NodePath_removal = requireRemoval();
  var NodePath_modification = requireModification();
  var NodePath_family = requireFamily();
  var NodePath_comments = requireComments();
  var NodePath_virtual_types_validator = requireVirtualTypesValidator();
  const {
    validate: validate2
  } = _t2;
  const debug = _debug("babel");
  path.REMOVED = 1 << 0;
  path.SHOULD_STOP = 1 << 1;
  path.SHOULD_SKIP = 1 << 2;
  const NodePath_Final = path.default = class NodePath {
    constructor(hub2, parent) {
      this.contexts = [];
      this.state = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this._store = null;
      this.parent = parent;
      this.hub = hub2;
      this.data = null;
      this.context = null;
      this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(v2) {
      if (v2) this._traverseFlags |= 1;
      else this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(v2) {
      if (v2) this._traverseFlags |= 2;
      else this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(v2) {
      if (v2) this._traverseFlags |= 4;
      else this._traverseFlags &= -5;
    }
    static get({
      hub: hub2,
      parentPath,
      parent,
      container,
      listKey,
      key
    }) {
      if (!hub2 && parentPath) {
        hub2 = parentPath.hub;
      }
      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }
      const targetNode = container[key];
      const paths = cache2.getOrCreateCachedPaths(parent, parentPath);
      let path2 = paths.get(targetNode);
      if (!path2) {
        path2 = new NodePath(hub2, parent);
        if (targetNode) paths.set(targetNode, path2);
      }
      _context.setup.call(path2, parentPath, container, listKey, key);
      return path2;
    }
    getScope(scope2) {
      return this.isScope() ? new _index2.default(this) : scope2;
    }
    setData(key, val) {
      if (this.data == null) {
        this.data = /* @__PURE__ */ Object.create(null);
      }
      return this.data[key] = val;
    }
    getData(key, def) {
      if (this.data == null) {
        this.data = /* @__PURE__ */ Object.create(null);
      }
      let val = this.data[key];
      if (val === void 0 && def !== void 0) val = this.data[key] = def;
      return val;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(msg, Error2 = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error2);
    }
    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
    set(key, node2) {
      validate2(this.node, key, node2);
      this.node[key] = node2;
    }
    getPathLocation() {
      const parts = [];
      let path2 = this;
      do {
        let key = path2.key;
        if (path2.inList) key = `${path2.listKey}[${key}]`;
        parts.unshift(key);
      } while (path2 = path2.parentPath);
      return parts.join(".");
    }
    debug(message) {
      if (!debug.enabled) return;
      debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    toString() {
      return (0, _generator.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  };
  const methods2 = {
    findParent: NodePath_ancestry.findParent,
    find: NodePath_ancestry.find,
    getFunctionParent: NodePath_ancestry.getFunctionParent,
    getStatementParent: NodePath_ancestry.getStatementParent,
    getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
    getAncestry: NodePath_ancestry.getAncestry,
    isAncestor: NodePath_ancestry.isAncestor,
    isDescendant: NodePath_ancestry.isDescendant,
    inType: NodePath_ancestry.inType,
    getTypeAnnotation: NodePath_inference.getTypeAnnotation,
    isBaseType: NodePath_inference.isBaseType,
    couldBeBaseType: NodePath_inference.couldBeBaseType,
    baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
    isGenericType: NodePath_inference.isGenericType,
    replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
    replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
    replaceWith: NodePath_replacement.replaceWith,
    replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
    replaceInline: NodePath_replacement.replaceInline,
    evaluateTruthy: NodePath_evaluation.evaluateTruthy,
    evaluate: NodePath_evaluation.evaluate,
    toComputedKey: NodePath_conversion.toComputedKey,
    ensureBlock: NodePath_conversion.ensureBlock,
    unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
    arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
    splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
    ensureFunctionName: NodePath_conversion.ensureFunctionName,
    matchesPattern: NodePath_introspection.matchesPattern,
    isStatic: NodePath_introspection.isStatic,
    isNodeType: NodePath_introspection.isNodeType,
    canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: NodePath_introspection.isCompletionRecord,
    isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
    referencesImport: NodePath_introspection.referencesImport,
    getSource: NodePath_introspection.getSource,
    willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
    resolve: NodePath_introspection.resolve,
    isConstantExpression: NodePath_introspection.isConstantExpression,
    isInStrictMode: NodePath_introspection.isInStrictMode,
    isDenylisted: NodePath_context.isDenylisted,
    visit: NodePath_context.visit,
    skip: NodePath_context.skip,
    skipKey: NodePath_context.skipKey,
    stop: NodePath_context.stop,
    setContext: NodePath_context.setContext,
    requeue: NodePath_context.requeue,
    requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
    remove: NodePath_removal.remove,
    insertBefore: NodePath_modification.insertBefore,
    insertAfter: NodePath_modification.insertAfter,
    unshiftContainer: NodePath_modification.unshiftContainer,
    pushContainer: NodePath_modification.pushContainer,
    getOpposite: NodePath_family.getOpposite,
    getCompletionRecords: NodePath_family.getCompletionRecords,
    getSibling: NodePath_family.getSibling,
    getPrevSibling: NodePath_family.getPrevSibling,
    getNextSibling: NodePath_family.getNextSibling,
    getAllNextSiblings: NodePath_family.getAllNextSiblings,
    getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
    get: NodePath_family.get,
    getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
    getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
    getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
    addComment: NodePath_comments.addComment,
    addComments: NodePath_comments.addComments
  };
  Object.assign(NodePath_Final.prototype, methods2);
  {
    NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
    Object.assign(NodePath_Final.prototype, {
      has: NodePath_introspection[String("has")],
      is: NodePath_introspection[String("is")],
      isnt: NodePath_introspection[String("isnt")],
      equals: NodePath_introspection[String("equals")],
      hoist: NodePath_modification[String("hoist")],
      updateSiblingKeys: NodePath_modification.updateSiblingKeys,
      call: NodePath_context.call,
      isBlacklisted: NodePath_context[String("isBlacklisted")],
      setScope: NodePath_context.setScope,
      resync: NodePath_context.resync,
      popContext: NodePath_context.popContext,
      pushContext: NodePath_context.pushContext,
      setup: NodePath_context.setup,
      setKey: NodePath_context.setKey
    });
  }
  {
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    Object.assign(NodePath_Final.prototype, {
      _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
      _replaceWith: NodePath_replacement._replaceWith,
      _resolve: NodePath_introspection._resolve,
      _call: NodePath_context._call,
      _resyncParent: NodePath_context._resyncParent,
      _resyncKey: NodePath_context._resyncKey,
      _resyncList: NodePath_context._resyncList,
      _resyncRemoved: NodePath_context._resyncRemoved,
      _getQueueContexts: NodePath_context._getQueueContexts,
      _removeFromScope: NodePath_removal._removeFromScope,
      _callRemovalHooks: NodePath_removal._callRemovalHooks,
      _remove: NodePath_removal._remove,
      _markRemoved: NodePath_removal._markRemoved,
      _assertUnremoved: NodePath_removal._assertUnremoved,
      _containerInsert: NodePath_modification._containerInsert,
      _containerInsertBefore: NodePath_modification._containerInsertBefore,
      _containerInsertAfter: NodePath_modification._containerInsertAfter,
      _verifyNodeList: NodePath_modification._verifyNodeList,
      _getKey: NodePath_family._getKey,
      _getPattern: NodePath_family._getPattern
    });
  }
  for (const type of t.TYPES) {
    const typeKey = `is${type}`;
    const fn2 = t[typeKey];
    NodePath_Final.prototype[typeKey] = function(opts) {
      return fn2(this.node, opts);
    };
    NodePath_Final.prototype[`assert${type}`] = function(opts) {
      if (!fn2(this.node, opts)) {
        throw new TypeError(`Expected node path of type ${type}`);
      }
    };
  }
  Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
  for (const type of Object.keys(virtualTypes2)) {
    if (type[0] === "_") continue;
    if (!t.TYPES.includes(type)) t.TYPES.push(type);
  }
  return path;
}
var hasRequiredContext$1;
function requireContext$1() {
  if (hasRequiredContext$1) return context;
  hasRequiredContext$1 = 1;
  Object.defineProperty(context, "__esModule", {
    value: true
  });
  context.default = void 0;
  var _index = requirePath();
  var _t2 = requireLib$5();
  var _context = requireContext();
  const {
    VISITOR_KEYS
  } = _t2;
  class TraversalContext {
    constructor(scope2, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope2;
      this.state = state;
      this.opts = opts;
    }
    shouldVisit(node2) {
      const opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node2.type]) return true;
      const keys = VISITOR_KEYS[node2.type];
      if (!(keys != null && keys.length)) return false;
      for (const key of keys) {
        if (node2[key]) {
          return true;
        }
      }
      return false;
    }
    create(node2, container, key, listKey) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: node2,
        container,
        key,
        listKey
      });
    }
    maybeQueue(path2, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path2);
        } else {
          this.priorityQueue.push(path2);
        }
      }
    }
    visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      const queue = [];
      for (let key = 0; key < container.length; key++) {
        const node2 = container[key];
        if (node2 && this.shouldVisit(node2)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }
      return this.visitQueue(queue);
    }
    visitSingle(node2, key) {
      if (this.shouldVisit(node2[key])) {
        return this.visitQueue([this.create(node2, node2, key)]);
      } else {
        return false;
      }
    }
    visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      const visited = /* @__PURE__ */ new WeakSet();
      let stop = false;
      let visitIndex = 0;
      for (; visitIndex < queue.length; ) {
        const path2 = queue[visitIndex];
        visitIndex++;
        _context.resync.call(path2);
        if (path2.contexts.length === 0 || path2.contexts[path2.contexts.length - 1] !== this) {
          _context.pushContext.call(path2, this);
        }
        if (path2.key === null) continue;
        const {
          node: node2
        } = path2;
        if (visited.has(node2)) continue;
        if (node2) visited.add(node2);
        if (path2.visit()) {
          stop = true;
          break;
        }
        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }
      for (let i = 0; i < visitIndex; i++) {
        _context.popContext.call(queue[i]);
      }
      this.queue = null;
      return stop;
    }
    visit(node2, key) {
      const nodes = node2[key];
      if (!nodes) return false;
      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node2, key);
      } else {
        return this.visitSingle(node2, key);
      }
    }
  }
  context.default = TraversalContext;
  return context;
}
var hasRequiredTraverseNode;
function requireTraverseNode() {
  if (hasRequiredTraverseNode) return traverseNode;
  hasRequiredTraverseNode = 1;
  Object.defineProperty(traverseNode, "__esModule", {
    value: true
  });
  traverseNode.traverseNode = traverseNode$1;
  var _context = requireContext$1();
  requirePath();
  var _t2 = requireLib$5();
  requireContext();
  const {
    VISITOR_KEYS
  } = _t2;
  function traverseNode$1(node2, opts, scope2, state, path2, skipKeys, visitSelf) {
    const keys = VISITOR_KEYS[node2.type];
    if (!keys) return false;
    const context2 = new _context.default(scope2, opts, state, path2);
    if (visitSelf) {
      if (skipKeys != null && skipKeys[path2.parentKey]) return false;
      return context2.visitQueue([path2]);
    }
    for (const key of keys) {
      if (skipKeys != null && skipKeys[key]) continue;
      if (context2.visit(node2, key)) {
        return true;
      }
    }
    return false;
  }
  return traverseNode;
}
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context$1;
  hasRequiredContext = 1;
  Object.defineProperty(context$1, "__esModule", {
    value: true
  });
  context$1._call = _call;
  context$1._getQueueContexts = _getQueueContexts;
  context$1._resyncKey = _resyncKey;
  context$1._resyncList = _resyncList;
  context$1._resyncParent = _resyncParent;
  context$1._resyncRemoved = _resyncRemoved;
  context$1.call = call;
  context$1.isDenylisted = isDenylisted;
  context$1.popContext = popContext;
  context$1.pushContext = pushContext;
  context$1.requeue = requeue;
  context$1.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
  context$1.resync = resync;
  context$1.setContext = setContext;
  context$1.setKey = setKey;
  context$1.setScope = setScope;
  context$1.setup = setup;
  context$1.skip = skip;
  context$1.skipKey = skipKey;
  context$1.stop = stop;
  context$1.visit = visit;
  var _traverseNode = requireTraverseNode();
  var _index = requirePath();
  var _removal = requireRemoval();
  var t = requireLib$5();
  function call(key) {
    const opts = this.opts;
    this.debug(key);
    if (this.node) {
      if (_call.call(this, opts[key])) return true;
    }
    if (this.node) {
      var _opts$this$node$type;
      return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
    }
    return false;
  }
  function _call(fns) {
    if (!fns) return false;
    for (const fn2 of fns) {
      if (!fn2) continue;
      const node2 = this.node;
      if (!node2) return true;
      const ret = fn2.call(this.state, this, this.state);
      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
      }
      if (ret) {
        throw new Error(`Unexpected return value from visitor method ${fn2}`);
      }
      if (this.node !== node2) return true;
      if (this._traverseFlags > 0) return true;
    }
    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;
    const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist == null ? void 0 : denylist.includes(this.node.type);
  }
  {
    context$1.isBlacklisted = isDenylisted;
  }
  function restoreContext(path2, context2) {
    if (path2.context !== context2) {
      path2.context = context2;
      path2.state = context2.state;
      path2.opts = context2.opts;
    }
  }
  function visit() {
    var _this$opts$shouldSkip, _this$opts;
    if (!this.node) {
      return false;
    }
    if (this.isDenylisted()) {
      return false;
    }
    if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
      return false;
    }
    const currentContext = this.context;
    if (this.shouldSkip || call.call(this, "enter")) {
      this.debug("Skip...");
      return this.shouldStop;
    }
    restoreContext(this, currentContext);
    this.debug("Recursing into...");
    this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, "exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }
    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
  }
  function setScope() {
    var _this$opts2, _this$scope;
    if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
    let path2 = this.parentPath;
    if ((this.key === "key" || this.listKey === "decorators") && path2.isMethod() || this.key === "discriminant" && path2.isSwitchStatement()) {
      path2 = path2.parentPath;
    }
    let target;
    while (path2 && !target) {
      var _path$opts;
      if ((_path$opts = path2.opts) != null && _path$opts.noScope) return;
      target = path2.scope;
      path2 = path2.parentPath;
    }
    this.scope = this.getScope(target);
    (_this$scope = this.scope) == null || _this$scope.init();
  }
  function setContext(context2) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }
    this._traverseFlags = 0;
    if (context2) {
      this.context = context2;
      this.state = context2.state;
      this.opts = context2.opts;
    }
    setScope.call(this);
    return this;
  }
  function resync() {
    if (this.removed) return;
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) {
      return;
    }
    if (Array.isArray(this.container)) {
      for (let i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          setKey.call(this, i);
          return;
        }
      }
    } else {
      for (const key of Object.keys(this.container)) {
        if (this.container[key] === this.node) {
          setKey.call(this, key);
          return;
        }
      }
    }
    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      _removal._markRemoved.call(this);
    }
  }
  function popContext() {
    this.contexts.pop();
    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(void 0);
    }
  }
  function pushContext(context2) {
    this.contexts.push(context2);
    this.setContext(context2);
  }
  function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
  }
  function setKey(key) {
    var _this$node;
    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }
  function requeue(pathToQueue = this) {
    if (pathToQueue.removed) return;
    const contexts = this.contexts;
    for (const context2 of contexts) {
      context2.maybeQueue(pathToQueue);
    }
  }
  function requeueComputedKeyAndDecorators() {
    const {
      context: context2,
      node: node2
    } = this;
    if (!t.isPrivate(node2) && node2.computed) {
      context2.maybeQueue(this.get("key"));
    }
    if (node2.decorators) {
      for (const decorator of this.get("decorators")) {
        context2.maybeQueue(decorator);
      }
    }
  }
  function _getQueueContexts() {
    let path2 = this;
    let contexts = this.contexts;
    while (!contexts.length) {
      path2 = path2.parentPath;
      if (!path2) break;
      contexts = path2.contexts;
    }
    return contexts;
  }
  return context$1;
}
var hub = {};
var hasRequiredHub;
function requireHub() {
  if (hasRequiredHub) return hub;
  hasRequiredHub = 1;
  Object.defineProperty(hub, "__esModule", {
    value: true
  });
  hub.default = void 0;
  class Hub {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(node2, msg, Error2 = TypeError) {
      return new Error2(msg);
    }
  }
  hub.default = Hub;
  return hub;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$7;
  hasRequiredLib = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports$1, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports$1, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports$1.visitors = exports$1.default = void 0;
    requireContext();
    var visitors2 = requireVisitors();
    exports$1.visitors = visitors2;
    var _t2 = requireLib$5();
    var cache2 = requireCache();
    var _traverseNode = requireTraverseNode();
    var _index = requirePath();
    var _index2 = requireScope();
    var _hub = requireHub();
    const {
      VISITOR_KEYS,
      removeProperties: removeProperties2,
      traverseFast: traverseFast2
    } = _t2;
    function traverse2(parent, opts = {}, scope2, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope2) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors2.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope2, state, parentPath, void 0, visitSelf);
    }
    exports$1.default = traverse2;
    traverse2.visitors = visitors2;
    traverse2.verify = visitors2.verify;
    traverse2.explode = visitors2.explode;
    traverse2.cheap = function(node2, enter) {
      traverseFast2(node2, enter);
      return;
    };
    traverse2.node = function(node2, opts, scope2, state, path2, skipKeys) {
      (0, _traverseNode.traverseNode)(node2, opts, scope2, state, path2, skipKeys);
    };
    traverse2.clearNode = function(node2, opts) {
      removeProperties2(node2, opts);
    };
    traverse2.removeProperties = function(tree, opts) {
      traverseFast2(tree, traverse2.clearNode, opts);
      return tree;
    };
    traverse2.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      return traverseFast2(tree, function(node2) {
        if (denylistTypes != null && denylistTypes.includes(node2.type)) {
          return traverseFast2.skip;
        }
        if (node2.type === type) {
          return traverseFast2.stop;
        }
      });
    };
    traverse2.cache = cache2;
  })(lib$7);
  return lib$7;
}
var libExports = requireLib();
const traverse = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
function convertNode(node2, rawTemplate) {
  node2.innerComments = [];
  node2.extra = Object.assign(node2.extra ?? {}, {
    isGlimmerTemplate: true,
    template: rawTemplate
  });
}
function findCorrectCommentBlockIndex(comments2, start, end) {
  if (!comments2) {
    return -1;
  }
  return comments2.findIndex((comment) => {
    const { start: commentStart, end: commentEnd } = comment;
    return commentStart === start && commentEnd === end || commentStart === start + 1 && commentEnd === end - 1 || commentStart === start + 7 && commentEnd === end - 1;
  });
}
function convertAst(ast, data) {
  const { parser: parser2, templates } = data;
  traverse(ast, {
    enter(path2) {
      if (templates.length === 0) {
        return null;
      }
      const { node: node2 } = path2;
      switch (node2.type) {
        case "BlockStatement":
        case "ObjectExpression":
        case "StaticBlock": {
          const [start, end] = [parser2.locStart(node2), parser2.locEnd(node2)];
          const templateIndex = templates.findIndex((template) => {
            const { utf16Range } = template;
            if (utf16Range.start === start && utf16Range.end === end) {
              return true;
            }
            return node2.type === "ObjectExpression" && utf16Range.start === start - 1 && utf16Range.end === end + 1;
          });
          if (templateIndex === -1) {
            return null;
          }
          const rawTemplate = templates.splice(templateIndex, 1)[0];
          if (!rawTemplate) {
            throw new Error(
              "expected raw template because splice index came from findIndex"
            );
          }
          if (ast.comments && ast.comments.length > 0) {
            const commentBlockIndex = findCorrectCommentBlockIndex(
              ast.comments,
              start,
              end
            );
            if (commentBlockIndex !== void 0 && commentBlockIndex >= 0) {
              ast.comments.splice(commentBlockIndex, 1);
            }
          }
          convertNode(node2, rawTemplate);
        }
      }
      return null;
    }
  });
  if (templates.length > 0) {
    throw new Error(
      `failed to process all templates, ${templates.length} remaining`
    );
  }
}
const BufferMap = /* @__PURE__ */ new Map();
function getBuffer(string_) {
  let buffer2 = BufferMap.get(string_);
  if (!buffer2) {
    buffer2 = Buffer.from(string_);
    BufferMap.set(string_, buffer2);
  }
  return buffer2;
}
function parse$1(file, options2) {
  const preprocessor = new contentTag.Preprocessor();
  return preprocessor.parse(file, options2);
}
function sliceByteRange(string_, indexStart, indexEnd) {
  const buffer2 = getBuffer(string_);
  return buffer2.slice(indexStart, indexEnd).toString();
}
function preprocessTemplateRange(template, code) {
  const { start, end } = template.utf16Range;
  const after = code.slice(end);
  let prefix;
  let suffix;
  if (template.type === "class-member") {
    prefix = "static{/*";
    suffix = "*/}";
  } else {
    prefix = "{/*";
    suffix = "*/}";
    const nextToken = after.match(/\S+/);
    if (nextToken && (nextToken[0] === "as" || nextToken[0] === "satisfies")) {
      prefix = "(" + prefix;
      suffix = suffix + ")";
    }
  }
  const before = code.slice(0, start);
  const spaces = code.slice(start + prefix.length, end - suffix.length).replaceAll(/[^\n]/g, " ");
  return before + prefix + spaces + suffix + after;
}
function codeToGlimmerAst(code, filename) {
  const contentTags = parse$1(code, { filename });
  const templates = contentTags.map((contentTag2) => {
    const { contentRange, contents, range, type } = contentTag2;
    const utf16Range = {
      end: sliceByteRange(code, 0, range.endByte).length,
      start: sliceByteRange(code, 0, range.startByte).length
    };
    return {
      contentRange,
      contents,
      range,
      type,
      utf16Range
    };
  });
  return templates;
}
function preprocess(code, fileName) {
  const templates = codeToGlimmerAst(code, fileName);
  for (const template of templates) {
    code = preprocessTemplateRange(template, code);
  }
  return { code, templates };
}
function assert(message, condition) {
  if (!condition) {
    throw new Error(message);
  }
}
const parser = ta$1["babel-ts"];
async function parse(text, options2) {
  const { code, templates } = preprocess(text, options2.filepath);
  const ast = await parser.parse(code, options2);
  assert("expected ast", ast);
  convertAst(ast, { parser, templates });
  return ast;
}
const parsers = {
  [PARSER_NAME]: {
    ...parser,
    astFormat: PRINTER_NAME,
    parse
  }
};
var fa = Object.defineProperty;
var _n = (e, t) => {
  for (var r in t) fa(e, r, { get: t[r], enumerable: true });
};
var pa = {};
_n(pa, { languages: () => Qm, options: () => aa, printers: () => Km });
var $s = [{ name: "JavaScript", type: "programming", aceMode: "javascript", extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".start.frag", ".end.frag", ".wxs"], filenames: ["Jakefile", "start.frag", "end.frag"], tmScope: "source.js", aliases: ["js", "node"], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], linguistLanguageId: 183 }, { name: "Flow", type: "programming", aceMode: "javascript", extensions: [".js.flow"], filenames: [], tmScope: "source.js", aliases: [], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], linguistLanguageId: 183 }, { name: "JSX", type: "programming", aceMode: "javascript", extensions: [".jsx"], filenames: void 0, tmScope: "source.js.jsx", aliases: void 0, codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript", linguistLanguageId: 183 }, { name: "TypeScript", type: "programming", aceMode: "typescript", extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aliases: ["ts"], codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", interpreters: ["bun", "deno", "ts-node", "tsx"], parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], linguistLanguageId: 378 }, { name: "TSX", type: "programming", aceMode: "tsx", extensions: [".tsx"], tmScope: "source.tsx", codemirrorMode: "jsx", codemirrorMimeType: "text/typescript-jsx", group: "TypeScript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"], linguistLanguageId: 94901924 }];
var Ys = {};
_n(Ys, { canAttachComment: () => Qi, embed: () => yu, features: () => Ym, getVisitorKeys: () => Lr, handleComments: () => ms, hasPrettierIgnore: () => Qt, insertPragma: () => bu, isBlockComment: () => ne, isGap: () => Zi, massageAstNode: () => gi, print: () => qs, printComment: () => rs, printPrettierIgnored: () => qs, willPrintOwnComments: () => zi });
var Jt = (e, t) => (r, n, ...s) => r | 1 && n == null ? void 0 : (t.call(n) ?? n[e]).apply(n, s);
var ya = String.prototype.replaceAll ?? function(e, t) {
  return e.global ? this.replace(e, t) : this.split(e).join(t);
}, Ea = Jt("replaceAll", function() {
  if (typeof this == "string") return ya;
}), J = Ea;
function Fa(e) {
  return this[e < 0 ? this.length + e : e];
}
var da = Jt("at", function() {
  if (Array.isArray(this) || typeof this == "string") return Fa;
}), _ = da;
function Ca(e) {
  return e !== null && typeof e == "object";
}
var Ks = Ca;
function* Aa(e, t) {
  let { getVisitorKeys: r, filter: n = () => true } = t, s = (i) => Ks(i) && n(i);
  for (let i of r(e)) {
    let u = e[i];
    if (Array.isArray(u)) for (let o of u) s(o) && (yield o);
    else s(u) && (yield u);
  }
}
function* Ta(e, t) {
  let r = [e];
  for (let n = 0; n < r.length; n++) {
    let s = r[n];
    for (let i of Aa(s, t)) yield i, r.push(i);
  }
}
function Qs(e, { getVisitorKeys: t, predicate: r }) {
  for (let n of Ta(e, { getVisitorKeys: t })) if (r(n)) return true;
  return false;
}
var zs = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function Nn(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function vn(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e >= 94192 && e <= 94198 || e >= 94208 && e <= 101589 || e >= 101631 && e <= 101662 || e >= 101760 && e <= 101874 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128728 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129674 || e >= 129678 && e <= 129734 || e === 129736 || e >= 129741 && e <= 129756 || e >= 129759 && e <= 129770 || e >= 129775 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var Zs = "©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌨⏏⏱⏲⏸⏹⏺▪▫▶◀◻◼☀☁☂☃☄☎☑☘☝☠☢☣☦☪☮☯☸☹☺♀♂♟♠♣♥♦♨♻♾⚒⚔⚕⚖⚗⚙⚛⚜⚠⚧⚰⚱⛈⛏⛑⛓⛩⛱⛷⛸⛹✂✈✉✌✍✏✒✔✖✝✡✳✴❄❇❣❤➡⤴⤵⬅⬆⬇";
var xa = /[^\x20-\x7F]/u, ga = new Set(Zs);
function ha(e) {
  if (!e) return 0;
  if (!xa.test(e)) return e.length;
  e = e.replace(zs(), (r) => ga.has(r) ? " " : "  ");
  let t = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || n >= 65024 && n <= 65039 || (t += Nn(n) || vn(n) ? 2 : 1);
  }
  return t;
}
var it2 = ha;
function Pr(e) {
  return (t, r, n) => {
    let s = !!n?.backwards;
    if (r === false) return false;
    let { length: i } = t, u = r;
    for (; u >= 0 && u < i; ) {
      let o = t.charAt(u);
      if (e instanceof RegExp) {
        if (!e.test(o)) return u;
      } else if (!e.includes(o)) return u;
      s ? u-- : u++;
    }
    return u === -1 || u === i ? u : false;
  };
}
var Qe = Pr(" 	"), ei = Pr(",; 	"), ti = Pr(/[^\n\r]/u);
var ri = (e) => e === `
` || e === "\r" || e === "\u2028" || e === "\u2029";
function Sa(e, t, r) {
  let n = !!r?.backwards;
  if (t === false) return false;
  let s = e.charAt(t);
  if (n) {
    if (e.charAt(t - 1) === "\r" && s === `
`) return t - 2;
    if (ri(s)) return t - 1;
  } else {
    if (s === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (ri(s)) return t + 1;
  }
  return t;
}
var ze = Sa;
function Ba(e, t, r = {}) {
  let n = Qe(e, r.backwards ? t - 1 : t, r), s = ze(e, n, r);
  return n !== s;
}
var Q2 = Ba;
function ba(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
  }
  return t;
}
var Gt = ba;
function Pa(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? ti(e, t) : t;
}
var Wt = Pa;
function ka(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = ei(e, n), n = Gt(e, n), n = Qe(e, n);
  return n = Wt(e, n), n = ze(e, n), n !== false && Q2(e, n);
}
var qt = ka;
function Ia(e) {
  return Array.isArray(e) && e.length > 0;
}
var j = Ia;
var La = () => {
}, Pe = La;
function Oa(e, t) {
  let r = t === true || t === "'" ? "'" : '"', n = r === "'" ? '"' : "'", s = 0, i = 0;
  for (let u of e) u === r ? s++ : u === n && i++;
  return s > i ? n : r;
}
var kr = Oa;
var wa = /\\(["'\\])|(["'])/gu;
function Ma(e, t) {
  let r = t === '"' ? "'" : '"', n = J(0, e, wa, (s, i, u) => i ? i === r ? r : s : u === t ? "\\" + u : u);
  return t + n + t;
}
var ni = Ma;
function _a(e, t) {
  let r = e.slice(1, -1), n = t.parser === "json" || t.parser === "jsonc" || t.parser === "json5" && t.quoteProps === "preserve" && !t.singleQuote ? '"' : t.__isInHtmlAttribute ? "'" : kr(r, t.singleQuote);
  return e.charAt(0) === n ? e : ni(r, n);
}
var ut = _a;
var si = (e) => Number.isInteger(e) && e >= 0;
function O(e) {
  let t = e.range?.[0] ?? e.start, r = (e.declaration?.decorators ?? e.decorators)?.[0];
  return r ? Math.min(O(r), t) : t;
}
function k(e) {
  return e.range?.[1] ?? e.end;
}
function St(e, t) {
  let r = O(e);
  return si(r) && r === O(t);
}
function Na(e, t) {
  let r = k(e);
  return si(r) && r === k(t);
}
function ii(e, t) {
  return St(e, t) && Na(e, t);
}
var cr = null;
function lr(e) {
  if (cr !== null && typeof cr.property) {
    let t = cr;
    return cr = lr.prototype = null, t;
  }
  return cr = lr.prototype = e ?? /* @__PURE__ */ Object.create(null), new lr();
}
var va = 10;
for (let e = 0; e <= va; e++) lr();
function Rn(e) {
  return lr(e);
}
function ja(e, t = "type") {
  Rn(e);
  function r(n) {
    let s = n[t], i = e[s];
    if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: n });
    return i;
  }
  return r;
}
var Ir = ja;
var ui = { AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], AnyTypeAnnotation: [], ArgumentPlaceholder: [], ArrayExpression: ["elements"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrayTypeAnnotation: ["elementType"], ArrowFunctionExpression: ["typeParameters", "params", "predicate", "returnType", "body"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], AwaitExpression: ["argument"], BigIntLiteral: [], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], BinaryExpression: ["left", "right"], BindExpression: ["object", "callee"], BlockStatement: ["directives", "body"], BooleanLiteral: [], BooleanLiteralTypeAnnotation: [], BooleanTypeAnnotation: [], BreakStatement: ["label"], CallExpression: ["callee", "typeArguments", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassAccessorProperty: ["decorators", "key", "typeAnnotation", "value"], ClassBody: ["body"], ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeArguments", "mixins", "implements", "body", "superTypeParameters"], ClassExpression: ["decorators", "id", "typeParameters", "superClass", "superTypeArguments", "mixins", "implements", "body", "superTypeParameters"], ClassImplements: ["id", "typeParameters"], ClassMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ClassPrivateMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ClassPrivateProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalExpression: ["test", "consequent", "alternate"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], ContinueStatement: ["label"], DebuggerStatement: [], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclaredPredicate: ["value"], DeclareEnum: ["id", "body"], DeclareExportAllDeclaration: ["source", "attributes"], DeclareExportDeclaration: ["declaration", "specifiers", "source", "attributes"], DeclareFunction: ["id", "predicate"], DeclareHook: ["id"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareNamespace: ["id", "body"], DeclareOpaqueType: ["id", "typeParameters", "supertype", "lowerBound", "upperBound"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareVariable: ["id"], Decorator: ["expression"], Directive: ["value"], DirectiveLiteral: [], DoExpression: ["body"], DoWhileStatement: ["body", "test"], EmptyStatement: [], EmptyTypeAnnotation: [], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], EnumBooleanBody: ["members"], EnumBooleanMember: ["id", "init"], EnumDeclaration: ["id", "body"], EnumDefaultedMember: ["id"], EnumNumberBody: ["members"], EnumNumberMember: ["id", "init"], EnumStringBody: ["members"], EnumStringMember: ["id", "init"], EnumSymbolBody: ["members"], ExistsTypeAnnotation: [], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportDefaultSpecifier: ["exported"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportNamespaceSpecifier: ["exported"], ExportSpecifier: ["local", "exported"], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionExpression: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionTypeAnnotation: ["typeParameters", "this", "params", "rest", "returnType"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], ImportAttribute: ["key", "value"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportExpression: ["source", "options"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], IndexedAccessType: ["objectType", "indexType"], InferredPredicate: [], InferTypeAnnotation: ["typeParameter"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceExtends: ["id", "typeParameters"], InterfaceTypeAnnotation: ["extends", "body"], InterpreterDirective: [], IntersectionTypeAnnotation: ["types"], JsExpressionRoot: ["node"], JsonRoot: ["node"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXClosingFragment: [], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "typeArguments", "attributes"], JSXOpeningFragment: [], JSXSpreadAttribute: ["argument"], JSXSpreadChild: ["expression"], JSXText: [], KeyofTypeAnnotation: ["argument"], LabeledStatement: ["label", "body"], Literal: [], LogicalExpression: ["left", "right"], MatchArrayPattern: ["elements", "rest"], MatchAsPattern: ["pattern", "target"], MatchBindingPattern: ["id"], MatchExpression: ["argument", "cases"], MatchExpressionCase: ["pattern", "body", "guard"], MatchIdentifierPattern: ["id"], MatchLiteralPattern: ["literal"], MatchMemberPattern: ["base", "property"], MatchObjectPattern: ["properties", "rest"], MatchObjectPatternProperty: ["key", "pattern"], MatchOrPattern: ["patterns"], MatchRestPattern: ["argument"], MatchStatement: ["argument", "cases"], MatchStatementCase: ["pattern", "body", "guard"], MatchUnaryPattern: ["argument"], MatchWildcardPattern: [], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["decorators", "key", "value"], MixedTypeAnnotation: [], ModuleExpression: ["body"], NeverTypeAnnotation: [], NewExpression: ["callee", "typeArguments", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxAs: ["key", "alias"], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKey: [], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGPipeExpression: ["left", "right", "arguments"], NGRoot: ["node"], NullableTypeAnnotation: ["typeAnnotation"], NullLiteral: [], NullLiteralTypeAnnotation: [], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], NumericLiteral: [], ObjectExpression: ["properties"], ObjectMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], ObjectProperty: ["decorators", "key", "value"], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["variance", "id", "key", "value"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype", "lowerBound", "upperBound"], OptionalCallExpression: ["callee", "typeArguments", "arguments"], OptionalIndexedAccessType: ["objectType", "indexType"], OptionalMemberExpression: ["object", "property"], ParenthesizedExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], PipelineTopicExpression: ["expression"], Placeholder: [], PrivateIdentifier: [], PrivateName: ["id"], Program: ["directives", "body"], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], QualifiedTypeIdentifier: ["qualification", "id"], QualifiedTypeofIdentifier: ["qualification", "id"], RegExpLiteral: [], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SatisfiesExpression: ["expression", "typeAnnotation"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], StaticBlock: ["body"], StringLiteral: [], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], Super: [], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], SymbolTypeAnnotation: [], TaggedTemplateExpression: ["tag", "typeArguments", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThisTypeAnnotation: [], ThrowStatement: ["argument"], TopicReference: [], TryStatement: ["block", "handler", "finalizer"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAnyKeyword: [], TSArrayType: ["elementType"], TSAsExpression: ["expression", "typeAnnotation"], TSAsyncKeyword: [], TSBigIntKeyword: [], TSBooleanKeyword: [], TSCallSignatureDeclaration: ["typeParameters", "params", "returnType"], TSClassImplements: ["expression", "typeArguments"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSConstructorType: ["typeParameters", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "params", "returnType"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareKeyword: [], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSEnumDeclaration: ["id", "body"], TSEnumMember: ["id", "initializer"], TSExportAssignment: ["expression"], TSExportKeyword: [], TSExternalModuleReference: ["expression"], TSFunctionType: ["typeParameters", "params", "returnType"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSImportType: ["options", "qualifier", "typeArguments", "source"], TSIndexedAccessType: ["objectType", "indexType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSInferType: ["typeParameter"], TSInstantiationExpression: ["expression", "typeArguments"], TSInterfaceBody: ["body"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceHeritage: ["expression", "typeArguments"], TSIntersectionType: ["types"], TSIntrinsicKeyword: [], TSJSDocAllType: [], TSJSDocNonNullableType: ["typeAnnotation"], TSJSDocNullableType: ["typeAnnotation"], TSJSDocUnknownType: [], TSLiteralType: ["literal"], TSMappedType: ["key", "constraint", "nameType", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "params", "returnType"], TSModuleBlock: ["body"], TSModuleDeclaration: ["id", "body"], TSNamedTupleMember: ["label", "elementType"], TSNamespaceExportDeclaration: ["id"], TSNeverKeyword: [], TSNonNullExpression: ["expression"], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSOptionalType: ["typeAnnotation"], TSParameterProperty: ["parameter", "decorators"], TSParenthesizedType: ["typeAnnotation"], TSPrivateKeyword: [], TSPropertySignature: ["key", "typeAnnotation"], TSProtectedKeyword: [], TSPublicKeyword: [], TSQualifiedName: ["left", "right"], TSReadonlyKeyword: [], TSRestType: ["typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSStaticKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSTemplateLiteralType: ["quasis", "types"], TSThisType: [], TSTupleType: ["elementTypes"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSTypeAnnotation: ["typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSTypeLiteral: ["members"], TSTypeOperator: ["typeAnnotation"], TSTypeParameter: ["name", "constraint", "default"], TSTypeParameterDeclaration: ["params"], TSTypeParameterInstantiation: ["params"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeArguments"], TSTypeReference: ["typeName", "typeArguments"], TSUndefinedKeyword: [], TSUnionType: ["types"], TSUnknownKeyword: [], TSVoidKeyword: [], TupleTypeAnnotation: ["types", "elementTypes"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeOperator: ["typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], TypePredicate: ["parameterName", "typeAnnotation"], UnaryExpression: ["argument"], UndefinedTypeAnnotation: [], UnionTypeAnnotation: ["types"], UnknownTypeAnnotation: [], UpdateExpression: ["argument"], V8IntrinsicIdentifier: [], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], Variance: [], VoidPattern: [], VoidTypeAnnotation: [], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] };
var Ra = Ir(ui), Lr = Ra;
function Ja(e) {
  let t = new Set(e);
  return (r) => t.has(r?.type);
}
var P = Ja;
function Ga(e) {
  return e.extra?.raw ?? e.raw;
}
var pe2 = Ga;
var Wa = P(["Block", "CommentBlock", "MultiLine"]), ne = Wa;
var qa = P(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), Or = qa;
var Ya = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), Ct = Ya;
function Ua(e, t) {
  let r = t.split(".");
  for (let n = r.length - 1; n >= 0; n--) {
    let s = r[n];
    if (n === 0) return e.type === "Identifier" && e.name === s;
    if (n === 1 && e.type === "MetaProperty" && e.property.type === "Identifier" && e.property.name === s) {
      e = e.meta;
      continue;
    }
    if (e.type === "MemberExpression" && !e.optional && !e.computed && e.property.type === "Identifier" && e.property.name === s) {
      e = e.object;
      continue;
    }
    return false;
  }
}
function Ha(e, t) {
  return t.some((r) => Ua(e, r));
}
var Bt = Ha;
function Xa({ type: e }) {
  return e.startsWith("TS") && e.endsWith("Keyword");
}
var wr = Xa;
function Va({ node: e, parent: t }) {
  return e?.type !== "EmptyStatement" ? false : t.type === "IfStatement" ? t.consequent === e || t.alternate === e : t.type === "DoWhileStatement" || t.type === "ForInStatement" || t.type === "ForOfStatement" || t.type === "ForStatement" || t.type === "LabeledStatement" || t.type === "WithStatement" || t.type === "WhileStatement" ? t.body === e : false;
}
var bt = Va;
function Dr(e, t) {
  return t(e) || Qs(e, { getVisitorKeys: Lr, predicate: t });
}
function Ut(e) {
  return e.type === "AssignmentExpression" || e.type === "BinaryExpression" || e.type === "LogicalExpression" || e.type === "NGPipeExpression" || e.type === "ConditionalExpression" || M(e) || R(e) || e.type === "SequenceExpression" || e.type === "TaggedTemplateExpression" || e.type === "BindExpression" || e.type === "UpdateExpression" && !e.prefix || Ce2(e) || e.type === "TSNonNullExpression" || e.type === "ChainExpression";
}
function pi(e) {
  return e.expressions ? e.expressions[0] : e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression;
}
function _r(e) {
  if (e.expressions) return ["expressions", 0];
  if (e.left) return ["left"];
  if (e.test) return ["test"];
  if (e.object) return ["object"];
  if (e.callee) return ["callee"];
  if (e.tag) return ["tag"];
  if (e.argument) return ["argument"];
  if (e.expression) return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var ci = P(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), G = P(["ArrayExpression"]), se = P(["ObjectExpression"]);
function li(e) {
  return e.type === "LogicalExpression" && e.operator === "??";
}
function Fe(e) {
  return e.type === "NumericLiteral" || e.type === "Literal" && typeof e.value == "number";
}
function mi(e) {
  return e.type === "BooleanLiteral" || e.type === "Literal" && typeof e.value == "boolean";
}
function Yn(e) {
  return e.type === "UnaryExpression" && (e.operator === "+" || e.operator === "-") && Fe(e.argument);
}
function H(e) {
  return !!(e && (e.type === "StringLiteral" || e.type === "Literal" && typeof e.value == "string"));
}
function Un(e) {
  return e.type === "RegExpLiteral" || e.type === "Literal" && !!e.regex;
}
var Nr = P(["Literal", "BooleanLiteral", "BigIntLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), $a = P(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier"]), We2 = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), Yt = P(["FunctionExpression", "ArrowFunctionExpression"]);
function Ka(e) {
  return e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement";
}
function Jn(e) {
  return M(e) && e.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(e.callee.name);
}
var Y2 = P(["JSXElement", "JSXFragment"]);
function lt2(e) {
  return e.method && e.kind === "init" || e.kind === "get" || e.kind === "set";
}
function vr(e) {
  return (e.type === "ObjectTypeProperty" || e.type === "ObjectTypeInternalSlot") && !e.static && !e.method && e.kind !== "get" && e.kind !== "set" && e.value.type === "FunctionTypeAnnotation";
}
function Di(e) {
  return (e.type === "TypeAnnotation" || e.type === "TSTypeAnnotation") && e.typeAnnotation.type === "FunctionTypeAnnotation" && !e.static && !St(e, e.typeAnnotation);
}
var Ae = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function At(e) {
  return R(e) || e.type === "BindExpression" && !!e.object;
}
var Qa = P(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function Ht(e) {
  return wr(e) || Or(e) || Qa(e) || e.type === "GenericTypeAnnotation" && !e.typeParameters || e.type === "TSTypeReference" && !e.typeArguments;
}
function za(e) {
  return e.type === "Identifier" && (e.name === "beforeEach" || e.name === "beforeAll" || e.name === "afterEach" || e.name === "afterAll");
}
var Za = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.fixme", "test.step", "test.describe", "test.describe.only", "test.describe.skip", "test.describe.fixme", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function ep(e) {
  return Bt(e, Za);
}
function Pt(e, t) {
  if (e?.type !== "CallExpression" || e.optional) return false;
  let r = ce(e);
  if (r.length === 1) {
    if (Jn(e) && Pt(t)) return Yt(r[0]);
    if (za(e.callee)) return Jn(r[0]);
  } else if ((r.length === 2 || r.length === 3) && (r[0].type === "TemplateLiteral" || H(r[0])) && ep(e.callee)) return r[2] && !Fe(r[2]) ? false : (r.length === 2 ? Yt(r[1]) : Ka(r[1]) && $(r[1]).length <= 1) || Jn(r[1]);
  return false;
}
var fi = (e) => (t) => (t?.type === "ChainExpression" && (t = t.expression), e(t)), M = fi(P(["CallExpression", "OptionalCallExpression"])), R = fi(P(["MemberExpression", "OptionalMemberExpression"]));
function Hn(e, t = 5) {
  return yi(e, t) <= t;
}
function yi(e, t) {
  let r = 0;
  for (let n in e) {
    let s = e[n];
    if (s && typeof s == "object" && typeof s.type == "string" && (r++, r += yi(s, t - r)), r > t) return r;
  }
  return r;
}
var tp = 0.25;
function fr(e, t) {
  let { printWidth: r } = t;
  if (C(e)) return false;
  let n = r * tp;
  if (e.type === "ThisExpression" || e.type === "Identifier" && e.name.length <= n || Yn(e) && !C(e.argument)) return true;
  let s = e.type === "Literal" && "regex" in e && e.regex.pattern || e.type === "RegExpLiteral" && e.pattern;
  return s ? s.length <= n : H(e) ? ut(pe2(e), t).length <= n : e.type === "TemplateLiteral" ? e.expressions.length === 0 && e.quasis[0].value.raw.length <= n && !e.quasis[0].value.raw.includes(`
`) : e.type === "UnaryExpression" ? fr(e.argument, { printWidth: r }) : e.type === "CallExpression" && e.arguments.length === 0 && e.callee.type === "Identifier" ? e.callee.name.length <= n - 2 : Nr(e);
}
function de(e, t) {
  return Y2(t) ? It(t) : C(t, T.Leading, (r) => Q2(e, k(r)));
}
function oi(e) {
  return e.quasis.some((t) => t.value.raw.includes(`
`));
}
function jr(e, t) {
  return (e.type === "TemplateLiteral" && oi(e) || e.type === "TaggedTemplateExpression" && oi(e.quasi)) && !Q2(t, O(e), { backwards: true });
}
function Rr(e) {
  if (!C(e)) return false;
  let t = _(0, Ze2(e, T.Dangling), -1);
  return t && !ne(t);
}
function Ei(e) {
  if (e.length <= 1) return false;
  let t = 0;
  for (let r of e) if (Yt(r)) {
    if (t += 1, t > 1) return true;
  } else if (M(r)) {
    for (let n of ce(r)) if (Yt(n)) return true;
  }
  return false;
}
function Jr(e) {
  let { node: t, parent: r, key: n } = e;
  return n === "callee" && M(t) && M(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
}
var rp = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function je(e, t = 2) {
  if (t <= 0) return false;
  if (e.type === "ChainExpression" || e.type === "TSNonNullExpression") return je(e.expression, t);
  let r = (n) => je(n, t - 1);
  if (Un(e)) return it2(e.pattern ?? e.regex.pattern) <= 5;
  if (Nr(e) || $a(e) || e.type === "ArgumentPlaceholder") return true;
  if (e.type === "TemplateLiteral") return e.quasis.every((n) => !n.value.raw.includes(`
`)) && e.expressions.every(r);
  if (se(e)) return e.properties.every((n) => !n.computed && (n.shorthand || n.value && r(n.value)));
  if (G(e)) return e.elements.every((n) => n === null || r(n));
  if (mt(e)) {
    if (e.type === "ImportExpression" || je(e.callee, t)) {
      let n = ce(e);
      return n.length <= t && n.every(r);
    }
    return false;
  }
  return R(e) ? je(e.object, t) && je(e.property, t) : e.type === "UnaryExpression" && rp.has(e.operator) || e.type === "UpdateExpression" ? je(e.argument, t) : false;
}
function ie(e, t = "es5") {
  return e.trailingComma === "es5" && t === "es5" || e.trailingComma === "all" && (t === "all" || t === "es5");
}
function fe2(e, t) {
  switch (e.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return fe2(e.left, t);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return fe2(e.object, t);
    case "TaggedTemplateExpression":
      return e.tag.type === "FunctionExpression" ? false : fe2(e.tag, t);
    case "CallExpression":
    case "OptionalCallExpression":
      return e.callee.type === "FunctionExpression" ? false : fe2(e.callee, t);
    case "ConditionalExpression":
      return fe2(e.test, t);
    case "UpdateExpression":
      return !e.prefix && fe2(e.argument, t);
    case "BindExpression":
      return e.object && fe2(e.object, t);
    case "SequenceExpression":
      return fe2(e.expressions[0], t);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return fe2(e.expression, t);
    default:
      return t(e);
  }
}
var ai = { "==": true, "!=": true, "===": true, "!==": true }, Mr = { "*": true, "/": true, "%": true }, qn = { ">>": true, ">>>": true, "<<": true };
function yr(e, t) {
  return !(mr(t) !== mr(e) || e === "**" || ai[e] && ai[t] || t === "%" && Mr[e] || e === "%" && Mr[t] || t !== e && Mr[t] && Mr[e] || qn[e] && qn[t]);
}
var np = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((e, t) => e.map((r) => [r, t])));
function mr(e) {
  return np.get(e);
}
function Fi(e) {
  return !!qn[e] || e === "|" || e === "^" || e === "&";
}
function di(e) {
  if (e.rest) return true;
  let t = $(e);
  return _(0, t, -1)?.type === "RestElement";
}
var Gn = /* @__PURE__ */ new WeakMap();
function $(e) {
  if (Gn.has(e)) return Gn.get(e);
  let t = [];
  return e.this && t.push(e.this), t.push(...e.params), e.rest && t.push(e.rest), Gn.set(e, t), t;
}
function Ci(e, t) {
  let { node: r } = e, n = 0, s = () => t(e, n++);
  r.this && e.call(s, "this"), e.each(s, "params"), r.rest && e.call(s, "rest");
}
var Wn = /* @__PURE__ */ new WeakMap();
function ce(e) {
  if (Wn.has(e)) return Wn.get(e);
  if (e.type === "ChainExpression") return ce(e.expression);
  let t;
  return e.type === "ImportExpression" || e.type === "TSImportType" ? (t = [e.source], e.options && t.push(e.options)) : e.type === "TSExternalModuleReference" ? t = [e.expression] : t = e.arguments, Wn.set(e, t), t;
}
function Xt(e, t) {
  let { node: r } = e;
  if (r.type === "ChainExpression") return e.call(() => Xt(e, t), "expression");
  r.type === "ImportExpression" || r.type === "TSImportType" ? (e.call(() => t(e, 0), "source"), r.options && e.call(() => t(e, 1), "options")) : r.type === "TSExternalModuleReference" ? e.call(() => t(e, 0), "expression") : e.each(t, "arguments");
}
function Xn(e, t) {
  let r = [];
  if (e.type === "ChainExpression" && (e = e.expression, r.push("expression")), e.type === "ImportExpression" || e.type === "TSImportType") {
    if (t === 0 || t === (e.options ? -2 : -1)) return [...r, "source"];
    if (e.options && (t === 1 || t === -1)) return [...r, "options"];
    throw new RangeError("Invalid argument index");
  } else if (e.type === "TSExternalModuleReference") {
    if (t === 0 || t === -1) return [...r, "expression"];
  } else if (t < 0 && (t = e.arguments.length + t), t >= 0 && t < e.arguments.length) return [...r, "arguments", t];
  throw new RangeError("Invalid argument index");
}
function kt(e) {
  return e.value.trim() === "prettier-ignore" && !e.unignore;
}
function It(e) {
  return e?.prettierIgnore || C(e, T.PrettierIgnore);
}
var T = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Ai = (e, t) => {
  if (typeof e == "function" && (t = e, e = 0), e || t) return (r, n, s) => !(e & T.Leading && !r.leading || e & T.Trailing && !r.trailing || e & T.Dangling && (r.leading || r.trailing) || e & T.Block && !ne(r) || e & T.Line && !Ct(r) || e & T.First && n !== 0 || e & T.Last && n !== s.length - 1 || e & T.PrettierIgnore && !kt(r) || t && !t(r));
};
function C(e, t, r) {
  if (!j(e?.comments)) return false;
  let n = Ai(t, r);
  return n ? e.comments.some(n) : true;
}
function Ze2(e, t, r) {
  if (!Array.isArray(e?.comments)) return [];
  let n = Ai(t, r);
  return n ? e.comments.filter(n) : e.comments;
}
var ue2 = (e, { originalText: t }) => qt(t, k(e));
function mt(e) {
  return M(e) || e.type === "NewExpression" || e.type === "ImportExpression";
}
function ke(e) {
  return e && (e.type === "ObjectProperty" || e.type === "Property" && !lt2(e));
}
var Ce2 = P(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), Ie = P(["TSUnionType", "UnionTypeAnnotation"]), Lt = P(["TSIntersectionType", "IntersectionTypeAnnotation"]), qe = P(["TSConditionalType", "ConditionalTypeAnnotation"]), Ti = (e) => e?.type === "TSAsExpression" && e.typeAnnotation.type === "TSTypeReference" && e.typeAnnotation.typeName.type === "Identifier" && e.typeAnnotation.typeName.name === "const", Er = P(["TSTypeAliasDeclaration", "TypeAlias"]);
var sp = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Vt = (e) => {
  for (let t of e.quasis) delete t.value;
};
function xi(e, t, r) {
  if (e.type === "Program" && delete t.sourceType, (e.type === "BigIntLiteral" || e.type === "Literal") && e.bigint && (t.bigint = e.bigint.toLowerCase()), e.type === "EmptyStatement" && !bt({ node: e, parent: r }) || e.type === "JSXText" || e.type === "JSXExpressionContainer" && (e.expression.type === "Literal" || e.expression.type === "StringLiteral") && e.expression.value === " ") return null;
  if ((e.type === "Property" || e.type === "ObjectProperty" || e.type === "MethodDefinition" || e.type === "ClassProperty" || e.type === "ClassMethod" || e.type === "PropertyDefinition" || e.type === "TSDeclareMethod" || e.type === "TSPropertySignature" || e.type === "ObjectTypeProperty" || e.type === "ImportAttribute") && e.key && !e.computed) {
    let { key: s } = e;
    H(s) || Fe(s) ? t.key = String(s.value) : s.type === "Identifier" && (t.key = s.name);
  }
  if (e.type === "JSXElement" && e.openingElement.name.name === "style" && e.openingElement.attributes.some((s) => s.type === "JSXAttribute" && s.name.name === "jsx")) for (let { type: s, expression: i } of t.children) s === "JSXExpressionContainer" && i.type === "TemplateLiteral" && Vt(i);
  e.type === "JSXAttribute" && e.name.name === "css" && e.value.type === "JSXExpressionContainer" && e.value.expression.type === "TemplateLiteral" && Vt(t.value.expression), e.type === "JSXAttribute" && e.value?.type === "Literal" && /["']|&quot;|&apos;/u.test(e.value.value) && (t.value.value = J(0, e.value.value, /["']|&quot;|&apos;/gu, '"'));
  let n = e.expression || e.callee;
  if (e.type === "Decorator" && n.type === "CallExpression" && n.callee.name === "Component" && n.arguments.length === 1) {
    let s = e.expression.arguments[0].properties;
    for (let [i, u] of t.expression.arguments[0].properties.entries()) switch (s[i].key.name) {
      case "styles":
        G(u.value) && Vt(u.value.elements[0]);
        break;
      case "template":
        u.value.type === "TemplateLiteral" && Vt(u.value);
        break;
    }
  }
  e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql" || e.tag.name === "css" || e.tag.name === "md" || e.tag.name === "markdown" || e.tag.name === "html") || e.tag.type === "CallExpression") && Vt(t.quasi), e.type === "TemplateLiteral" && Vt(t), e.type === "ChainExpression" && e.expression.type === "TSNonNullExpression" && (t.type = "TSNonNullExpression", t.expression.type = "ChainExpression");
}
xi.ignoredProperties = sp;
var gi = xi;
var Ye = "string", ge = "array", et2 = "cursor", Ue = "indent", He2 = "align", tt2 = "trim", ye = "group", Le = "fill", he = "if-break", Xe2 = "indent-if-break", Ve = "line-suffix", Re = "line-suffix-boundary", le = "line", Se2 = "label", Oe = "break-parent", Gr = /* @__PURE__ */ new Set([et2, Ue, He2, tt2, ye, Le, he, Xe2, Ve, Re, le, Se2, Oe]);
function ip(e) {
  if (typeof e == "string") return Ye;
  if (Array.isArray(e)) return ge;
  if (!e) return;
  let { type: t } = e;
  if (Gr.has(t)) return t;
}
var Je2 = ip;
var up = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function op(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (Je2(e)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let n = up([...Gr].map((s) => `'${s}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
var Vn = class extends Error {
  name = "InvalidDocError";
  constructor(t) {
    super(op(t)), this.doc = t;
  }
}, Tt = Vn;
var hi = {};
function ap(e, t, r, n) {
  let s = [e];
  for (; s.length > 0; ) {
    let i = s.pop();
    if (i === hi) {
      r(s.pop());
      continue;
    }
    r && s.push(i, hi);
    let u = Je2(i);
    if (!u) throw new Tt(i);
    if (t?.(i) !== false) switch (u) {
      case ge:
      case Le: {
        let o = u === ge ? i : i.parts;
        for (let a2 = o.length, p = a2 - 1; p >= 0; --p) s.push(o[p]);
        break;
      }
      case he:
        s.push(i.flatContents, i.breakContents);
        break;
      case ye:
        if (n && i.expandedStates) for (let o = i.expandedStates.length, a2 = o - 1; a2 >= 0; --a2) s.push(i.expandedStates[a2]);
        else s.push(i.contents);
        break;
      case He2:
      case Ue:
      case Xe2:
      case Se2:
      case Ve:
        s.push(i.contents);
        break;
      case Ye:
      case et2:
      case tt2:
      case Re:
      case le:
      case Oe:
        break;
      default:
        throw new Tt(i);
    }
  }
}
var Wr = ap;
function Dt(e, t) {
  if (typeof e == "string") return t(e);
  let r = /* @__PURE__ */ new Map();
  return n(e);
  function n(i) {
    if (r.has(i)) return r.get(i);
    let u = s(i);
    return r.set(i, u), u;
  }
  function s(i) {
    switch (Je2(i)) {
      case ge:
        return t(i.map(n));
      case Le:
        return t({ ...i, parts: i.parts.map(n) });
      case he:
        return t({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
      case ye: {
        let { expandedStates: u, contents: o } = i;
        return u ? (u = u.map(n), o = u[0]) : o = n(o), t({ ...i, contents: o, expandedStates: u });
      }
      case He2:
      case Ue:
      case Xe2:
      case Se2:
      case Ve:
        return t({ ...i, contents: n(i.contents) });
      case Ye:
      case et2:
      case tt2:
      case Re:
      case le:
      case Oe:
        return t(i);
      default:
        throw new Tt(i);
    }
  }
}
function Bi(e, t, r) {
  let n = r, s = false;
  function i(u) {
    if (s) return false;
    let o = t(u);
    o !== void 0 && (s = true, n = o);
  }
  return Wr(e, i), n;
}
function pp(e) {
  if (e.type === ye && e.break || e.type === le && e.hard || e.type === Oe) return true;
}
function re(e) {
  return Bi(e, pp, false);
}
function Si(e) {
  if (e.length > 0) {
    let t = _(0, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function bi(e) {
  let t = /* @__PURE__ */ new Set(), r = [];
  function n(i) {
    if (i.type === Oe && Si(r), i.type === ye) {
      if (r.push(i), t.has(i)) return false;
      t.add(i);
    }
  }
  function s(i) {
    i.type === ye && r.pop().break && Si(r);
  }
  Wr(e, n, s, true);
}
function cp(e) {
  return e.type === le && !e.hard ? e.soft ? "" : " " : e.type === he ? e.flatContents : e;
}
function Ot(e) {
  return Dt(e, cp);
}
function lp(e) {
  switch (Je2(e)) {
    case Le:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case ye:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === ye && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case He2:
    case Ue:
    case Xe2:
    case Ve:
      if (!e.contents) return "";
      break;
    case he:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case ge: {
      let t = [];
      for (let r of e) {
        if (!r) continue;
        let [n, ...s] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof _(0, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...s);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case Ye:
    case et2:
    case tt2:
    case Re:
    case le:
    case Se2:
    case Oe:
      break;
    default:
      throw new Tt(e);
  }
  return e;
}
function $t(e) {
  return Dt(e, (t) => lp(t));
}
function Ge2(e, t = qr) {
  return Dt(e, (r) => typeof r == "string" ? I(t, r.split(`
`)) : r);
}
function mp(e) {
  if (e.type === le) return true;
}
function Pi(e) {
  return Bi(e, mp, false);
}
function Fr(e, t) {
  return e.type === Se2 ? { ...e, contents: t(e.contents) } : t(e);
}
function ki(e) {
  let t = true;
  return Wr(e, (r) => {
    switch (Je2(r)) {
      case Ye:
        if (r === "") break;
      case tt2:
      case Re:
      case le:
      case Oe:
        return t = false, false;
    }
  }), t;
}
var Yr = Pe;
function m(e) {
  return { type: Ue, contents: e };
}
function Te(e, t) {
  return { type: He2, contents: t, n: e };
}
function Oi(e) {
  return Te(Number.NEGATIVE_INFINITY, e);
}
function Ur(e) {
  return Te(-1, e);
}
function wi(e, t, r) {
  let n = e;
  if (t > 0) {
    for (let s = 0; s < Math.floor(t / r); ++s) n = m(n);
    n = Te(t % r, n), n = Te(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
var Be = { type: Oe };
var dr = { type: et2 };
function Hr(e) {
  return { type: Le, parts: e };
}
function c(e, t = {}) {
  return Yr(t.expandedStates), { type: ye, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function rt2(e, t) {
  return c(e[0], { ...t, expandedStates: e });
}
function b(e, t = "", r = {}) {
  return { type: he, breakContents: e, flatContents: t, groupId: r.groupId };
}
function ft(e, t) {
  return { type: Xe2, contents: e, groupId: t.groupId, negate: t.negate };
}
function I(e, t) {
  let r = [];
  for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
  return r;
}
function ot2(e, t) {
  return e ? { type: Se2, label: e, contents: t } : t;
}
var A = { type: le }, f = { type: le, soft: true }, $n = { type: le, hard: true }, y = [$n, Be], Dp = { type: le, hard: true, literal: true }, qr = [Dp, Be];
function Kn(e) {
  return { type: Ve, contents: e };
}
var we2 = { type: Re };
function Mi(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var fp = { type: 0 }, yp = { type: 1 }, Qn = { value: "", length: 0, queue: [], get root() {
  return Qn;
} };
function _i(e, t, r) {
  let n = t.type === 1 ? e.queue.slice(0, -1) : [...e.queue, t], s = "", i = 0, u = 0, o = 0;
  for (let F2 of n) switch (F2.type) {
    case 0:
      D2(), r.useTabs ? a2(1) : p(r.tabWidth);
      break;
    case 3: {
      let { string: B2 } = F2;
      D2(), s += B2, i += B2.length;
      break;
    }
    case 2: {
      let { width: B2 } = F2;
      u += 1, o += B2;
      break;
    }
    default:
      throw new Error(`Unexpected indent comment '${F2.type}'.`);
  }
  return E(), { ...e, value: s, length: i, queue: n };
  function a2(F2) {
    s += "	".repeat(F2), i += r.tabWidth * F2;
  }
  function p(F2) {
    s += " ".repeat(F2), i += F2;
  }
  function D2() {
    r.useTabs ? l2() : E();
  }
  function l2() {
    u > 0 && a2(u), d2();
  }
  function E() {
    o > 0 && p(o), d2();
  }
  function d2() {
    u = 0, o = 0;
  }
}
function Ni(e, t, r) {
  if (!t) return e;
  if (t.type === "root") return { ...e, root: e };
  if (t === Number.NEGATIVE_INFINITY) return e.root;
  let n;
  return typeof t == "number" ? t < 0 ? n = yp : n = { type: 2, width: t } : n = { type: 3, string: t }, _i(e, n, r);
}
function vi(e, t) {
  return _i(e, fp, t);
}
function Ep(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--) {
    let n = e[r];
    if (n === " " || n === "	") t++;
    else break;
  }
  return t;
}
function zn(e) {
  let t = Ep(e);
  return { text: t === 0 ? e : e.slice(0, e.length - t), count: t };
}
var Me = Symbol("MODE_BREAK"), at2 = Symbol("MODE_FLAT"), Zn = Symbol("DOC_FILL_PRINTED_LENGTH");
function Xr(e, t, r, n, s, i) {
  if (r === Number.POSITIVE_INFINITY) return true;
  let u = t.length, o = false, a2 = [e], p = "";
  for (; r >= 0; ) {
    if (a2.length === 0) {
      if (u === 0) return true;
      a2.push(t[--u]);
      continue;
    }
    let { mode: D2, doc: l2 } = a2.pop(), E = Je2(l2);
    switch (E) {
      case Ye:
        l2 && (o && (p += " ", r -= 1, o = false), p += l2, r -= it2(l2));
        break;
      case ge:
      case Le: {
        let d2 = E === ge ? l2 : l2.parts, F2 = l2[Zn] ?? 0;
        for (let B2 = d2.length - 1; B2 >= F2; B2--) a2.push({ mode: D2, doc: d2[B2] });
        break;
      }
      case Ue:
      case He2:
      case Xe2:
      case Se2:
        a2.push({ mode: D2, doc: l2.contents });
        break;
      case tt2: {
        let { text: d2, count: F2 } = zn(p);
        p = d2, r += F2;
        break;
      }
      case ye: {
        if (i && l2.break) return false;
        let d2 = l2.break ? Me : D2, F2 = l2.expandedStates && d2 === Me ? _(0, l2.expandedStates, -1) : l2.contents;
        a2.push({ mode: d2, doc: F2 });
        break;
      }
      case he: {
        let F2 = (l2.groupId ? s[l2.groupId] || at2 : D2) === Me ? l2.breakContents : l2.flatContents;
        F2 && a2.push({ mode: D2, doc: F2 });
        break;
      }
      case le:
        if (D2 === Me || l2.hard) return true;
        l2.soft || (o = true);
        break;
      case Ve:
        n = true;
        break;
      case Re:
        if (n) return false;
        break;
    }
  }
  return false;
}
function es(e, t) {
  let r = /* @__PURE__ */ Object.create(null), n = t.printWidth, s = Mi(t.endOfLine), i = 0, u = [{ indent: Qn, mode: Me, doc: e }], o = "", a2 = false, p = [], D2 = [], l2 = [], E = [], d2 = 0;
  for (bi(e); u.length > 0; ) {
    let { indent: g2, mode: x2, doc: h } = u.pop();
    switch (Je2(h)) {
      case Ye: {
        let N = s !== `
` ? J(0, h, `
`, s) : h;
        N && (o += N, u.length > 0 && (i += it2(N)));
        break;
      }
      case ge:
        for (let N = h.length - 1; N >= 0; N--) u.push({ indent: g2, mode: x2, doc: h[N] });
        break;
      case et2:
        if (D2.length >= 2) throw new Error("There are too many 'cursor' in doc.");
        D2.push(d2 + o.length);
        break;
      case Ue:
        u.push({ indent: vi(g2, t), mode: x2, doc: h.contents });
        break;
      case He2:
        u.push({ indent: Ni(g2, h.n, t), mode: x2, doc: h.contents });
        break;
      case tt2:
        L2();
        break;
      case ye:
        switch (x2) {
          case at2:
            if (!a2) {
              u.push({ indent: g2, mode: h.break ? Me : at2, doc: h.contents });
              break;
            }
          case Me: {
            a2 = false;
            let N = { indent: g2, mode: at2, doc: h.contents }, W2 = n - i, De2 = p.length > 0;
            if (!h.break && Xr(N, u, W2, De2, r)) u.push(N);
            else if (h.expandedStates) {
              let q2 = _(0, h.expandedStates, -1);
              if (h.break) {
                u.push({ indent: g2, mode: Me, doc: q2 });
                break;
              } else for (let K2 = 1; K2 < h.expandedStates.length + 1; K2++) if (K2 >= h.expandedStates.length) {
                u.push({ indent: g2, mode: Me, doc: q2 });
                break;
              } else {
                let Z2 = h.expandedStates[K2], be2 = { indent: g2, mode: at2, doc: Z2 };
                if (Xr(be2, u, W2, De2, r)) {
                  u.push(be2);
                  break;
                }
              }
            } else u.push({ indent: g2, mode: Me, doc: h.contents });
            break;
          }
        }
        h.id && (r[h.id] = _(0, u, -1).mode);
        break;
      case Le: {
        let N = n - i, W2 = h[Zn] ?? 0, { parts: De2 } = h, q2 = De2.length - W2;
        if (q2 === 0) break;
        let K2 = De2[W2 + 0], Z2 = De2[W2 + 1], be2 = { indent: g2, mode: at2, doc: K2 }, nt2 = { indent: g2, mode: Me, doc: K2 }, w = Xr(be2, [], N, p.length > 0, r, true);
        if (q2 === 1) {
          w ? u.push(be2) : u.push(nt2);
          break;
        }
        let te2 = { indent: g2, mode: at2, doc: Z2 }, ae2 = { indent: g2, mode: Me, doc: Z2 };
        if (q2 === 2) {
          w ? u.push(te2, be2) : u.push(ae2, nt2);
          break;
        }
        let st2 = De2[W2 + 2], ht2 = { indent: g2, mode: x2, doc: { ...h, [Zn]: W2 + 2 } }, Sr2 = Xr({ indent: g2, mode: at2, doc: [K2, Z2, st2] }, [], N, p.length > 0, r, true);
        u.push(ht2), Sr2 ? u.push(te2, be2) : w ? u.push(ae2, be2) : u.push(ae2, nt2);
        break;
      }
      case he:
      case Xe2: {
        let N = h.groupId ? r[h.groupId] : x2;
        if (N === Me) {
          let W2 = h.type === he ? h.breakContents : h.negate ? h.contents : m(h.contents);
          W2 && u.push({ indent: g2, mode: x2, doc: W2 });
        }
        if (N === at2) {
          let W2 = h.type === he ? h.flatContents : h.negate ? m(h.contents) : h.contents;
          W2 && u.push({ indent: g2, mode: x2, doc: W2 });
        }
        break;
      }
      case Ve:
        p.push({ indent: g2, mode: x2, doc: h.contents });
        break;
      case Re:
        p.length > 0 && u.push({ indent: g2, mode: x2, doc: $n });
        break;
      case le:
        switch (x2) {
          case at2:
            if (h.hard) a2 = true;
            else {
              h.soft || (o += " ", i += 1);
              break;
            }
          case Me:
            if (p.length > 0) {
              u.push({ indent: g2, mode: x2, doc: h }, ...p.reverse()), p.length = 0;
              break;
            }
            h.literal ? (o += s, i = 0, g2.root && (g2.root.value && (o += g2.root.value), i = g2.root.length)) : (L2(), o += s + g2.value, i = g2.length);
            break;
        }
        break;
      case Se2:
        u.push({ indent: g2, mode: x2, doc: h.contents });
        break;
      case Oe:
        break;
      default:
        throw new Tt(h);
    }
    u.length === 0 && p.length > 0 && (u.push(...p.reverse()), p.length = 0);
  }
  let F2 = l2.join("") + o, B2 = [...E, ...D2];
  if (B2.length !== 2) return { formatted: F2 };
  let S2 = B2[0];
  return { formatted: F2, cursorNodeStart: S2, cursorNodeText: F2.slice(S2, _(0, B2, -1)) };
  function L2() {
    let { text: g2, count: x2 } = zn(o);
    g2 && (l2.push(g2), d2 += g2.length), o = "", i -= x2, D2.length > 0 && (E.push(...D2.map((h) => Math.min(h, d2))), D2.length = 0);
  }
}
function Fp(e) {
  if (!ne(e)) return false;
  let t = `*${e.value}*`.split(`
`);
  return t.length > 1 && t.every((r) => r.trimStart()[0] === "*");
}
var ts = /* @__PURE__ */ new WeakMap();
function dp(e) {
  return ts.has(e) || ts.set(e, Fp(e)), ts.get(e);
}
var ji = dp;
function rs(e, t) {
  let r = e.node;
  if (Ct(r)) return t.originalText.slice(O(r), k(r)).trimEnd();
  if (ji(r)) return Cp(r);
  if (ne(r)) return ["/*", Ge2(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function Cp(e) {
  let t = e.value.split(`
`);
  return ["/*", I(y, t.map((r, n) => n === 0 ? r.trimEnd() : " " + (n < t.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
function Ap(e) {
  let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "…"), t + (r ? " " + r : "");
}
function ns(e, t) {
  (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = Ap(e);
}
function ee(e, t) {
  t.leading = true, t.trailing = false, ns(e, t);
}
function _e(e, t, r) {
  t.leading = false, t.trailing = false, r && (t.marker = r), ns(e, t);
}
function X2(e, t) {
  t.leading = false, t.trailing = true, ns(e, t);
}
function Tp(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = Qe(e, n), n = Gt(e, n), n = Wt(e, n), n = ze(e, n);
  return n;
}
var pt = Tp;
function xp(e, t) {
  let r = pt(e, t);
  return r === false ? "" : e.charAt(r);
}
var Ne = xp;
function gp(e, t, r) {
  for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
  return false;
}
var oe = gp;
var ss = /* @__PURE__ */ new WeakMap();
function hp(e) {
  return ss.has(e) || ss.set(e, ne(e) && e.value[0] === "*" && /@(?:type|satisfies)\b/u.test(e.value)), ss.get(e);
}
var Vr = hp;
var us = (e, t) => Ct(e) || !oe(t, O(e), k(e));
function Sp(e) {
  return [Xi, Ji, Yi, Np, kp, os, as, Ri, Gi, Gp, jp, Rp, cs, Hi, Wp, Wi, Ui, ps, Ip, $p, Vi, ls].some((t) => t(e));
}
function Bp(e) {
  return [Pp, Yi, Ji, Hi, os, as, Ri, Gi, Ui, vp, Jp, cs, Up, ps, Xp, Vp, Kp, Vi, zp, Qp, ls].some((t) => t(e));
}
function bp(e) {
  return [Xi, os, as, _p, Wi, cs, Mp, wp, ps, Hp, ls].some((t) => t(e));
}
function wt(e, t) {
  let r = (e.body || e.properties).find(({ type: n }) => n !== "EmptyStatement");
  r ? ee(r, t) : _e(e, t);
}
function is(e, t) {
  e.type === "BlockStatement" ? wt(e, t) : ee(e, t);
}
function Pp({ comment: e, followingNode: t }) {
  return t && Vr(e) ? (ee(t, e), true) : false;
}
function os({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
  if (r?.type !== "IfStatement" || !n) return false;
  if (Ne(s, k(e)) === ")") return X2(t, e), true;
  if (n.type === "BlockStatement" && n === r.consequent && O(e) >= k(t) && k(e) <= O(n)) return ee(n, e), true;
  if (t === r.consequent && n === r.alternate) {
    let u = pt(s, k(r.consequent));
    if (n.type === "BlockStatement" && O(e) >= u && k(e) <= O(n)) return ee(n, e), true;
    if (O(e) < u || r.alternate.type === "BlockStatement") return t.type === "BlockStatement" ? (X2(t, e), true) : us(e, s) && !oe(s, O(t), O(e)) ? (X2(t, e), true) : (_e(r, e), true);
  }
  return n.type === "BlockStatement" ? (wt(n, e), true) : n.type === "IfStatement" ? (is(n.consequent, e), true) : r.consequent === n ? (ee(n, e), true) : false;
}
function as({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
  return r?.type !== "WhileStatement" || !n ? false : Ne(s, k(e)) === ")" ? (X2(t, e), true) : n.type === "BlockStatement" ? (wt(n, e), true) : r.body === n ? (ee(n, e), true) : false;
}
function Ri({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
  return r?.type !== "TryStatement" && r?.type !== "CatchClause" || !n ? false : r.type === "CatchClause" && t ? (X2(t, e), true) : n.type === "BlockStatement" ? (wt(n, e), true) : n.type === "TryStatement" ? (is(n.finalizer, e), true) : n.type === "CatchClause" ? (is(n.body, e), true) : false;
}
function kp({ comment: e, enclosingNode: t, followingNode: r }) {
  return R(t) && r?.type === "Identifier" ? (ee(t, e), true) : false;
}
function Ip({ comment: e, enclosingNode: t, followingNode: r, options: n }) {
  return !n.experimentalTernaries || !(t?.type === "ConditionalExpression" || qe(t)) ? false : r?.type === "ConditionalExpression" || qe(r) ? (_e(t, e), true) : false;
}
function Ji({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s, options: i }) {
  let u = t && !oe(s, k(t), O(e));
  return (!t || !u) && (r?.type === "ConditionalExpression" || qe(r)) && n ? i.experimentalTernaries && r.alternate === n && !(ne(e) && !oe(i.originalText, O(e), k(e))) ? (_e(r, e), true) : (ee(n, e), true) : false;
}
var Lp = P(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function Gi({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
  if (Lp(r)) {
    if (j(r.decorators) && n?.type !== "Decorator") return X2(_(0, r.decorators, -1), e), true;
    if (r.body && n === r.body) return wt(r.body, e), true;
    if (n) {
      if (r.superClass && n === r.superClass && t && (t === r.id || t === r.typeParameters)) return X2(t, e), true;
      for (let s of ["implements", "extends", "mixins"]) if (r[s] && n === r[s][0]) return t && (t === r.id || t === r.typeParameters || t === r.superClass) ? X2(t, e) : _e(r, e, s), true;
    }
  }
  return false;
}
var Op = P(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "TSParameterProperty"]);
function Wi({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
  return r && t && Ne(n, k(e)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && t.type === "Identifier" && r.key === t && Ne(n, k(t)) !== ":" ? (X2(t, e), true) : t?.type === "Decorator" && Op(r) && (Ct(e) || e.placement === "ownLine") ? (X2(t, e), true) : false;
}
var qi = P(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function wp({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
  return Ne(n, k(e)) !== "(" ? false : t && qi(r) ? (X2(t, e), true) : false;
}
function Mp({ comment: e, enclosingNode: t, text: r }) {
  if (t?.type !== "ArrowFunctionExpression") return false;
  let n = pt(r, k(e));
  return n !== false && r.slice(n, n + 2) === "=>" ? (_e(t, e), true) : false;
}
function _p({ comment: e, enclosingNode: t, text: r }) {
  return Ne(r, k(e)) !== ")" ? false : t && ($i(t) && $(t).length === 0 || mt(t) && ce(t).length === 0) ? (_e(t, e), true) : (t?.type === "MethodDefinition" || t?.type === "TSAbstractMethodDefinition") && $(t.value).length === 0 ? (_e(t.value, e), true) : false;
}
function Np({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
  return t?.type === "ComponentTypeParameter" && (r?.type === "DeclareComponent" || r?.type === "ComponentTypeAnnotation") && n?.type !== "ComponentTypeParameter" ? (X2(t, e), true) : (t?.type === "ComponentParameter" || t?.type === "RestElement") && r?.type === "ComponentDeclaration" && Ne(s, k(e)) === ")" ? (X2(t, e), true) : false;
}
function Yi({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
  return t?.type === "FunctionTypeParam" && r?.type === "FunctionTypeAnnotation" && n?.type !== "FunctionTypeParam" ? (X2(t, e), true) : (t?.type === "Identifier" || t?.type === "AssignmentPattern" || t?.type === "ObjectPattern" || t?.type === "ArrayPattern" || t?.type === "RestElement" || t?.type === "TSParameterProperty") && $i(r) && Ne(s, k(e)) === ")" ? (X2(t, e), true) : !ne(e) && n?.type === "BlockStatement" && qi(r) && (r.type === "MethodDefinition" ? r.value.body : r.body) === n && pt(s, k(e)) === O(n) ? (wt(n, e), true) : false;
}
function Ui({ comment: e, enclosingNode: t }) {
  return t?.type === "LabeledStatement" ? (ee(t, e), true) : false;
}
function ps({ comment: e, enclosingNode: t }) {
  return (t?.type === "ContinueStatement" || t?.type === "BreakStatement") && !t.label ? (X2(t, e), true) : false;
}
function vp({ comment: e, precedingNode: t, enclosingNode: r }) {
  return M(r) && t && r.callee === t && r.arguments.length > 0 ? (ee(r.arguments[0], e), true) : false;
}
function jp({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
  return Ie(r) ? (kt(e) && (n.prettierIgnore = true, e.unignore = true), t ? (X2(t, e), true) : false) : (Ie(n) && kt(e) && (n.types[0].prettierIgnore = true, e.unignore = true), false);
}
function Rp({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
  return r && r.type === "MatchOrPattern" ? (kt(e) && (n.prettierIgnore = true, e.unignore = true), t ? (X2(t, e), true) : false) : (n && n.type === "MatchOrPattern" && kt(e) && (n.types[0].prettierIgnore = true, e.unignore = true), false);
}
function Jp({ comment: e, enclosingNode: t }) {
  return ke(t) ? (ee(t, e), true) : false;
}
function cs({ comment: e, enclosingNode: t, ast: r, isLastComment: n }) {
  return r?.body?.length === 0 ? (n ? _e(r, e) : ee(r, e), true) : t?.type === "Program" && t.body.length === 0 && !j(t.directives) ? (n ? _e(t, e) : ee(t, e), true) : false;
}
function Gp({ comment: e, enclosingNode: t, followingNode: r }) {
  return (t?.type === "ForInStatement" || t?.type === "ForOfStatement") && r !== t.body ? (ee(t, e), true) : false;
}
function Hi({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
  if (r?.type === "ImportSpecifier" || r?.type === "ExportSpecifier") return ee(r, e), true;
  let s = t?.type === "ImportSpecifier" && r?.type === "ImportDeclaration", i = t?.type === "ExportSpecifier" && r?.type === "ExportNamedDeclaration";
  return (s || i) && Q2(n, k(e)) ? (X2(t, e), true) : false;
}
function Wp({ comment: e, enclosingNode: t }) {
  return t?.type === "AssignmentPattern" ? (ee(t, e), true) : false;
}
var qp = P(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Yp = P(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function Up({ comment: e, enclosingNode: t, followingNode: r }) {
  return qp(t) && r && (Yp(r) || ne(e)) ? (ee(r, e), true) : false;
}
function Hp({ comment: e, enclosingNode: t, precedingNode: r, followingNode: n, text: s }) {
  return !n && (t?.type === "TSMethodSignature" || t?.type === "TSDeclareFunction" || t?.type === "TSAbstractMethodDefinition") && (!r || r !== t.returnType) && Ne(s, k(e)) === ";" ? (X2(t, e), true) : false;
}
function Xi({ comment: e, enclosingNode: t, followingNode: r }) {
  if (kt(e) && t?.type === "TSMappedType" && r === t.key) return t.prettierIgnore = true, e.unignore = true, true;
}
function Vi({ comment: e, precedingNode: t, enclosingNode: r }) {
  if (r?.type === "TSMappedType" && !t) return _e(r, e), true;
}
function Xp({ comment: e, enclosingNode: t, followingNode: r }) {
  return !t || t.type !== "SwitchCase" || t.test || !r || r !== t.consequent[0] ? false : (r.type === "BlockStatement" && Ct(e) ? wt(r, e) : _e(t, e), true);
}
function Vp({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
  return Ie(t) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !n || Lt(r)) ? (X2(_(0, t.types, -1), e), true) : false;
}
function $p({ comment: e, enclosingNode: t, precedingNode: r, followingNode: n }) {
  if ((t?.type === "ObjectPattern" || t?.type === "ArrayPattern") && n?.type === "TSTypeAnnotation") return r ? X2(r, e) : _e(t, e), true;
}
function Kp({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
  return !n && r?.type === "UnaryExpression" && (t?.type === "LogicalExpression" || t?.type === "BinaryExpression") && oe(s, O(r.argument), O(t.right)) && us(e, s) && !oe(s, O(t.right), O(e)) ? (X2(t.right, e), true) : false;
}
function Qp({ enclosingNode: e, followingNode: t, comment: r }) {
  if (e && (e.type === "TSPropertySignature" || e.type === "ObjectTypeProperty") && (Ie(t) || Lt(t))) return ee(t, r), true;
}
function ls({ enclosingNode: e, precedingNode: t, followingNode: r, comment: n, text: s }) {
  if (Ce2(e) && t === e.expression && !us(n, s)) return r ? ee(r, n) : X2(e, n), true;
}
function zp({ comment: e, enclosingNode: t, followingNode: r, precedingNode: n }) {
  return t && r && n && t.type === "ArrowFunctionExpression" && t.returnType === n && (n.type === "TSTypeAnnotation" || n.type === "TypeAnnotation") ? (ee(r, e), true) : false;
}
var $i = P(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), Zp = { endOfLine: Bp, ownLine: Sp, remaining: bp }, ms = Zp;
var ec = P(["File", "TemplateElement", "TSEmptyBodyFunctionExpression", "ChainExpression"]), tc = (e, [t]) => t?.type === "ComponentParameter" && t.shorthand && t.name === e && t.local !== t.name || t?.type === "MatchObjectPatternProperty" && t.shorthand && t.key === e && t.value !== t.key || t?.type === "ObjectProperty" && t.shorthand && t.key === e && t.value !== t.key || t?.type === "Property" && t.shorthand && t.key === e && !lt2(t) && t.value !== t.key, rc = (e, [t]) => !!(e.type === "FunctionExpression" && t.type === "MethodDefinition" && t.value === e && $(e).length === 0 && !e.returnType && !j(e.typeParameters) && e.body), Ki = (e, [t]) => t?.typeAnnotation === e && Ti(t), nc = (e, [t, ...r]) => Ki(e, [t]) || t?.typeName === e && Ki(t, r);
function Qi(e, t) {
  return ec(e) || tc(e, t) || rc(e, t) ? false : e.type === "EmptyStatement" ? bt({ node: e, parent: t[0] }) : !(nc(e, t) || e.type === "TSTypeAnnotation" && t[0].type === "TSPropertySignature");
}
var sc = P(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function zi(e) {
  let { key: t, parent: r } = e;
  if (t === "types" && Ie(r) || t === "argument" && r.type === "JSXSpreadAttribute" || t === "expression" && r.type === "JSXSpreadChild" || t === "superClass" && (r.type === "ClassDeclaration" || r.type === "ClassExpression") || (t === "id" || t === "typeParameters") && sc(r) || t === "patterns" && r.type === "MatchOrPattern") return true;
  let { node: n } = e;
  return It(n) ? false : Y2(n) || Ie(n);
}
function Zi(e, { parser: t }) {
  if (t === "flow" || t === "hermes" || t === "babel-flow") return e = J(0, e, /[\s(]/gu, ""), e === "" || e === "/*" || e === "/*::";
}
function ic(e, t, r = 0) {
  let n = 0;
  for (let s = r; s < e.length; ++s) e[s] === "	" ? n = n + t - n % t : n++;
  return n;
}
var eu = ic;
function uc(e, t) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : eu(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
}
var tu = uc;
function $r(e, t, r) {
  let { node: n } = e;
  if (n.type === "TemplateLiteral" && pc(e)) {
    let p = oc(e, t, r);
    if (p) return p;
  }
  let i = "expressions";
  n.type === "TSTemplateLiteralType" && (i = "types");
  let u = [], o = e.map(r, i);
  u.push(we2, "`");
  let a2 = 0;
  return e.each(({ index: p, node: D2 }) => {
    if (u.push(r()), D2.tail) return;
    let { tabWidth: l2 } = t, E = D2.value.raw, d2 = E.includes(`
`) ? tu(E, l2) : a2;
    a2 = d2;
    let F2 = o[p], B2 = n[i][p], S2 = oe(t.originalText, k(D2), O(n.quasis[p + 1]));
    if (!S2) {
      let g2 = es(F2, { ...t, printWidth: Number.POSITIVE_INFINITY }).formatted;
      g2.includes(`
`) ? S2 = true : F2 = g2;
    }
    S2 && (C(B2) || B2.type === "Identifier" || R(B2) || B2.type === "ConditionalExpression" || B2.type === "SequenceExpression" || Ce2(B2) || Ae(B2)) && (F2 = [m([f, F2]), f]);
    let L2 = d2 === 0 && E.endsWith(`
`) ? Te(Number.NEGATIVE_INFINITY, F2) : wi(F2, d2, l2);
    u.push(c(["${", L2, we2, "}"]));
  }, "quasis"), u.push("`"), u;
}
function ru(e, t, r) {
  let n = r("quasi"), { node: s } = e, i = "", u = Ze2(s.quasi, T.Leading)[0];
  return u && (oe(t.originalText, k(s.typeArguments ?? s.tag), O(u)) ? i = f : i = " "), ot2(n.label && { tagged: true, ...n.label }, [r("tag"), r("typeArguments"), i, we2, n]);
}
function oc(e, t, r) {
  let { node: n } = e, s = n.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
  if (s.length > 1 || s.some((i) => i.length > 0)) {
    t.__inJestEach = true;
    let i = e.map(r, "expressions");
    t.__inJestEach = false;
    let u = i.map((l2) => "${" + es(l2, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), o = [{ hasLineBreak: false, cells: [] }];
    for (let l2 = 1; l2 < n.quasis.length; l2++) {
      let E = _(0, o, -1), d2 = u[l2 - 1];
      E.cells.push(d2), d2.includes(`
`) && (E.hasLineBreak = true), n.quasis[l2].value.raw.includes(`
`) && o.push({ hasLineBreak: false, cells: [] });
    }
    let a2 = Math.max(s.length, ...o.map((l2) => l2.cells.length)), p = Array.from({ length: a2 }).fill(0), D2 = [{ cells: s }, ...o.filter((l2) => l2.cells.length > 0)];
    for (let { cells: l2 } of D2.filter((E) => !E.hasLineBreak)) for (let [E, d2] of l2.entries()) p[E] = Math.max(p[E], it2(d2));
    return [we2, "`", m([y, I(y, D2.map((l2) => I(" | ", l2.cells.map((E, d2) => l2.hasLineBreak ? E : E + " ".repeat(p[d2] - it2(E))))))]), y, "`"];
  }
}
function ac(e, t) {
  let { node: r } = e, n = t();
  return C(r) && (n = c([m([f, n]), f])), ["${", n, we2, "}"];
}
function Kt(e, t) {
  return e.map(() => ac(e, t), "expressions");
}
function Kr(e, t) {
  return Dt(e, (r) => typeof r == "string" ? t ? J(0, r, /(\\*)`/gu, "$1$1\\`") : Ds(r) : r);
}
function Ds(e) {
  return J(0, e, /([\\`]|\$\{)/gu, "\\$1");
}
function pc({ node: e, parent: t }) {
  let r = /^[fx]?(?:describe|it|test)$/u;
  return t.type === "TaggedTemplateExpression" && t.quasi === e && t.tag.type === "MemberExpression" && t.tag.property.type === "Identifier" && t.tag.property.name === "each" && (t.tag.object.type === "Identifier" && r.test(t.tag.object.name) || t.tag.object.type === "MemberExpression" && t.tag.object.property.type === "Identifier" && (t.tag.object.property.name === "only" || t.tag.object.property.name === "skip") && t.tag.object.object.type === "Identifier" && r.test(t.tag.object.object.name));
}
var ys = [(e, t) => e.type === "ObjectExpression" && t === "properties", (e, t) => e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "Component" && t === "arguments", (e, t) => e.type === "Decorator" && t === "expression"];
function nu(e) {
  let t = (n) => n.type === "TemplateLiteral", r = (n, s) => ke(n) && !n.computed && n.key.type === "Identifier" && n.key.name === "styles" && s === "value";
  return e.match(t, (n, s) => G(n) && s === "elements", r, ...ys) || e.match(t, r, ...ys);
}
function Es(e) {
  return e.match((t) => t.type === "TemplateLiteral", (t, r) => ke(t) && !t.computed && t.key.type === "Identifier" && t.key.name === "template" && r === "value", ...ys);
}
function fs(e, t) {
  return C(e, T.Block | T.Leading, ({ value: r }) => r === ` ${t} `);
}
function Qr({ node: e, parent: t }, r) {
  return fs(e, r) || cc(t) && fs(t, r) || t.type === "ExpressionStatement" && fs(t, r);
}
function cc(e) {
  return e.type === "AsConstExpression" || e.type === "TSAsExpression" && e.typeAnnotation.type === "TSTypeReference" && e.typeAnnotation.typeName.type === "Identifier" && e.typeAnnotation.typeName.name === "const";
}
async function iu(e, t, r) {
  let { node: n } = r, s = "";
  for (let [a2, p] of n.quasis.entries()) {
    let { raw: D2 } = p.value;
    a2 > 0 && (s += "@prettier-placeholder-" + (a2 - 1) + "-id"), s += D2;
  }
  let i = await e(s, { parser: "scss" }), u = Kt(r, t), o = lc(i, u);
  if (!o) throw new Error("Couldn't insert all the expressions");
  return ["`", m([y, o]), f, "`"];
}
function lc(e, t) {
  if (!j(t)) return e;
  let r = 0, n = Dt($t(e), (s) => typeof s != "string" || !s.includes("@prettier-placeholder") ? s : s.split(/@prettier-placeholder-(\d+)-id/u).map((i, u) => u % 2 === 0 ? Ge2(i) : (r++, t[i])));
  return t.length === r ? n : null;
}
function mc(e) {
  return e.match(void 0, (t, r) => r === "quasi" && t.type === "TaggedTemplateExpression" && Bt(t.tag, ["css", "css.global", "css.resolve"])) || e.match(void 0, (t, r) => r === "expression" && t.type === "JSXExpressionContainer", (t, r) => r === "children" && t.type === "JSXElement" && t.openingElement.name.type === "JSXIdentifier" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((n) => n.type === "JSXAttribute" && n.name.type === "JSXIdentifier" && n.name.name === "jsx"));
}
function zr(e) {
  return e.type === "Identifier" && e.name === "styled";
}
function su(e) {
  return /^[A-Z]/u.test(e.object.name) && e.property.name === "extend";
}
function Dc({ parent: e }) {
  if (!e || e.type !== "TaggedTemplateExpression") return false;
  let t = e.tag.type === "ParenthesizedExpression" ? e.tag.expression : e.tag;
  switch (t.type) {
    case "MemberExpression":
      return zr(t.object) || su(t);
    case "CallExpression":
      return zr(t.callee) || t.callee.type === "MemberExpression" && (t.callee.object.type === "MemberExpression" && (zr(t.callee.object.object) || su(t.callee.object)) || t.callee.object.type === "CallExpression" && zr(t.callee.object.callee));
    case "Identifier":
      return t.name === "css";
    default:
      return false;
  }
}
function fc({ parent: e, grandparent: t }) {
  return t?.type === "JSXAttribute" && e.type === "JSXExpressionContainer" && t.name.type === "JSXIdentifier" && t.name.name === "css";
}
var uu = (e) => mc(e) || Dc(e) || fc(e) || nu(e);
async function ou(e, t, r) {
  let { node: n } = r, s = n.quasis.length, i = Kt(r, t), u = [];
  for (let o = 0; o < s; o++) {
    let a2 = n.quasis[o], p = o === 0, D2 = o === s - 1, l2 = a2.value.cooked, E = l2.split(`
`), d2 = E.length, F2 = i[o], B2 = d2 > 2 && E[0].trim() === "" && E[1].trim() === "", S2 = d2 > 2 && E[d2 - 1].trim() === "" && E[d2 - 2].trim() === "", L2 = E.every((x2) => /^\s*(?:#[^\n\r]*)?$/u.test(x2));
    if (!D2 && /#[^\n\r]*$/u.test(E[d2 - 1])) return null;
    let g2 = null;
    L2 ? g2 = yc(E) : g2 = await e(l2, { parser: "graphql" }), g2 ? (g2 = Kr(g2, false), !p && B2 && u.push(""), u.push(g2), !D2 && S2 && u.push("")) : !p && !D2 && B2 && u.push(""), F2 && u.push(F2);
  }
  return ["`", m([y, I(y, u)]), y, "`"];
}
function yc(e) {
  let t = [], r = false, n = e.map((s) => s.trim());
  for (let [s, i] of n.entries()) i !== "" && (n[s - 1] === "" && r ? t.push([y, i]) : t.push(i), r = true);
  return t.length === 0 ? null : I(y, t);
}
function au({ node: e, parent: t }) {
  return Qr({ node: e, parent: t }, "GraphQL") || t && (t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" && t.tag.object.name === "graphql" && t.tag.property.name === "experimental" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql")) || t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "graphql");
}
var Fs = 0;
async function pu(e, t, r, n, s) {
  let { node: i } = n, u = Fs;
  Fs = Fs + 1 >>> 0;
  let o = (L2) => `PRETTIER_HTML_PLACEHOLDER_${L2}_${u}_IN_JS`, a2 = i.quasis.map((L2, g2, x2) => g2 === x2.length - 1 ? L2.value.cooked : L2.value.cooked + o(g2)).join(""), p = Kt(n, r), D2 = new RegExp(o("(\\d+)"), "gu"), l2 = 0, E = await t(a2, { parser: e, __onHtmlRoot(L2) {
    l2 = L2.children.length;
  } }), d2 = Dt(E, (L2) => {
    if (typeof L2 != "string") return L2;
    let g2 = [], x2 = L2.split(D2);
    for (let h = 0; h < x2.length; h++) {
      let N = x2[h];
      if (h % 2 === 0) {
        N && (N = Ds(N), s.__embeddedInHtml && (N = J(0, N, /<\/(?=script\b)/giu, "<\\/")), g2.push(N));
        continue;
      }
      let W2 = Number(N);
      g2.push(p[W2]);
    }
    return g2;
  }), F2 = /^\s/u.test(a2) ? " " : "", B2 = /\s$/u.test(a2) ? " " : "", S2 = s.htmlWhitespaceSensitivity === "ignore" ? y : F2 && B2 ? A : null;
  return S2 ? c(["`", m([S2, c(d2)]), S2, "`"]) : ot2({ hug: false }, c(["`", F2, l2 > 1 ? m(c(d2)) : c(d2), B2, "`"]));
}
function cu(e) {
  return Qr(e, "HTML") || e.match((t) => t.type === "TemplateLiteral", (t, r) => t.type === "TaggedTemplateExpression" && t.tag.type === "Identifier" && t.tag.name === "html" && r === "quasi");
}
var lu = pu.bind(void 0, "html"), mu = pu.bind(void 0, "angular");
async function Du(e, t, r) {
  let { node: n } = r, s = J(0, n.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (a2, p) => "\\".repeat(p.length / 2) + "`"), i = Ec(s), u = i !== "";
  u && (s = J(0, s, new RegExp(`^${i}`, "gmu"), ""));
  let o = Kr(await e(s, { parser: "markdown", __inJsTemplate: true }), true);
  return ["`", u ? m([f, o]) : [qr, Oi(o)], f, "`"];
}
function Ec(e) {
  let t = e.match(/^([^\S\n]*)\S/mu);
  return t === null ? "" : t[1];
}
function fu({ node: e, parent: t }) {
  return t?.type === "TaggedTemplateExpression" && e.quasis.length === 1 && t.tag.type === "Identifier" && (t.tag.name === "md" || t.tag.name === "markdown");
}
var Fc = [{ test: uu, print: iu }, { test: au, print: ou }, { test: cu, print: lu }, { test: Es, print: mu }, { test: fu, print: Du }].map(({ test: e, print: t }) => ({ test: e, print: Cc(t) }));
function dc(e) {
  let { node: t } = e;
  if (t.type !== "TemplateLiteral" || Ac(t)) return;
  let r = Fc.find(({ test: n }) => n(e));
  if (r) return t.quasis.length === 1 && t.quasis[0].value.raw.trim() === "" ? "``" : r.print;
}
function Cc(e) {
  return async (...t) => {
    let r = await e(...t);
    return r && ot2({ embed: true, ...r.label }, r);
  };
}
function Ac({ quasis: e }) {
  return e.some(({ value: { cooked: t } }) => t === null);
}
var yu = dc;
var Tc = /\*\/$/, xc = /^\/\*\*?/, Cu = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, gc = /(^|\s+)\/\/([^\n\r]*)/g, Eu = /^(\r?\n)+/, hc = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, Fu = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Sc = /(\r?\n|^) *\* ?/g, Au = [];
function Tu(e) {
  let t = e.match(Cu);
  return t ? t[0].trimStart() : "";
}
function xu(e) {
  let r = e.match(Cu)?.[0];
  return r == null ? e : e.slice(r.length);
}
function gu(e) {
  e = J(0, e.replace(xc, "").replace(Tc, ""), Sc, "$1");
  let r = "";
  for (; r !== e; ) r = e, e = J(0, e, hc, `
$1 $2
`);
  e = e.replace(Eu, "").trimEnd();
  let n = /* @__PURE__ */ Object.create(null), s = J(0, e, Fu, "").replace(Eu, "").trimEnd(), i;
  for (; i = Fu.exec(e); ) {
    let u = J(0, i[2], gc, "");
    if (typeof n[i[1]] == "string" || Array.isArray(n[i[1]])) {
      let o = n[i[1]];
      n[i[1]] = [...Au, ...Array.isArray(o) ? o : [o], u];
    } else n[i[1]] = u;
  }
  return { comments: s, pragmas: n };
}
function hu({ comments: e = "", pragmas: t = {} }) {
  let u = Object.keys(t), o = u.flatMap((p) => du(p, t[p])).map((p) => ` * ${p}
`).join("");
  if (!e) {
    if (u.length === 0) return "";
    if (u.length === 1 && !Array.isArray(t[u[0]])) {
      let p = t[u[0]];
      return `/** ${du(u[0], p)[0]} */`;
    }
  }
  let a2 = e.split(`
`).map((p) => ` * ${p}`).join(`
`) + `
`;
  return `/**
` + (e ? a2 : "") + (e && u.length > 0 ? ` *
` : "") + o + " */";
}
function du(e, t) {
  return [...Au, ...Array.isArray(t) ? t : [t]].map((r) => `@${e} ${r}`.trim());
}
var Su = "format";
function Bc(e) {
  if (!e.startsWith("#!")) return "";
  let t = e.indexOf(`
`);
  return t === -1 ? e : e.slice(0, t);
}
var Bu = Bc;
function bc(e) {
  let t = Bu(e);
  t && (e = e.slice(t.length + 1));
  let r = Tu(e), { pragmas: n, comments: s } = gu(r);
  return { shebang: t, text: e, pragmas: n, comments: s };
}
function bu(e) {
  let { shebang: t, text: r, pragmas: n, comments: s } = bc(e), i = xu(r), u = hu({ pragmas: { [Su]: "", ...n }, comments: s.trimStart() });
  return (t ? `${t}
` : "") + u + (i.startsWith(`
`) ? `
` : `

`) + i;
}
function ds(e, t) {
  if (e.isRoot) return false;
  let { node: r, key: n, parent: s } = e;
  if (t.__isInHtmlInterpolation && !t.bracketSpacing && Lc(r) && Cr(e)) return true;
  if (Pc(r)) return false;
  if (r.type === "Identifier") {
    if (r.extra?.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(r.name) || n === "left" && (r.name === "async" && !s.await || r.name === "let") && s.type === "ForOfStatement") return true;
    if (r.name === "let") {
      let i = e.findAncestor((u) => u.type === "ForOfStatement")?.left;
      if (i && fe2(i, (u) => u === r)) return true;
    }
    if (n === "object" && r.name === "let" && s.type === "MemberExpression" && s.computed && !s.optional) {
      let i = e.findAncestor((o) => o.type === "ExpressionStatement" || o.type === "ForStatement" || o.type === "ForInStatement"), u = i ? i.type === "ExpressionStatement" ? i.expression : i.type === "ForStatement" ? i.init : i.left : void 0;
      if (u && fe2(u, (o) => o === r)) return true;
    }
    if (n === "expression") switch (r.name) {
      case "await":
      case "interface":
      case "module":
      case "using":
      case "yield":
      case "let":
      case "component":
      case "hook":
      case "type": {
        let i = e.findAncestor((u) => !Ce2(u));
        if (i !== s && i.type === "ExpressionStatement") return true;
      }
    }
    return false;
  }
  if (r.type === "ObjectExpression" || r.type === "FunctionExpression" || r.type === "ClassExpression" || r.type === "DoExpression") {
    let i = e.findAncestor((u) => u.type === "ExpressionStatement")?.expression;
    if (i && fe2(i, (u) => u === r)) return true;
  }
  if (r.type === "ObjectExpression") {
    let i = e.findAncestor((u) => u.type === "ArrowFunctionExpression")?.body;
    if (i && i.type !== "SequenceExpression" && i.type !== "AssignmentExpression" && fe2(i, (u) => u === r)) return true;
  }
  switch (s.type) {
    case "ParenthesizedExpression":
      return false;
    case "ClassDeclaration":
    case "ClassExpression":
      if (n === "superClass" && (r.type === "ArrowFunctionExpression" || r.type === "AssignmentExpression" || r.type === "AwaitExpression" || r.type === "BinaryExpression" || r.type === "ConditionalExpression" || r.type === "LogicalExpression" || r.type === "NewExpression" || r.type === "ObjectExpression" || r.type === "SequenceExpression" || r.type === "TaggedTemplateExpression" || r.type === "UnaryExpression" || r.type === "UpdateExpression" || r.type === "YieldExpression" || r.type === "TSNonNullExpression" || r.type === "ClassExpression" && j(r.decorators))) return true;
      break;
    case "ExportDefaultDeclaration":
      return Pu(e, t) || r.type === "SequenceExpression";
    case "Decorator":
      if (n === "expression" && !wc(r)) return true;
      break;
    case "TypeAnnotation":
      if (e.match(void 0, void 0, (i, u) => u === "returnType" && i.type === "ArrowFunctionExpression") && Ic(r)) return true;
      break;
    case "BinaryExpression":
      if (n === "left" && (s.operator === "in" || s.operator === "instanceof") && r.type === "UnaryExpression") return true;
      break;
    case "VariableDeclarator":
      if (n === "init" && e.match(void 0, void 0, (i, u) => u === "declarations" && i.type === "VariableDeclaration", (i, u) => u === "left" && i.type === "ForInStatement")) return true;
      break;
  }
  switch (r.type) {
    case "UpdateExpression":
      if (s.type === "UnaryExpression") return r.prefix && (r.operator === "++" && s.operator === "+" || r.operator === "--" && s.operator === "-");
    case "UnaryExpression":
      switch (s.type) {
        case "UnaryExpression":
          return r.operator === s.operator && (r.operator === "+" || r.operator === "-");
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return n === "object";
        case "TaggedTemplateExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "BinaryExpression":
          return n === "left" && s.operator === "**";
        case "TSNonNullExpression":
          return true;
        default:
          return false;
      }
    case "BinaryExpression":
      if (s.type === "UpdateExpression" || r.operator === "in" && kc(e)) return true;
      if (r.operator === "|>" && r.extra?.parenthesized) {
        let i = e.grandparent;
        if (i.type === "BinaryExpression" && i.operator === "|>") return true;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (s.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !Ce2(r);
        case "ConditionalExpression":
          return Ce2(r) || li(r);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return n === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return n === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return n === "left" && (r.type === "TSTypeAssertion" || Ce2(r));
        case "LogicalExpression":
          if (r.type === "LogicalExpression") return s.operator !== r.operator;
        case "BinaryExpression": {
          let { operator: i, type: u } = r;
          if (!i && u !== "TSTypeAssertion") return true;
          let o = mr(i), a2 = s.operator, p = mr(a2);
          return !!(p > o || n === "right" && p === o || p === o && !yr(a2, i) || p < o && i === "%" && (a2 === "+" || a2 === "-") || Fi(a2));
        }
        default:
          return false;
      }
    case "SequenceExpression":
      return s.type !== "ForStatement";
    case "YieldExpression":
      if (s.type === "AwaitExpression" || s.type === "TSTypeAssertion") return true;
    case "AwaitExpression":
      switch (s.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return n === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "ConditionalExpression":
          return n === "test";
        case "BinaryExpression":
          return !(!r.argument && s.operator === "|>");
        default:
          return false;
      }
    case "TSFunctionType":
      if (e.match((i) => i.type === "TSFunctionType", (i, u) => u === "typeAnnotation" && i.type === "TSTypeAnnotation", (i, u) => u === "returnType" && i.type === "ArrowFunctionExpression")) return true;
    case "TSConditionalType":
    case "TSConstructorType":
    case "ConditionalTypeAnnotation":
      if (n === "extendsType" && qe(r) && s.type === r.type || n === "checkType" && qe(s)) return true;
      if (n === "extendsType" && s.type === "TSConditionalType") {
        let { typeAnnotation: i } = r.returnType || r.typeAnnotation;
        if (i.type === "TSTypePredicate" && i.typeAnnotation && (i = i.typeAnnotation.typeAnnotation), i.type === "TSInferType" && i.typeParameter.constraint) return true;
      }
    case "TSUnionType":
    case "TSIntersectionType":
      if ((Ie(s) || Lt(s)) && s.types.length > 1 && (!r.types || r.types.length > 1)) return true;
    case "TSInferType":
      if (r.type === "TSInferType") {
        if (s.type === "TSRestType") return false;
        if (n === "types" && (s.type === "TSUnionType" || s.type === "TSIntersectionType") && r.typeParameter.type === "TSTypeParameter" && r.typeParameter.constraint) return true;
      }
    case "TSTypeOperator":
      return s.type === "TSArrayType" || s.type === "TSOptionalType" || s.type === "TSRestType" || n === "objectType" && s.type === "TSIndexedAccessType" || s.type === "TSTypeOperator" || s.type === "TSTypeAnnotation" && e.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return n === "objectType" && s.type === "TSIndexedAccessType" || n === "elementType" && s.type === "TSArrayType";
    case "TypeOperator":
      return s.type === "ArrayTypeAnnotation" || s.type === "NullableTypeAnnotation" || n === "objectType" && (s.type === "IndexedAccessType" || s.type === "OptionalIndexedAccessType") || s.type === "TypeOperator";
    case "TypeofTypeAnnotation":
      return n === "objectType" && (s.type === "IndexedAccessType" || s.type === "OptionalIndexedAccessType") || n === "elementType" && s.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return s.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return s.type === "TypeOperator" || s.type === "KeyofTypeAnnotation" || s.type === "ArrayTypeAnnotation" || s.type === "NullableTypeAnnotation" || s.type === "IntersectionTypeAnnotation" || s.type === "UnionTypeAnnotation" || n === "objectType" && (s.type === "IndexedAccessType" || s.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return s.type === "ArrayTypeAnnotation" || n === "objectType" && (s.type === "IndexedAccessType" || s.type === "OptionalIndexedAccessType");
    case "ComponentTypeAnnotation":
    case "FunctionTypeAnnotation": {
      if (r.type === "ComponentTypeAnnotation" && (r.rendersType === null || r.rendersType === void 0)) return false;
      if (e.match(void 0, (u, o) => o === "typeAnnotation" && u.type === "TypeAnnotation", (u, o) => o === "returnType" && u.type === "ArrowFunctionExpression") || e.match(void 0, (u, o) => o === "typeAnnotation" && u.type === "TypePredicate", (u, o) => o === "typeAnnotation" && u.type === "TypeAnnotation", (u, o) => o === "returnType" && u.type === "ArrowFunctionExpression")) return true;
      let i = s.type === "NullableTypeAnnotation" ? e.grandparent : s;
      return i.type === "UnionTypeAnnotation" || i.type === "IntersectionTypeAnnotation" || i.type === "ArrayTypeAnnotation" || n === "objectType" && (i.type === "IndexedAccessType" || i.type === "OptionalIndexedAccessType") || n === "checkType" && s.type === "ConditionalTypeAnnotation" || n === "extendsType" && s.type === "ConditionalTypeAnnotation" && r.returnType?.type === "InferTypeAnnotation" && r.returnType?.typeParameter.bound || i.type === "NullableTypeAnnotation" || s.type === "FunctionTypeParam" && s.name === null && $(r).some((u) => u.typeAnnotation?.type === "NullableTypeAnnotation");
    }
    case "OptionalIndexedAccessType":
      return n === "objectType" && s.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof r.value == "string" && s.type === "ExpressionStatement" && typeof s.directive != "string") {
        let i = e.grandparent;
        return i.type === "Program" || i.type === "BlockStatement";
      }
      return n === "object" && R(s) && Fe(r);
    case "AssignmentExpression":
      return !((n === "init" || n === "update") && s.type === "ForStatement" || n === "expression" && r.left.type !== "ObjectPattern" && s.type === "ExpressionStatement" || n === "key" && s.type === "TSPropertySignature" || s.type === "AssignmentExpression" || n === "expressions" && s.type === "SequenceExpression" && e.match(void 0, void 0, (i, u) => (u === "init" || u === "update") && i.type === "ForStatement") || n === "value" && s.type === "Property" && e.match(void 0, void 0, (i, u) => u === "properties" && i.type === "ObjectPattern") || s.type === "NGChainedExpression" || n === "node" && s.type === "JsExpressionRoot");
    case "ConditionalExpression":
      switch (s.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "ConditionalExpression":
          return t.experimentalTernaries ? false : n === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return n === "object";
        default:
          return false;
      }
    case "FunctionExpression":
      switch (s.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "TaggedTemplateExpression":
          return true;
        default:
          return false;
      }
    case "ArrowFunctionExpression":
      switch (s.type) {
        case "BinaryExpression":
          return s.operator !== "|>" || r.extra?.parenthesized;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return n === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return n === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
        case "MatchExpressionCase":
          return true;
        case "TSInstantiationExpression":
          return n === "expression";
        case "ConditionalExpression":
          return n === "test";
        default:
          return false;
      }
    case "ClassExpression":
      switch (s.type) {
        case "NewExpression":
          return n === "callee";
        default:
          return false;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (Oc(e)) return true;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (n === "callee" && (s.type === "BindExpression" || s.type === "NewExpression")) {
        let i = r;
        for (; i; ) switch (i.type) {
          case "CallExpression":
          case "OptionalCallExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
          case "BindExpression":
            i = i.object;
            break;
          case "TaggedTemplateExpression":
            i = i.tag;
            break;
          case "TSNonNullExpression":
            i = i.expression;
            break;
          default:
            return false;
        }
      }
      return false;
    case "BindExpression":
      return n === "callee" && (s.type === "BindExpression" || s.type === "NewExpression") || n === "object" && R(s);
    case "NGPipeExpression":
      return !(s.type === "NGRoot" || s.type === "NGMicrosyntaxExpression" || s.type === "ObjectProperty" && !r.extra?.parenthesized || G(s) || n === "arguments" && M(s) || n === "right" && s.type === "NGPipeExpression" || n === "property" && s.type === "MemberExpression" || s.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return n === "callee" || n === "left" && s.type === "BinaryExpression" && s.operator === "<" || !G(s) && s.type !== "ArrowFunctionExpression" && s.type !== "AssignmentExpression" && s.type !== "AssignmentPattern" && s.type !== "BinaryExpression" && s.type !== "NewExpression" && s.type !== "ConditionalExpression" && s.type !== "ExpressionStatement" && s.type !== "JsExpressionRoot" && s.type !== "JSXAttribute" && s.type !== "JSXElement" && s.type !== "JSXExpressionContainer" && s.type !== "JSXFragment" && s.type !== "LogicalExpression" && !M(s) && !ke(s) && s.type !== "ReturnStatement" && s.type !== "ThrowStatement" && s.type !== "TypeCastExpression" && s.type !== "VariableDeclarator" && s.type !== "YieldExpression" && s.type !== "MatchExpressionCase";
    case "TSInstantiationExpression":
      return n === "object" && R(s);
    case "MatchOrPattern":
      return s.type === "MatchAsPattern";
  }
  return false;
}
var Pc = P(["BlockStatement", "BreakStatement", "ComponentDeclaration", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareComponent", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareHook", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareNamespace", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "HookDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function kc(e) {
  let t = 0, { node: r } = e;
  for (; r; ) {
    let n = e.getParentNode(t++);
    if (n?.type === "ForStatement" && n.init === r) return true;
    r = n;
  }
  return false;
}
function Ic(e) {
  return Dr(e, (t) => t.type === "ObjectTypeAnnotation" && Dr(t, (r) => r.type === "FunctionTypeAnnotation"));
}
function Lc(e) {
  return se(e);
}
function Cr(e) {
  let { parent: t, key: r } = e;
  switch (t.type) {
    case "NGPipeExpression":
      if (r === "arguments" && e.isLast) return e.callParent(Cr);
      break;
    case "ObjectProperty":
      if (r === "value") return e.callParent(() => e.key === "properties" && e.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right") return e.callParent(Cr);
      break;
    case "ConditionalExpression":
      if (r === "alternate") return e.callParent(Cr);
      break;
    case "UnaryExpression":
      if (t.prefix) return e.callParent(Cr);
      break;
  }
  return false;
}
function Pu(e, t) {
  let { node: r, parent: n } = e;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? n.type === "ExportDefaultDeclaration" || !ds(e, t) : !Ut(r) || n.type !== "ExportDefaultDeclaration" && ds(e, t) ? false : e.call(() => Pu(e, t), ..._r(r));
}
function Oc(e) {
  return !!(e.match(void 0, (t, r) => r === "expression" && t.type === "ChainExpression", (t, r) => r === "tag" && t.type === "TaggedTemplateExpression") || e.match((t) => t.type === "OptionalCallExpression" || t.type === "OptionalMemberExpression", (t, r) => r === "tag" && t.type === "TaggedTemplateExpression") || e.match((t) => t.type === "OptionalCallExpression" || t.type === "OptionalMemberExpression", (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "tag" && t.type === "TaggedTemplateExpression") || e.match(void 0, (t, r) => r === "expression" && t.type === "ChainExpression", (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "tag" && t.type === "TaggedTemplateExpression") || e.match(void 0, (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "expression" && t.type === "ChainExpression", (t, r) => r === "tag" && t.type === "TaggedTemplateExpression") || e.match((t) => t.type === "OptionalMemberExpression" || t.type === "OptionalCallExpression", (t, r) => r === "object" && t.type === "MemberExpression" || r === "callee" && (t.type === "CallExpression" || t.type === "NewExpression")) || e.match((t) => t.type === "OptionalMemberExpression" || t.type === "OptionalCallExpression", (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "object" && t.type === "MemberExpression" || r === "callee" && t.type === "CallExpression") || e.match((t) => t.type === "CallExpression" || t.type === "MemberExpression", (t, r) => r === "expression" && t.type === "ChainExpression") && (e.match(void 0, void 0, (t, r) => r === "callee" && (t.type === "CallExpression" && !t.optional || t.type === "NewExpression") || r === "object" && t.type === "MemberExpression" && !t.optional) || e.match(void 0, void 0, (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "object" && t.type === "MemberExpression" || r === "callee" && t.type === "CallExpression")) || e.match((t) => t.type === "CallExpression" || t.type === "MemberExpression", (t, r) => r === "expression" && t.type === "TSNonNullExpression", (t, r) => r === "expression" && t.type === "ChainExpression", (t, r) => r === "object" && t.type === "MemberExpression" || r === "callee" && t.type === "CallExpression"));
}
function Cs(e) {
  return e.type === "Identifier" ? true : R(e) ? !e.computed && !e.optional && e.property.type === "Identifier" && Cs(e.object) : false;
}
function wc(e) {
  return e.type === "ChainExpression" && (e = e.expression), Cs(e) || M(e) && !e.optional && Cs(e.callee);
}
var xe = ds;
function Mc(e, t) {
  let r = t - 1;
  r = Qe(e, r, { backwards: true }), r = ze(e, r, { backwards: true }), r = Qe(e, r, { backwards: true });
  let n = ze(e, r, { backwards: true });
  return r !== n;
}
var ku = Mc;
var _c = () => true;
function As(e, t) {
  let r = e.node;
  return r.printed = true, t.printer.printComment(e, t);
}
function Nc(e, t) {
  let r = e.node, n = [As(e, t)], { printer: s, originalText: i, locStart: u, locEnd: o } = t;
  if (s.isBlockComment?.(r)) {
    let D2 = Q2(i, o(r)) ? Q2(i, u(r), { backwards: true }) ? y : A : " ";
    n.push(D2);
  } else n.push(y);
  let p = ze(i, Qe(i, o(r)));
  return p !== false && Q2(i, p) && n.push(y), n;
}
function vc(e, t, r) {
  let n = e.node, s = As(e, t), { printer: i, originalText: u, locStart: o } = t, a2 = i.isBlockComment?.(n);
  if (r?.hasLineSuffix && !r?.isBlock || Q2(u, o(n), { backwards: true })) {
    let p = ku(u, o(n));
    return { doc: Kn([y, p ? y : "", s]), isBlock: a2, hasLineSuffix: true };
  }
  return !a2 || r?.hasLineSuffix ? { doc: [Kn([" ", s]), Be], isBlock: a2, hasLineSuffix: true } : { doc: [" ", s], isBlock: a2, hasLineSuffix: false };
}
function v(e, t, r = {}) {
  let { node: n } = e;
  if (!j(n?.comments)) return "";
  let { indent: s = false, marker: i, filter: u = _c } = r, o = [];
  if (e.each(({ node: p }) => {
    p.leading || p.trailing || p.marker !== i || !u(p) || o.push(As(e, t));
  }, "comments"), o.length === 0) return "";
  let a2 = I(y, o);
  return s ? m([y, a2]) : a2;
}
function Mt(e, t) {
  let r = e.node;
  if (!r) return {};
  let n = t[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a2) => !n.has(a2)).length === 0) return { leading: "", trailing: "" };
  let i = [], u = [], o;
  return e.each(() => {
    let a2 = e.node;
    if (n?.has(a2)) return;
    let { leading: p, trailing: D2 } = a2;
    p ? i.push(Nc(e, t)) : D2 && (o = vc(e, t, o), u.push(o.doc));
  }, "comments"), { leading: i, trailing: u };
}
function me(e, t, r) {
  let { leading: n, trailing: s } = Mt(e, r);
  return !n && !s ? t : Fr(t, (i) => [n, i, s]);
}
var Ts = class extends Error {
  name = "UnexpectedNodeError";
  constructor(t, r, n = "type") {
    super(`Unexpected ${r} node ${n}: ${JSON.stringify(t[n])}.`), this.node = t;
  }
}, $e2 = Ts;
function xs(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var gs = class {
  #e;
  constructor(t) {
    this.#e = new Set(t);
  }
  getLeadingWhitespaceCount(t) {
    let r = this.#e, n = 0;
    for (let s = 0; s < t.length && r.has(t.charAt(s)); s++) n++;
    return n;
  }
  getTrailingWhitespaceCount(t) {
    let r = this.#e, n = 0;
    for (let s = t.length - 1; s >= 0 && r.has(t.charAt(s)); s--) n++;
    return n;
  }
  getLeadingWhitespace(t) {
    let r = this.getLeadingWhitespaceCount(t);
    return t.slice(0, r);
  }
  getTrailingWhitespace(t) {
    let r = this.getTrailingWhitespaceCount(t);
    return t.slice(t.length - r);
  }
  hasLeadingWhitespace(t) {
    return this.#e.has(t.charAt(0));
  }
  hasTrailingWhitespace(t) {
    return this.#e.has(_(0, t, -1));
  }
  trimStart(t) {
    let r = this.getLeadingWhitespaceCount(t);
    return t.slice(r);
  }
  trimEnd(t) {
    let r = this.getTrailingWhitespaceCount(t);
    return t.slice(0, t.length - r);
  }
  trim(t) {
    return this.trimEnd(this.trimStart(t));
  }
  split(t, r = false) {
    let n = `[${xs([...this.#e].join(""))}]+`, s = new RegExp(r ? `(${n})` : n, "u");
    return t.split(s);
  }
  hasWhitespaceCharacter(t) {
    let r = this.#e;
    return Array.prototype.some.call(t, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(t) {
    let r = this.#e;
    return Array.prototype.some.call(t, (n) => !r.has(n));
  }
  isWhitespaceOnly(t) {
    let r = this.#e;
    return Array.prototype.every.call(t, (n) => r.has(n));
  }
  #t(t) {
    let r = Number.POSITIVE_INFINITY;
    for (let n of t.split(`
`)) {
      if (n.length === 0) continue;
      let s = this.getLeadingWhitespaceCount(n);
      if (s === 0) return 0;
      n.length !== s && s < r && (r = s);
    }
    return r === Number.POSITIVE_INFINITY ? 0 : r;
  }
  dedentString(t) {
    let r = this.#t(t);
    return r === 0 ? t : t.split(`
`).map((n) => n.slice(r)).join(`
`);
  }
}, Iu = gs;
var Zr = new Iu(` 
\r	`), hs = (e) => e === "" || e === A || e === y || e === f;
function jc(e, t, r) {
  let { node: n } = e;
  if (n.type === "JSXElement" && Zc(n)) return [r("openingElement"), r("closingElement")];
  let s = n.type === "JSXElement" ? r("openingElement") : r("openingFragment"), i = n.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (n.children.length === 1 && n.children[0].type === "JSXExpressionContainer" && (n.children[0].expression.type === "TemplateLiteral" || n.children[0].expression.type === "TaggedTemplateExpression")) return [s, ...e.map(r, "children"), i];
  n.children = n.children.map((x2) => el(x2) ? { type: "JSXText", value: " ", raw: " " } : x2);
  let u = n.children.some(Y2), o = n.children.filter((x2) => x2.type === "JSXExpressionContainer").length > 1, a2 = n.type === "JSXElement" && n.openingElement.attributes.length > 1, p = re(s) || u || a2 || o, D2 = e.parent.rootMarker === "mdx", l2 = t.singleQuote ? "{' '}" : '{" "}', E = D2 ? A : b([l2, f], " "), d2 = n.openingElement?.name?.name === "fbt", F2 = Rc(e, t, r, E, d2), B2 = n.children.some((x2) => Ar(x2));
  for (let x2 = F2.length - 2; x2 >= 0; x2--) {
    let h = F2[x2] === "" && F2[x2 + 1] === "", N = F2[x2] === y && F2[x2 + 1] === "" && F2[x2 + 2] === y, W2 = (F2[x2] === f || F2[x2] === y) && F2[x2 + 1] === "" && F2[x2 + 2] === E, De2 = F2[x2] === E && F2[x2 + 1] === "" && (F2[x2 + 2] === f || F2[x2 + 2] === y), q2 = F2[x2] === E && F2[x2 + 1] === "" && F2[x2 + 2] === E, K2 = F2[x2] === f && F2[x2 + 1] === "" && F2[x2 + 2] === y || F2[x2] === y && F2[x2 + 1] === "" && F2[x2 + 2] === f;
    N && B2 || h || W2 || q2 || K2 ? F2.splice(x2, 2) : De2 && F2.splice(x2 + 1, 2);
  }
  for (; F2.length > 0 && hs(_(0, F2, -1)); ) F2.pop();
  for (; F2.length > 1 && hs(F2[0]) && hs(F2[1]); ) F2.shift(), F2.shift();
  let S2 = [""];
  for (let [x2, h] of F2.entries()) {
    if (h === E) {
      if (x2 === 1 && ki(F2[x2 - 1])) {
        if (F2.length === 2) {
          S2.push([S2.pop(), l2]);
          continue;
        }
        S2.push([l2, y], "");
        continue;
      } else if (x2 === F2.length - 1) {
        S2.push([S2.pop(), l2]);
        continue;
      } else if (F2[x2 - 1] === "" && F2[x2 - 2] === y) {
        S2.push([S2.pop(), l2]);
        continue;
      }
    }
    x2 % 2 === 0 ? S2.push([S2.pop(), h]) : S2.push(h, ""), re(h) && (p = true);
  }
  let L2 = B2 ? Hr(S2) : c(S2, { shouldBreak: true });
  if (t.cursorNode?.type === "JSXText" && n.children.includes(t.cursorNode) ? L2 = [dr, L2, dr] : t.nodeBeforeCursor?.type === "JSXText" && n.children.includes(t.nodeBeforeCursor) ? L2 = [dr, L2] : t.nodeAfterCursor?.type === "JSXText" && n.children.includes(t.nodeAfterCursor) && (L2 = [L2, dr]), D2) return L2;
  let g2 = c([s, m([y, L2]), y, i]);
  return p ? g2 : rt2([c([s, ...F2, i]), g2]);
}
function Rc(e, t, r, n, s) {
  let i = "", u = [i];
  function o(p) {
    i = p, u.push([u.pop(), p]);
  }
  function a2(p) {
    p !== "" && (i = p, u.push(p, ""));
  }
  return e.each(({ node: p, next: D2 }) => {
    if (p.type === "JSXText") {
      let l2 = pe2(p);
      if (Ar(p)) {
        let E = Zr.split(l2, true);
        E[0] === "" && (E.shift(), /\n/u.test(E[0]) ? a2(Ou(s, E[1], p, D2)) : a2(n), E.shift());
        let d2;
        if (_(0, E, -1) === "" && (E.pop(), d2 = E.pop()), E.length === 0) return;
        for (let [F2, B2] of E.entries()) F2 % 2 === 1 ? a2(A) : o(B2);
        d2 !== void 0 ? /\n/u.test(d2) ? a2(Ou(s, i, p, D2)) : a2(n) : a2(Lu(s, i, p, D2));
      } else /\n/u.test(l2) ? l2.match(/\n/gu).length > 1 && a2(y) : a2(n);
    } else {
      let l2 = r();
      if (o(l2), D2 && Ar(D2)) {
        let d2 = Zr.trim(pe2(D2)), [F2] = Zr.split(d2);
        a2(Lu(s, F2, p, D2));
      } else a2(y);
    }
  }, "children"), u;
}
function Lu(e, t, r, n) {
  return e ? "" : r.type === "JSXElement" && !r.closingElement || n?.type === "JSXElement" && !n.closingElement ? t.length === 1 ? f : y : f;
}
function Ou(e, t, r, n) {
  return e ? y : t.length === 1 ? r.type === "JSXElement" && !r.closingElement || n?.type === "JSXElement" && !n.closingElement ? y : f : y;
}
var Jc = P(["ArrayExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "NewExpression", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot", "MatchExpressionCase"]);
function Gc(e, t, r) {
  let { parent: n } = e;
  if (Jc(n)) return t;
  let s = Wc(e), i = xe(e, r);
  return c([i ? "" : b("("), m([f, t]), f, i ? "" : b(")")], { shouldBreak: s });
}
function Wc(e) {
  return e.match(void 0, (t, r) => r === "body" && t.type === "ArrowFunctionExpression", (t, r) => r === "arguments" && M(t)) && (e.match(void 0, void 0, void 0, (t, r) => r === "expression" && t.type === "JSXExpressionContainer") || e.match(void 0, void 0, void 0, (t, r) => r === "expression" && t.type === "ChainExpression", (t, r) => r === "expression" && t.type === "JSXExpressionContainer"));
}
function qc(e, t, r) {
  let { node: n } = e, s = [r("name")];
  if (n.value) {
    let i;
    if (H(n.value)) {
      let u = pe2(n.value), o = J(0, J(0, u.slice(1, -1), "&apos;", "'"), "&quot;", '"'), a2 = kr(o, t.jsxSingleQuote);
      o = a2 === '"' ? J(0, o, '"', "&quot;") : J(0, o, "'", "&apos;"), i = e.call(() => me(e, Ge2(a2 + o + a2), t), "value");
    } else i = r("value");
    s.push("=", i);
  }
  return s;
}
function Yc(e, t, r) {
  let { node: n } = e, s = (i, u) => i.type === "JSXEmptyExpression" || !C(i) && (G(i) || se(i) || i.type === "ArrowFunctionExpression" || i.type === "AwaitExpression" && (s(i.argument, i) || i.argument.type === "JSXElement") || M(i) || i.type === "ChainExpression" && M(i.expression) || i.type === "FunctionExpression" || i.type === "TemplateLiteral" || i.type === "TaggedTemplateExpression" || i.type === "DoExpression" || Y2(u) && (i.type === "ConditionalExpression" || Ae(i)));
  return s(n.expression, e.parent) ? c(["{", r("expression"), we2, "}"]) : c(["{", m([f, r("expression")]), f, we2, "}"]);
}
function Uc(e, t, r) {
  let { node: n } = e, s = C(n.name) || C(n.typeArguments);
  if (n.selfClosing && n.attributes.length === 0 && !s) return ["<", r("name"), r("typeArguments"), " />"];
  if (n.attributes?.length === 1 && H(n.attributes[0].value) && !n.attributes[0].value.value.includes(`
`) && !s && !C(n.attributes[0])) return c(["<", r("name"), r("typeArguments"), " ", ...e.map(r, "attributes"), n.selfClosing ? " />" : ">"]);
  let i = n.attributes?.some((o) => H(o.value) && o.value.value.includes(`
`)), u = t.singleAttributePerLine && n.attributes.length > 1 ? y : A;
  return c(["<", r("name"), r("typeArguments"), m(e.map(() => [u, r()], "attributes")), ...Hc(n, t, s)], { shouldBreak: i });
}
function Hc(e, t, r) {
  return e.selfClosing ? [A, "/>"] : Xc(e, t, r) ? [">"] : [f, ">"];
}
function Xc(e, t, r) {
  let n = e.attributes.length > 0 && C(_(0, e.attributes, -1), T.Trailing);
  return e.attributes.length === 0 && !r || (t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !n;
}
function Vc(e, t, r) {
  let { node: n } = e, s = ["</"], i = r("name");
  return C(n.name, T.Leading | T.Line) ? s.push(m([y, i]), y) : C(n.name, T.Leading | T.Block) ? s.push(" ", i) : s.push(i), s.push(">"), s;
}
function $c(e, t) {
  let { node: r } = e, n = C(r), s = C(r, T.Line), i = r.type === "JSXOpeningFragment";
  return [i ? "<" : "</", m([s ? y : n && !i ? " " : "", v(e, t)]), s ? y : "", ">"];
}
function Kc(e, t, r) {
  let n = me(e, jc(e, t, r), t);
  return Gc(e, n, t);
}
function Qc(e, t) {
  let { node: r } = e, n = C(r, T.Line);
  return [v(e, t, { indent: n }), n ? y : ""];
}
function zc(e, t, r) {
  let { node: n } = e;
  return ["{", e.call(({ node: s }) => {
    let i = ["...", r()];
    return C(s) ? [m([f, me(e, i, t)]), f] : i;
  }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function wu(e, t, r) {
  let { node: n } = e;
  if (n.type.startsWith("JSX")) switch (n.type) {
    case "JSXAttribute":
      return qc(e, t, r);
    case "JSXIdentifier":
      return n.name;
    case "JSXNamespacedName":
      return I(":", [r("namespace"), r("name")]);
    case "JSXMemberExpression":
      return I(".", [r("object"), r("property")]);
    case "JSXSpreadAttribute":
    case "JSXSpreadChild":
      return zc(e, t, r);
    case "JSXExpressionContainer":
      return Yc(e, t, r);
    case "JSXFragment":
    case "JSXElement":
      return Kc(e, t, r);
    case "JSXOpeningElement":
      return Uc(e, t, r);
    case "JSXClosingElement":
      return Vc(e, t, r);
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      return $c(e, t);
    case "JSXEmptyExpression":
      return Qc(e, t);
    case "JSXText":
      throw new Error("JSXText should be handled by JSXElement");
    default:
      throw new $e2(n, "JSX");
  }
}
function Zc(e) {
  if (e.children.length === 0) return true;
  if (e.children.length > 1) return false;
  let t = e.children[0];
  return t.type === "JSXText" && !Ar(t);
}
function Ar(e) {
  return e.type === "JSXText" && (Zr.hasNonWhitespaceCharacter(pe2(e)) || !/\n/u.test(pe2(e)));
}
function el(e) {
  return e.type === "JSXExpressionContainer" && H(e.expression) && e.expression.value === " " && !C(e.expression);
}
function Mu(e) {
  let { node: t, parent: r } = e;
  if (!Y2(t) || !Y2(r)) return false;
  let { index: n, siblings: s } = e, i;
  for (let u = n; u > 0; u--) {
    let o = s[u - 1];
    if (!(o.type === "JSXText" && !Ar(o))) {
      i = o;
      break;
    }
  }
  return i?.type === "JSXExpressionContainer" && i.expression.type === "JSXEmptyExpression" && It(i.expression);
}
function tl(e) {
  return It(e.node) || Mu(e);
}
var Qt = tl;
var rl = 0;
function en(e, t, r) {
  let { node: n, parent: s, grandparent: i, key: u } = e, o = u !== "body" && (s.type === "IfStatement" || s.type === "WhileStatement" || s.type === "SwitchStatement" || s.type === "DoWhileStatement"), a2 = n.operator === "|>" && e.root.extra?.__isUsingHackPipeline, p = Ss(e, t, r, false, o);
  if (o) return p;
  if (a2) return c(p);
  if (u === "callee" && (M(s) || s.type === "NewExpression") || s.type === "UnaryExpression" || R(s) && !s.computed) return c([m([f, ...p]), f]);
  let D2 = s.type === "ReturnStatement" || s.type === "ThrowStatement" || s.type === "JSXExpressionContainer" && i.type === "JSXAttribute" || n.operator !== "|" && s.type === "JsExpressionRoot" || n.type !== "NGPipeExpression" && (s.type === "NGRoot" && t.parser === "__ng_binding" || s.type === "NGMicrosyntaxExpression" && i.type === "NGMicrosyntax" && i.body.length === 1) || n === s.body && s.type === "ArrowFunctionExpression" || n !== s.body && s.type === "ForStatement" || s.type === "ConditionalExpression" && i.type !== "ReturnStatement" && i.type !== "ThrowStatement" && !M(i) && i.type !== "NewExpression" || s.type === "TemplateLiteral" || sl(e), l2 = s.type === "AssignmentExpression" || s.type === "VariableDeclarator" || s.type === "ClassProperty" || s.type === "PropertyDefinition" || s.type === "TSAbstractPropertyDefinition" || s.type === "ClassPrivateProperty" || ke(s), E = Ae(n.left) && yr(n.operator, n.left.operator);
  if (D2 || zt(n) && !E || !zt(n) && l2) return c(p);
  if (p.length === 0) return "";
  let d2 = Y2(n.right), F2 = p.findIndex((h) => typeof h != "string" && !Array.isArray(h) && h.type === ye), B2 = p.slice(0, F2 === -1 ? 1 : F2 + 1), S2 = p.slice(B2.length, d2 ? -1 : void 0), L2 = Symbol("logicalChain-" + ++rl), g2 = c([...B2, m(S2)], { id: L2 });
  if (!d2) return g2;
  let x2 = _(0, p, -1);
  return c([g2, ft(x2, { groupId: L2 })]);
}
function Ss(e, t, r, n, s) {
  let { node: i } = e;
  if (!Ae(i)) return [c(r())];
  let u = [];
  yr(i.operator, i.left.operator) ? u = e.call(() => Ss(e, t, r, true, s), "left") : u.push(c(r("left")));
  let o = zt(i), a2 = i.right.type === "ChainExpression" ? i.right.expression : i.right, p = (i.operator === "|>" || i.type === "NGPipeExpression" || nl(e, t)) && !de(t.originalText, a2), l2 = !C(a2, T.Leading, Vr) && de(t.originalText, a2), E = i.type === "NGPipeExpression" ? "|" : i.operator, d2 = i.type === "NGPipeExpression" && i.arguments.length > 0 ? c(m([f, ": ", I([A, ": "], e.map(() => Te(2, c(r())), "arguments"))])) : "", F2;
  if (o) F2 = [E, de(t.originalText, a2) ? m([A, r("right"), d2]) : [" ", r("right"), d2]];
  else {
    let x2 = E === "|>" && e.root.extra?.__isUsingHackPipeline ? e.call(() => Ss(e, t, r, true, s), "right") : r("right");
    if (t.experimentalOperatorPosition === "start") {
      let h = "";
      if (l2) switch (Je2(x2)) {
        case ge:
          h = x2.splice(0, 1)[0];
          break;
        case Se2:
          h = x2.contents.splice(0, 1)[0];
          break;
      }
      F2 = [A, h, E, " ", x2, d2];
    } else F2 = [p ? A : "", E, p ? " " : A, x2, d2];
  }
  let { parent: B2 } = e, S2 = C(i.left, T.Trailing | T.Line);
  if ((S2 || !(s && i.type === "LogicalExpression") && B2.type !== i.type && i.left.type !== i.type && i.right.type !== i.type) && (F2 = c(F2, { shouldBreak: S2 })), t.experimentalOperatorPosition === "start" ? u.push(o || l2 ? " " : "", F2) : u.push(p ? "" : " ", F2), n && C(i)) {
    let g2 = $t(me(e, u, t));
    return g2.type === Le ? g2.parts : Array.isArray(g2) ? g2 : [g2];
  }
  return u;
}
function zt(e) {
  return e.type !== "LogicalExpression" ? false : !!(se(e.right) && e.right.properties.length > 0 || G(e.right) && e.right.elements.length > 0 || Y2(e.right));
}
var _u = (e) => e.type === "BinaryExpression" && e.operator === "|";
function nl(e, t) {
  return (t.parser === "__vue_expression" || t.parser === "__vue_ts_expression") && _u(e.node) && !e.hasAncestor((r) => !_u(r) && r.type !== "JsExpressionRoot");
}
function sl(e) {
  if (e.key !== "arguments") return false;
  let { parent: t } = e;
  if (!(M(t) && !t.optional && t.arguments.length === 1)) return false;
  let { callee: r } = t;
  return r.type === "Identifier" && r.name === "Boolean";
}
function vu(e, t, r) {
  let { node: n } = e;
  if (n.type.startsWith("NG")) switch (n.type) {
    case "NGRoot":
      return r("node");
    case "NGPipeExpression":
      return en(e, t, r);
    case "NGChainedExpression":
      return c(I([";", A], e.map(() => ol(e) ? r() : ["(", r(), ")"], "expressions")));
    case "NGEmptyExpression":
      return "";
    case "NGMicrosyntax":
      return e.map(() => [e.isFirst ? "" : Nu(e) ? " " : [";", A], r()], "body");
    case "NGMicrosyntaxKey":
      return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(n.name) ? n.name : JSON.stringify(n.name);
    case "NGMicrosyntaxExpression":
      return [r("expression"), n.alias === null ? "" : [" as ", r("alias")]];
    case "NGMicrosyntaxKeyedExpression": {
      let { index: s, parent: i } = e, u = Nu(e) || il(e) || (s === 1 && (n.key.name === "then" || n.key.name === "else" || n.key.name === "as") || s === 2 && (n.key.name === "else" && i.body[s - 1].type === "NGMicrosyntaxKeyedExpression" && i.body[s - 1].key.name === "then" || n.key.name === "track")) && i.body[0].type === "NGMicrosyntaxExpression";
      return [r("key"), u ? " " : ": ", r("expression")];
    }
    case "NGMicrosyntaxLet":
      return ["let ", r("key"), n.value === null ? "" : [" = ", r("value")]];
    case "NGMicrosyntaxAs":
      return [r("key"), " as ", r("alias")];
    default:
      throw new $e2(n, "Angular");
  }
}
function Nu({ node: e, index: t }) {
  return e.type === "NGMicrosyntaxKeyedExpression" && e.key.name === "of" && t === 1;
}
function il(e) {
  let { node: t } = e;
  return e.parent.body[1].key.name === "of" && t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "track" && t.key.type === "NGMicrosyntaxKey";
}
var ul = P(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function ol({ node: e }) {
  return Dr(e, ul);
}
function Bs(e, t, r) {
  let { node: n } = e;
  return c([I(A, e.map(r, "decorators")), Ju(n, t) ? y : A]);
}
function ju(e, t, r) {
  return Gu(e.node) ? [I(y, e.map(r, "declaration", "decorators")), y] : "";
}
function Ru(e, t, r) {
  let { node: n, parent: s } = e, { decorators: i } = n;
  if (!j(i) || Gu(s) || Qt(e)) return "";
  let u = n.type === "ClassExpression" || n.type === "ClassDeclaration" || Ju(n, t);
  return [e.key === "declaration" && ci(s) ? y : u ? Be : "", I(A, e.map(r, "decorators")), A];
}
function Ju(e, t) {
  return e.decorators.some((r) => Q2(t.originalText, k(r)));
}
function Gu(e) {
  if (e.type !== "ExportDefaultDeclaration" && e.type !== "ExportNamedDeclaration" && e.type !== "DeclareExportDeclaration") return false;
  let t = e.declaration?.decorators;
  return j(t) && St(e, t[0]);
}
var yt = class extends Error {
  name = "ArgExpansionBailout";
};
function al(e, t, r) {
  let { node: n } = e, s = ce(n);
  if (s.length === 0) return ["(", v(e, t), ")"];
  let i = s.length - 1;
  if (ll(s)) {
    let l2 = ["("];
    return Xt(e, (E, d2) => {
      l2.push(r()), d2 !== i && l2.push(", ");
    }), l2.push(")"), l2;
  }
  let u = false, o = [];
  Xt(e, ({ node: l2 }, E) => {
    let d2 = r();
    E === i || (ue2(l2, t) ? (u = true, d2 = [d2, ",", y, y]) : d2 = [d2, ",", A]), o.push(d2);
  });
  let a2 = !t.parser.startsWith("__ng_") && n.type !== "ImportExpression" && n.type !== "TSImportType" && n.type !== "TSExternalModuleReference" && ie(t, "all") ? "," : "";
  function p() {
    return c(["(", m([A, ...o]), a2, A, ")"], { shouldBreak: true });
  }
  if (u || e.parent.type !== "Decorator" && Ei(s)) return p();
  if (cl(s)) {
    let l2 = o.slice(1);
    if (l2.some(re)) return p();
    let E;
    try {
      E = r(Xn(n, 0), { expandFirstArg: true });
    } catch (d2) {
      if (d2 instanceof yt) return p();
      throw d2;
    }
    return re(E) ? [Be, rt2([["(", c(E, { shouldBreak: true }), ", ", ...l2, ")"], p()])] : rt2([["(", E, ", ", ...l2, ")"], ["(", c(E, { shouldBreak: true }), ", ", ...l2, ")"], p()]);
  }
  if (pl(s, o, t)) {
    let l2 = o.slice(0, -1);
    if (l2.some(re)) return p();
    let E;
    try {
      E = r(Xn(n, -1), { expandLastArg: true });
    } catch (d2) {
      if (d2 instanceof yt) return p();
      throw d2;
    }
    return re(E) ? [Be, rt2([["(", ...l2, c(E, { shouldBreak: true }), ")"], p()])] : rt2([["(", ...l2, E, ")"], ["(", ...l2, c(E, { shouldBreak: true }), ")"], p()]);
  }
  let D2 = ["(", m([f, ...o]), b(a2), f, ")"];
  return Jr(e) ? D2 : c(D2, { shouldBreak: o.some(re) || u });
}
function Tr(e, t = false) {
  return se(e) && (e.properties.length > 0 || C(e)) || G(e) && (e.elements.length > 0 || C(e)) || e.type === "TSTypeAssertion" && Tr(e.expression) || Ce2(e) && Tr(e.expression) || e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && (!e.returnType || !e.returnType.typeAnnotation || e.returnType.typeAnnotation.type !== "TSTypeReference" || ml(e.body)) && (e.body.type === "BlockStatement" || e.body.type === "ArrowFunctionExpression" && Tr(e.body, true) || se(e.body) || G(e.body) || !t && (M(e.body) || e.body.type === "ConditionalExpression") || Y2(e.body)) || e.type === "DoExpression" || e.type === "ModuleExpression";
}
function pl(e, t, r) {
  let n = _(0, e, -1);
  if (e.length === 1) {
    let i = _(0, t, -1);
    if (i.label?.embed && i.label?.hug !== false) return true;
  }
  let s = _(0, e, -2);
  return !C(n, T.Leading) && !C(n, T.Trailing) && Tr(n) && (!s || s.type !== n.type) && (e.length !== 2 || s.type !== "ArrowFunctionExpression" || !G(n)) && !(e.length > 1 && bs(n, r));
}
function cl(e) {
  if (e.length !== 2) return false;
  let [t, r] = e;
  return t.type === "ModuleExpression" && Dl(r) ? true : !C(t) && (t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && qu(r) && !Tr(r);
}
function qu(e) {
  if (e.type === "ParenthesizedExpression") return qu(e.expression);
  if (Ce2(e) || e.type === "TypeCastExpression") {
    let { typeAnnotation: t } = e;
    if (t.type === "TypeAnnotation" && (t = t.typeAnnotation), t.type === "TSArrayType" && (t = t.elementType, t.type === "TSArrayType" && (t = t.elementType)), t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") {
      let r = t.type === "GenericTypeAnnotation" ? t.typeParameters : t.typeArguments;
      r?.params.length === 1 && (t = r.params[0]);
    }
    return Ht(t) && je(e.expression, 1);
  }
  return mt(e) && ce(e).length > 1 ? false : Ae(e) ? je(e.left, 1) && je(e.right, 1) : Un(e) || je(e);
}
function ll(e) {
  return e.length === 2 ? Wu(e, 0) : e.length === 3 ? e[0].type === "Identifier" && Wu(e, 1) : false;
}
function Wu(e, t) {
  let r = e[t], n = e[t + 1];
  return r.type === "ArrowFunctionExpression" && $(r).length === 0 && r.body.type === "BlockStatement" && n.type === "ArrayExpression" && !e.some((s) => C(s));
}
function ml(e) {
  return e.type === "BlockStatement" && (e.body.some((t) => t.type !== "EmptyStatement") || C(e, T.Dangling));
}
function Dl(e) {
  if (!(e.type === "ObjectExpression" && e.properties.length === 1)) return false;
  let [t] = e.properties;
  return ke(t) ? !t.computed && (t.key.type === "Identifier" && t.key.name === "type" || H(t.key) && t.key.value === "type") && H(t.value) && t.value.value === "module" : false;
}
var xr = al;
var fl = (e) => ((e.type === "ChainExpression" || e.type === "TSNonNullExpression") && (e = e.expression), M(e) && ce(e).length > 0);
function yl(e) {
  let { node: t, ancestors: r } = e;
  for (let n of r) {
    if (!(R(n) && n.object === t || n.type === "TSNonNullExpression" && n.expression === t)) return n.type === "NewExpression" && n.callee === t;
    t = n;
  }
  return false;
}
function Yu(e, t, r) {
  let n = r("object"), s = Ps(e, t, r), { node: i } = e, u = e.findAncestor((p) => !(R(p) || p.type === "TSNonNullExpression")), o = e.findAncestor((p) => !(p.type === "ChainExpression" || p.type === "TSNonNullExpression")), a2 = u.type === "BindExpression" || u.type === "AssignmentExpression" && u.left.type !== "Identifier" || yl(e) || i.computed || i.object.type === "Identifier" && i.property.type === "Identifier" && !R(o) || (o.type === "AssignmentExpression" || o.type === "VariableDeclarator") && (fl(i.object) || n.label?.memberChain);
  return ot2(n.label, [n, a2 ? s : c(m([f, s]))]);
}
function Ps(e, t, r) {
  let n = r("property"), { node: s } = e, i = V(e);
  return s.computed ? !s.property || Fe(s.property) ? [i, "[", n, "]"] : c([i, "[", m([f, n]), f, "]"]) : [i, ".", n];
}
function Uu(e, t, r) {
  if (e.node.type === "ChainExpression") return e.call(() => Uu(e, t, r), "expression");
  let n = (e.parent.type === "ChainExpression" ? e.grandparent : e.parent).type === "ExpressionStatement", s = [];
  function i(w) {
    let { originalText: te2 } = t, ae2 = pt(te2, k(w));
    return te2.charAt(ae2) === ")" ? ae2 !== false && qt(te2, ae2 + 1) : ue2(w, t);
  }
  function u() {
    let { node: w } = e;
    if (w.type === "ChainExpression") return e.call(u, "expression");
    if (M(w) && (At(w.callee) || M(w.callee))) {
      let te2 = i(w);
      s.unshift({ node: w, hasTrailingEmptyLine: te2, printed: [me(e, [V(e), r("typeArguments"), xr(e, t, r)], t), te2 ? y : ""] }), e.call(u, "callee");
    } else At(w) ? (s.unshift({ node: w, needsParens: xe(e, t), printed: me(e, R(w) ? Ps(e, t, r) : tn(e, t, r), t) }), e.call(u, "object")) : w.type === "TSNonNullExpression" ? (s.unshift({ node: w, printed: me(e, "!", t) }), e.call(u, "expression")) : s.unshift({ node: w, printed: r() });
  }
  let { node: o } = e;
  s.unshift({ node: o, printed: [V(e), r("typeArguments"), xr(e, t, r)] }), o.callee && e.call(u, "callee");
  let a2 = [], p = [s[0]], D2 = 1;
  for (; D2 < s.length && (s[D2].node.type === "TSNonNullExpression" || M(s[D2].node) || R(s[D2].node) && s[D2].node.computed && Fe(s[D2].node.property)); ++D2) p.push(s[D2]);
  if (!M(s[0].node)) for (; D2 + 1 < s.length && (At(s[D2].node) && At(s[D2 + 1].node)); ++D2) p.push(s[D2]);
  a2.push(p), p = [];
  let l2 = false;
  for (; D2 < s.length; ++D2) {
    if (l2 && At(s[D2].node)) {
      if (s[D2].node.computed && Fe(s[D2].node.property)) {
        p.push(s[D2]);
        continue;
      }
      a2.push(p), p = [], l2 = false;
    }
    (M(s[D2].node) || s[D2].node.type === "ImportExpression") && (l2 = true), p.push(s[D2]), C(s[D2].node, T.Trailing) && (a2.push(p), p = [], l2 = false);
  }
  p.length > 0 && a2.push(p);
  function E(w) {
    return /^[A-Z]|^[$_]+$/u.test(w);
  }
  function d2(w) {
    return w.length <= t.tabWidth;
  }
  function F2(w) {
    let te2 = w[1][0]?.node.computed;
    if (w[0].length === 1) {
      let st2 = w[0][0].node;
      return st2.type === "ThisExpression" || st2.type === "Identifier" && (E(st2.name) || n && d2(st2.name) || te2);
    }
    let ae2 = _(0, w[0], -1).node;
    return R(ae2) && ae2.property.type === "Identifier" && (E(ae2.property.name) || te2);
  }
  let B2 = a2.length >= 2 && !C(a2[1][0].node) && F2(a2);
  function S2(w) {
    let te2 = w.map((ae2) => ae2.printed);
    return w.length > 0 && _(0, w, -1).needsParens ? ["(", ...te2, ")"] : te2;
  }
  function L2(w) {
    return w.length === 0 ? "" : m([y, I(y, w.map(S2))]);
  }
  let g2 = a2.map(S2), x2 = g2, h = B2 ? 3 : 2, N = a2.flat(), W2 = N.slice(1, -1).some((w) => C(w.node, T.Leading)) || N.slice(0, -1).some((w) => C(w.node, T.Trailing)) || a2[h] && C(a2[h][0].node, T.Leading);
  if (a2.length <= h && !W2 && !a2.some((w) => _(0, w, -1).hasTrailingEmptyLine)) return Jr(e) ? x2 : c(x2);
  let De2 = _(0, a2[B2 ? 1 : 0], -1).node, q2 = !M(De2) && i(De2), K2 = [S2(a2[0]), B2 ? a2.slice(1, 2).map(S2) : "", q2 ? y : "", L2(a2.slice(B2 ? 2 : 1))], Z2 = s.map(({ node: w }) => w).filter(M);
  function be2() {
    let w = _(0, _(0, a2, -1), -1).node, te2 = _(0, g2, -1);
    return M(w) && re(te2) && Z2.slice(0, -1).some((ae2) => ae2.arguments.some(Yt));
  }
  let nt2;
  return W2 || Z2.length > 2 && Z2.some((w) => !w.arguments.every((te2) => je(te2))) || g2.slice(0, -1).some(re) || be2() ? nt2 = c(K2) : nt2 = [re(x2) || q2 ? Be : "", rt2([x2, K2])], ot2({ memberChain: true }, nt2);
}
var Hu = Uu;
function _t(e, t, r) {
  let { node: n } = e, s = n.type === "NewExpression", i = V(e), u = ce(n), o = n.type !== "TSImportType" && n.typeArguments ? r("typeArguments") : "", a2 = u.length === 1 && jr(u[0], t.originalText);
  if (a2 || Fl(e) || dl(e) || Pt(n, e.parent)) {
    let l2 = [];
    if (Xt(e, () => {
      l2.push(r());
    }), !(a2 && l2[0].label?.embed)) return [s ? "new " : "", Xu(e, r), i, o, "(", I(", ", l2), ")"];
  }
  let p = n.type === "ImportExpression" || n.type === "TSImportType" || n.type === "TSExternalModuleReference";
  if (!p && !s && At(n.callee) && !e.call(() => xe(e, t), "callee", ...n.callee.type === "ChainExpression" ? ["expression"] : [])) return Hu(e, t, r);
  let D2 = [s ? "new " : "", Xu(e, r), i, o, xr(e, t, r)];
  return p || M(n.callee) ? c(D2) : D2;
}
function Xu(e, t) {
  let { node: r } = e;
  return r.type === "ImportExpression" ? `import${r.phase ? `.${r.phase}` : ""}` : r.type === "TSImportType" ? "import" : r.type === "TSExternalModuleReference" ? "require" : t("callee");
}
var El = ["require", "require.resolve", "require.resolve.paths", "import.meta.resolve"];
function Fl(e) {
  let { node: t } = e;
  if (!(t.type === "ImportExpression" || t.type === "TSImportType" || t.type === "TSExternalModuleReference" || t.type === "CallExpression" && !t.optional && Bt(t.callee, El))) return false;
  let r = ce(t);
  return r.length === 1 && H(r[0]) && !C(r[0]);
}
function dl(e) {
  let { node: t } = e;
  if (t.type !== "CallExpression" || t.optional || t.callee.type !== "Identifier") return false;
  let r = ce(t);
  return t.callee.name === "require" ? (r.length === 1 && H(r[0]) || r.length > 1) && !C(r[0]) : t.callee.name === "define" && e.parent.type === "ExpressionStatement" ? r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && H(r[0]) && r[1].type === "ArrayExpression" : false;
}
function xt(e, t, r, n, s, i) {
  let u = Cl(e, t, r, n, i), o = i ? r(i, { assignmentLayout: u }) : "";
  switch (u) {
    case "break-after-operator":
      return c([c(n), s, c(m([A, o]))]);
    case "never-break-after-operator":
      return c([c(n), s, " ", o]);
    case "fluid": {
      let a2 = Symbol("assignment");
      return c([c(n), s, c(m(A), { id: a2 }), we2, ft(o, { groupId: a2 })]);
    }
    case "break-lhs":
      return c([n, s, " ", c(o)]);
    case "chain":
      return [c(n), s, A, o];
    case "chain-tail":
      return [c(n), s, m([A, o])];
    case "chain-tail-arrow-chain":
      return [c(n), s, o];
    case "only-left":
      return n;
  }
}
function Ku(e, t, r) {
  let { node: n } = e;
  return xt(e, t, r, r("left"), [" ", n.operator], "right");
}
function Qu(e, t, r) {
  return xt(e, t, r, r("id"), " =", "init");
}
function Cl(e, t, r, n, s) {
  let { node: i } = e, u = i[s];
  if (!u) return "only-left";
  let o = !rn(u);
  if (e.match(rn, zu, (E) => !o || E.type !== "ExpressionStatement" && E.type !== "VariableDeclaration")) return o ? u.type === "ArrowFunctionExpression" && u.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!o && rn(u.right) || de(t.originalText, u)) return "break-after-operator";
  if (i.type === "ImportAttribute" || u.type === "CallExpression" && u.callee.name === "require" || t.parser === "json5" || t.parser === "jsonc" || t.parser === "json") return "never-break-after-operator";
  let D2 = Pi(n);
  if (Tl(i) || hl(i) || ks(i) && D2) return "break-lhs";
  let l2 = Sl(i, n, t);
  return e.call(() => Al(e, t, r, l2), s) ? "break-after-operator" : xl(i) ? "break-lhs" : !D2 && (l2 || u.type === "TemplateLiteral" || u.type === "TaggedTemplateExpression" || mi(u) || Fe(u) || u.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function Al(e, t, r, n) {
  let s = e.node;
  if (Ae(s) && !zt(s)) return true;
  switch (s.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return true;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!t.experimentalTernaries && !Pl(s)) break;
      return true;
    case "ConditionalExpression": {
      if (!t.experimentalTernaries) {
        let { test: p } = s;
        return Ae(p) && !zt(p);
      }
      let { consequent: o, alternate: a2 } = s;
      return o.type === "ConditionalExpression" || a2.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return j(s.decorators);
  }
  if (n) return false;
  let i = s, u = [];
  for (; ; ) if (i.type === "UnaryExpression" || i.type === "AwaitExpression" || i.type === "YieldExpression" && i.argument !== null) i = i.argument, u.push("argument");
  else if (i.type === "TSNonNullExpression") i = i.expression, u.push("expression");
  else break;
  return !!(H(i) || e.call(() => Zu(e, t, r), ...u));
}
function Tl(e) {
  if (zu(e)) {
    let t = e.left || e.id;
    return t.type === "ObjectPattern" && t.properties.length > 2 && t.properties.some((r) => ke(r) && (!r.shorthand || r.value?.type === "AssignmentPattern"));
  }
  return false;
}
function rn(e) {
  return e.type === "AssignmentExpression";
}
function zu(e) {
  return rn(e) || e.type === "VariableDeclarator";
}
function xl(e) {
  let t = gl(e);
  if (j(t)) {
    let r = e.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (t.length > 1 && t.some((n) => n[r] || n.default)) return true;
  }
  return false;
}
function gl(e) {
  if (Er(e)) return e.typeParameters?.params;
}
function hl(e) {
  if (e.type !== "VariableDeclarator") return false;
  let { typeAnnotation: t } = e.id;
  if (!t || !t.typeAnnotation) return false;
  let r = Vu(t.typeAnnotation);
  return j(r) && r.length > 1 && r.some((n) => j(Vu(n)) || n.type === "TSConditionalType");
}
function ks(e) {
  return e.type === "VariableDeclarator" && e.init?.type === "ArrowFunctionExpression";
}
function Vu(e) {
  let t;
  switch (e.type) {
    case "GenericTypeAnnotation":
      t = e.typeParameters;
      break;
    case "TSTypeReference":
      t = e.typeArguments;
      break;
  }
  return t?.params;
}
function Zu(e, t, r, n = false) {
  let { node: s } = e, i = () => Zu(e, t, r, true);
  if (s.type === "ChainExpression" || s.type === "TSNonNullExpression") return e.call(i, "expression");
  if (M(s)) {
    if (_t(e, t, r).label?.memberChain) return false;
    let o = ce(s);
    return !(o.length === 0 || o.length === 1 && fr(o[0], t)) || Bl(s, r) ? false : e.call(i, "callee");
  }
  return R(s) ? e.call(i, "object") : n && (s.type === "Identifier" || s.type === "ThisExpression");
}
function Sl(e, t, r) {
  return ke(e) ? (t = $t(t), typeof t == "string" && it2(t) < r.tabWidth + 3) : false;
}
function Bl(e, t) {
  let r = bl(e);
  if (j(r)) {
    if (r.length > 1) return true;
    if (r.length === 1) {
      let s = r[0];
      if (Ie(s) || Lt(s) || s.type === "TSTypeLiteral" || s.type === "ObjectTypeAnnotation") return true;
    }
    let n = e.typeParameters ? "typeParameters" : "typeArguments";
    if (re(t(n))) return true;
  }
  return false;
}
function bl(e) {
  return (e.typeParameters ?? e.typeArguments)?.params;
}
function $u(e) {
  switch (e.type) {
    case "FunctionTypeAnnotation":
    case "GenericTypeAnnotation":
    case "TSFunctionType":
      return !!e.typeParameters;
    case "TSTypeReference":
      return !!e.typeArguments;
    default:
      return false;
  }
}
function Pl(e) {
  return $u(e.checkType) || $u(e.extendsType);
}
function kl(e) {
  let t = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return t.has(r) || t.set(r, Symbol(e)), t.get(r);
  };
}
var eo = kl;
function Ke2(e, t, r, n, s) {
  let i = e.node, u = $(i), o = s && i.typeParameters ? r("typeParameters") : "";
  if (u.length === 0) return [o, "(", v(e, t, { filter: (F2) => Ne(t.originalText, k(F2)) === ")" }), ")"];
  let { parent: a2 } = e, p = Pt(a2), D2 = to(i), l2 = [];
  if (Ci(e, (F2, B2) => {
    let S2 = B2 === u.length - 1;
    S2 && i.rest && l2.push("..."), l2.push(r()), !S2 && (l2.push(","), p || D2 ? l2.push(" ") : ue2(u[B2], t) ? l2.push(y, y) : l2.push(A));
  }), n && !Ll(e)) {
    if (re(o) || re(l2)) throw new yt();
    return c([Ot(o), "(", Ot(l2), ")"]);
  }
  let E = u.every((F2) => !j(F2.decorators));
  return D2 && E ? [o, "(", ...l2, ")"] : p ? [o, "(", ...l2, ")"] : (vr(a2) || Di(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === i) && u.length === 1 && u[0].name === null && i.this !== u[0] && u[0].typeAnnotation && i.typeParameters === null && Ht(u[0].typeAnnotation) && !i.rest ? t.arrowParens === "always" || i.type === "HookTypeAnnotation" ? ["(", ...l2, ")"] : l2 : [o, "(", m([f, ...l2]), b(!di(i) && ie(t, "all") ? "," : ""), f, ")"];
}
function to(e) {
  if (!e) return false;
  let t = $(e);
  if (t.length !== 1) return false;
  let [r] = t;
  return !C(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && We2(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && We2(r.typeAnnotation) && r !== e.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || se(r.right) && r.right.properties.length === 0 || G(r.right) && r.right.elements.length === 0));
}
function Il(e) {
  let t;
  return e.returnType ? (t = e.returnType, t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
}
function ct2(e, t) {
  let r = Il(e);
  if (!r) return false;
  let n = e.typeParameters?.params;
  if (n) {
    if (n.length > 1) return false;
    if (n.length === 1) {
      let s = n[0];
      if (s.constraint || s.default) return false;
    }
  }
  return $(e).length === 1 && (We2(r) || re(t));
}
function Ll(e) {
  return e.match((t) => t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement", (t, r) => {
    if (t.type === "CallExpression" && r === "arguments" && t.arguments.length === 1 && t.callee.type === "CallExpression") {
      let n = t.callee.callee;
      return n.type === "Identifier" || n.type === "MemberExpression" && !n.computed && n.object.type === "Identifier" && n.property.type === "Identifier";
    }
    return false;
  }, (t, r) => t.type === "VariableDeclarator" && r === "init" || t.type === "ExportDefaultDeclaration" && r === "declaration" || t.type === "TSExportAssignment" && r === "expression" || t.type === "AssignmentExpression" && r === "right" && t.left.type === "MemberExpression" && t.left.object.type === "Identifier" && t.left.object.name === "module" && t.left.property.type === "Identifier" && t.left.property.name === "exports", (t) => t.type !== "VariableDeclaration" || t.kind === "const" && t.declarations.length === 1);
}
function ro(e) {
  let t = $(e);
  return t.length > 1 && t.some((r) => r.type === "TSParameterProperty");
}
function Nt(e, t) {
  return (t === "params" || t === "this" || t === "rest") && to(e);
}
var Ol = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, wl = (e) => Ol.test(e), no = wl;
function Ml(e) {
  return e.length === 1 ? e : e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
}
var Et = Ml;
var nn = /* @__PURE__ */ new WeakMap();
function io(e) {
  return /^(?:\d+|\d+\.\d+)$/u.test(e);
}
function so(e, t) {
  return t.parser === "json" || t.parser === "jsonc" || !H(e.key) || ut(pe2(e.key), t).slice(1, -1) !== e.key.value ? false : !!(no(e.key.value) && !(t.parser === "babel-ts" && e.type === "ClassProperty" || (t.parser === "typescript" || t.parser === "oxc-ts") && e.type === "PropertyDefinition") || io(e.key.value) && String(Number(e.key.value)) === e.key.value && e.type !== "ImportAttribute" && (t.parser === "babel" || t.parser === "acorn" || t.parser === "oxc" || t.parser === "espree" || t.parser === "meriyah" || t.parser === "__babel_estree"));
}
function _l(e, t) {
  let { key: r } = e.node;
  return (r.type === "Identifier" || Fe(r) && io(Et(pe2(r))) && String(r.value) === Et(pe2(r)) && !(t.parser === "typescript" || t.parser === "babel-ts" || t.parser === "oxc-ts")) && (t.parser === "json" || t.parser === "jsonc" || t.quoteProps === "consistent" && nn.get(e.parent));
}
function Ft(e, t, r) {
  let { node: n } = e;
  if (n.computed) return ["[", r("key"), "]"];
  let { parent: s } = e, { key: i } = n;
  if (t.quoteProps === "consistent" && !nn.has(s)) {
    let u = e.siblings.some((o) => !o.computed && H(o.key) && !so(o, t));
    nn.set(s, u);
  }
  if (_l(e, t)) {
    let u = ut(JSON.stringify(i.type === "Identifier" ? i.name : i.value.toString()), t);
    return e.call(() => me(e, u, t), "key");
  }
  return so(n, t) && (t.quoteProps === "as-needed" || t.quoteProps === "consistent" && !nn.get(s)) ? e.call(() => me(e, /^\d/u.test(i.value) ? Et(i.value) : i.value, t), "key") : r("key");
}
function sn(e, t, r) {
  let { node: n } = e;
  return n.shorthand ? r("value") : xt(e, t, r, Ft(e, t, r), ":", "value");
}
var Nl = ({ node: e, key: t, parent: r }) => t === "value" && e.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && lt2(r));
function un(e, t, r, n) {
  if (Nl(e)) return on(e, t, r);
  let { node: s } = e, i = false;
  if ((s.type === "FunctionDeclaration" || s.type === "FunctionExpression") && n?.expandLastArg) {
    let { parent: D2 } = e;
    M(D2) && (ce(D2).length > 1 || $(s).every((l2) => l2.type === "Identifier" && !l2.typeAnnotation)) && (i = true);
  }
  let u = [z(e), s.async ? "async " : "", `function${s.generator ? "*" : ""} `, s.id ? r("id") : ""], o = Ke2(e, t, r, i), a2 = Zt(e, r), p = ct2(s, a2);
  return u.push(r("typeParameters"), c([p ? c(o) : o, a2]), s.body ? " " : "", r("body")), t.semi && (s.declare || !s.body) && u.push(";"), u;
}
function gr(e, t, r) {
  let { node: n } = e, { kind: s } = n, i = n.value || n, u = [];
  return !s || s === "init" || s === "method" || s === "constructor" ? i.async && u.push("async ") : u.push(s, " "), i.generator && u.push("*"), u.push(Ft(e, t, r), n.optional ? "?" : "", n === i ? on(e, t, r) : r("value")), u;
}
function on(e, t, r) {
  let { node: n } = e, s = Ke2(e, t, r), i = Zt(e, r), u = ro(n), o = ct2(n, i), a2 = [r("typeParameters"), c([u ? c(s, { shouldBreak: true }) : o ? c(s) : s, i])];
  return n.body ? a2.push(" ", r("body")) : a2.push(t.semi ? ";" : ""), a2;
}
function vl(e) {
  let t = $(e);
  return t.length === 1 && !e.typeParameters && !C(e, T.Dangling) && t[0].type === "Identifier" && !t[0].typeAnnotation && !C(t[0]) && !t[0].optional && !e.predicate && !e.returnType;
}
function an(e, t) {
  if (t.arrowParens === "always") return false;
  if (t.arrowParens === "avoid") {
    let { node: r } = e;
    return vl(r);
  }
  return false;
}
function Zt(e, t) {
  let { node: r } = e, s = [U(e, t, "returnType")];
  return r.predicate && s.push(t("predicate")), s;
}
function uo(e, t, r) {
  let { node: n } = e, s = [];
  if (n.argument) {
    let o = r("argument");
    jl(t, n.argument) ? o = ["(", m([y, o]), y, ")"] : (Ae(n.argument) || t.experimentalTernaries && n.argument.type === "ConditionalExpression" && (n.argument.consequent.type === "ConditionalExpression" || n.argument.alternate.type === "ConditionalExpression")) && (o = c([b("("), m([f, o]), f, b(")")])), s.push(" ", o);
  }
  let i = C(n, T.Dangling), u = t.semi && i && C(n, T.Last | T.Line);
  return u && s.push(";"), i && s.push(" ", v(e, t)), !u && t.semi && s.push(";"), s;
}
function oo(e, t, r) {
  return ["return", uo(e, t, r)];
}
function ao(e, t, r) {
  return ["throw", uo(e, t, r)];
}
function jl(e, t) {
  if (de(e.originalText, t) || C(t, T.Leading, (r) => oe(e.originalText, O(r), k(r))) && !Y2(t)) return true;
  if (Ut(t)) {
    let r = t, n;
    for (; n = pi(r); ) if (r = n, de(e.originalText, r)) return true;
  }
  return false;
}
function vt(e, t, r) {
  let { node: n } = e, s = [], i = n.type === "ObjectTypeAnnotation", u = !co(e), o = u ? A : y, a2 = C(n, T.Dangling), [p, D2] = i && n.exact ? ["{|", "|}"] : "{}", l2;
  if (Rl(e, ({ node: E, next: d2, isLast: F2 }) => {
    if (l2 ?? (l2 = E), s.push(r()), u && i) {
      let { parent: B2 } = e;
      B2.inexact || !F2 ? s.push(",") : ie(t) && s.push(b(","));
    }
    !u && (Jl({ node: E, next: d2 }, t) || mo({ node: E, next: d2 }, t)) && s.push(";"), F2 || (s.push(o), ue2(E, t) && s.push(y));
  }), a2 && s.push(v(e, t)), n.type === "ObjectTypeAnnotation" && n.inexact) {
    let E;
    C(n, T.Dangling) ? E = [C(n, T.Line) || Q2(t.originalText, k(_(0, Ze2(n), -1))) ? y : A, "..."] : E = [l2 ? A : "", "..."], s.push(E);
  }
  if (u) {
    let E = a2 || t.objectWrap === "preserve" && l2 && oe(t.originalText, O(n), O(l2)), d2;
    if (s.length === 0) d2 = p + D2;
    else {
      let F2 = t.bracketSpacing ? A : f;
      d2 = [p, m([F2, ...s]), F2, D2];
    }
    return e.match(void 0, (F2, B2) => B2 === "typeAnnotation", (F2, B2) => B2 === "typeAnnotation", Nt) || e.match(void 0, (F2, B2) => F2.type === "FunctionTypeParam" && B2 === "typeAnnotation", Nt) ? d2 : c(d2, { shouldBreak: E });
  }
  return [p, s.length > 0 ? [m([y, s]), y] : "", D2];
}
function co(e) {
  let { node: t } = e;
  if (t.type === "ObjectTypeAnnotation") {
    let { key: r, parent: n } = e;
    return r === "body" && (n.type === "InterfaceDeclaration" || n.type === "DeclareInterface" || n.type === "DeclareClass");
  }
  return t.type === "ClassBody" || t.type === "TSInterfaceBody";
}
function Rl(e, t) {
  let { node: r } = e;
  if (r.type === "ClassBody" || r.type === "TSInterfaceBody") {
    e.each(t, "body");
    return;
  }
  if (r.type === "TSTypeLiteral") {
    e.each(t, "members");
    return;
  }
  if (r.type === "ObjectTypeAnnotation") {
    let n = ["properties", "indexers", "callProperties", "internalSlots"].flatMap((s) => e.map(({ node: i, index: u }) => ({ node: i, loc: O(i), selector: [s, u] }), s)).sort((s, i) => s.loc - i.loc);
    for (let [s, { node: i, selector: u }] of n.entries()) e.call(() => t({ node: i, next: n[s + 1]?.node, isLast: s === n.length - 1 }), ...u);
  }
}
function ve(e, t) {
  let { parent: r } = e;
  return e.callParent(co) ? t.semi || r.type === "ObjectTypeAnnotation" ? ";" : "" : r.type === "TSTypeLiteral" ? e.isLast ? t.semi ? b(";") : "" : t.semi || mo({ node: e.node, next: e.next }, t) ? ";" : b("", ";") : "";
}
var po = P(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]), lo = (e) => {
  if (e.computed || e.typeAnnotation) return false;
  let { type: t, name: r } = e.key;
  return t === "Identifier" && (r === "static" || r === "get" || r === "set");
};
function Jl({ node: e, next: t }, r) {
  if (r.semi || !po(e)) return false;
  if (!e.value && lo(e)) return true;
  if (!t || t.static || t.accessibility || t.readonly) return false;
  if (!t.computed) {
    let n = t.key?.name;
    if (n === "in" || n === "instanceof") return true;
  }
  if (po(t) && t.variance && !t.static && !t.declare) return true;
  switch (t.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return t.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((t.value ? t.value.async : t.async) || t.kind === "get" || t.kind === "set") return false;
      let s = t.value ? t.value.generator : t.generator;
      return !!(t.computed || s);
    }
    case "TSIndexSignature":
      return true;
  }
  return false;
}
var Gl = P(["TSPropertySignature"]);
function mo({ node: e, next: t }, r) {
  if (r.semi || !Gl(e)) return false;
  if (lo(e)) return true;
  if (!t) return false;
  switch (t.type) {
    case "TSCallSignatureDeclaration":
      return true;
  }
  return false;
}
var Wl = eo("heritageGroup"), ql = P(["TSInterfaceDeclaration", "DeclareInterface", "InterfaceDeclaration", "InterfaceTypeAnnotation"]);
function er(e, t, r) {
  let { node: n } = e, s = ql(n), i = [z(e), tr(e), s ? "interface" : "class"], u = fo(e), o = [], a2 = [];
  if (n.type !== "InterfaceTypeAnnotation") {
    n.id && o.push(" ");
    for (let D2 of ["id", "typeParameters"]) if (n[D2]) {
      let { leading: l2, trailing: E } = e.call(() => Mt(e, t), D2);
      o.push(l2, r(D2), m(E));
    }
  }
  if (n.superClass) {
    let D2 = [Hl(e, t, r), r(n.superTypeArguments ? "superTypeArguments" : "superTypeParameters")], l2 = e.call(() => ["extends ", me(e, D2, t)], "superClass");
    u ? a2.push(A, c(l2)) : a2.push(" ", l2);
  } else a2.push(Ls(e, t, r, "extends"));
  a2.push(Ls(e, t, r, "mixins"), Ls(e, t, r, "implements"));
  let p;
  return u ? (p = Wl(n), i.push(c([...o, m(a2)], { id: p }))) : i.push(...o, ...a2), !s && u && Yl(n.body) ? i.push(b(y, " ", { groupId: p })) : i.push(" "), i.push(r("body")), i;
}
function Yl(e) {
  return e.type === "ObjectTypeAnnotation" ? ["properties", "indexers", "callProperties", "internalSlots"].some((t) => j(e[t])) : j(e.body);
}
function Do(e) {
  let t = e.superClass ? 1 : 0;
  for (let r of ["extends", "mixins", "implements"]) if (Array.isArray(e[r]) && (t += e[r].length), t > 1) return true;
  return t > 1;
}
function Ul(e) {
  let { node: t } = e;
  if (C(t.id, T.Trailing) || C(t.typeParameters, T.Trailing) || C(t.superClass) || Do(t)) return true;
  if (t.superClass) return e.parent.type === "AssignmentExpression" ? false : !(t.superTypeArguments ?? t.superTypeParameters) && R(t.superClass);
  let r = t.extends?.[0] ?? t.mixins?.[0] ?? t.implements?.[0];
  return r ? r.type === "InterfaceExtends" && r.id.type === "QualifiedTypeIdentifier" && !r.typeParameters || (r.type === "TSClassImplements" || r.type === "TSInterfaceHeritage") && R(r.expression) && !r.typeArguments : false;
}
var Is = /* @__PURE__ */ new WeakMap();
function fo(e) {
  let { node: t } = e;
  return Is.has(t) || Is.set(t, Ul(e)), Is.get(t);
}
function Ls(e, t, r, n) {
  let { node: s } = e;
  if (!j(s[n])) return "";
  let i = v(e, t, { marker: n }), u = I([",", A], e.map(r, n));
  if (!Do(s)) {
    let o = [`${n} `, i, u];
    return fo(e) ? [A, c(o)] : [" ", o];
  }
  return [A, i, i && y, n, c(m([A, u]))];
}
function Hl(e, t, r) {
  let n = r("superClass"), { parent: s } = e;
  return s.type === "AssignmentExpression" ? c(b(["(", m([f, n]), f, ")"], n)) : n;
}
function pn(e, t, r) {
  let { node: n } = e, s = [];
  return j(n.decorators) && s.push(Bs(e, t, r)), s.push(rr(n)), n.static && s.push("static "), s.push(tr(e)), n.override && s.push("override "), s.push(gr(e, t, r)), s;
}
function cn(e, t, r) {
  let { node: n } = e, s = [];
  j(n.decorators) && s.push(Bs(e, t, r)), s.push(z(e), rr(n)), n.static && s.push("static "), s.push(tr(e)), n.override && s.push("override "), n.readonly && s.push("readonly "), n.variance && s.push(r("variance")), (n.type === "ClassAccessorProperty" || n.type === "AccessorProperty" || n.type === "TSAbstractAccessorProperty") && s.push("accessor "), s.push(Ft(e, t, r), V(e), ln(e), U(e, r));
  let i = n.type === "TSAbstractPropertyDefinition" || n.type === "TSAbstractAccessorProperty";
  return [xt(e, t, r, s, " =", i ? void 0 : "value"), t.semi ? ";" : ""];
}
var Xl = P(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), Vl = P(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function $l(e) {
  let { types: t } = e;
  if (t.some((n) => C(n))) return false;
  let r = t.find((n) => Vl(n));
  return r ? t.every((n) => n === r || Xl(n)) : false;
}
function Os(e) {
  return Ht(e) || We2(e) ? true : Ie(e) ? $l(e) : false;
}
function yo(e, t, r) {
  let { node: n } = e, s = [z(e), "opaque type ", r("id"), r("typeParameters")];
  if (n.supertype && s.push(": ", r("supertype")), n.lowerBound || n.upperBound) {
    let i = [];
    n.lowerBound && i.push(m([A, "super ", r("lowerBound")])), n.upperBound && i.push(m([A, "extends ", r("upperBound")])), s.push(c(i));
  }
  return n.impltype && s.push(" = ", r("impltype")), s.push(t.semi ? ";" : ""), s;
}
function mn(e, t, r) {
  let { node: n } = e, s = [z(e), "type ", r("id"), r("typeParameters")], i = n.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [xt(e, t, r, s, " =", i), t.semi ? ";" : ""];
}
function Dn(e, t, r) {
  let n = false;
  return c(e.map(({ isFirst: s, previous: i, node: u, index: o }) => {
    let a2 = r();
    if (s) return a2;
    let p = We2(u), D2 = We2(i);
    return D2 && p ? [" & ", n ? m(a2) : a2] : !D2 && !p || de(t.originalText, u) ? t.experimentalOperatorPosition === "start" ? m([A, "& ", a2]) : m([" &", A, a2]) : (o > 1 && (n = true), [" & ", o > 1 ? m(a2) : a2]);
  }, "types"));
}
function fn(e, t, r) {
  let { node: n } = e, { parent: s } = e, i = s.type !== "TypeParameterInstantiation" && (!qe(s) || !t.experimentalTernaries) && s.type !== "TSTypeParameterInstantiation" && s.type !== "GenericTypeAnnotation" && s.type !== "TSTypeReference" && s.type !== "TSTypeAssertion" && s.type !== "TupleTypeAnnotation" && s.type !== "TSTupleType" && !(s.type === "FunctionTypeParam" && !s.name && e.grandparent.this !== s) && !((Er(s) || s.type === "VariableDeclarator") && de(t.originalText, n)) && !(Er(s) && C(s.id, T.Trailing | T.Line)), u = Os(n), o = e.map(() => {
    let d2 = r();
    return u || (d2 = Te(2, d2)), me(e, d2, t);
  }, "types"), { leading: a2, trailing: p } = Mt(e, t);
  if (u) return [a2, I(" | ", o), p];
  let D2 = i && !de(t.originalText, n), l2 = [b([D2 ? A : "", "| "]), I([A, "| "], o)];
  if (xe(e, t)) return [a2, c([m(l2), f]), p];
  let E = [a2, c(l2)];
  return (s.type === "TupleTypeAnnotation" || s.type === "TSTupleType") && s[s.type === "TupleTypeAnnotation" && s.types ? "types" : "elementTypes"].length > 1 ? [c([m([b(["(", f]), E]), f, b(")")]), p] : [c(i ? m(E) : E), p];
}
function Kl(e) {
  let { node: t, parent: r } = e;
  return t.type === "FunctionTypeAnnotation" && (vr(r) || !((r.type === "ObjectTypeProperty" || r.type === "ObjectTypeInternalSlot") && !r.variance && !r.optional && St(r, t) || r.type === "ObjectTypeCallProperty" || e.getParentNode(2)?.type === "DeclareFunction"));
}
function yn(e, t, r) {
  let { node: n } = e, s = [tr(e)];
  (n.type === "TSConstructorType" || n.type === "TSConstructSignatureDeclaration") && s.push("new ");
  let i = Ke2(e, t, r, false, true), u = [];
  return n.type === "FunctionTypeAnnotation" ? u.push(Kl(e) ? " => " : ": ", r("returnType")) : u.push(U(e, r, "returnType")), ct2(n, u) && (i = c(i)), s.push(i, u), [c(s), n.type === "TSConstructSignatureDeclaration" || n.type === "TSCallSignatureDeclaration" ? ve(e, t) : ""];
}
function En(e, t, r) {
  return [r("objectType"), V(e), "[", r("indexType"), "]"];
}
function Fn(e, t, r) {
  return ["infer ", r("typeParameter")];
}
function ws(e, t, r) {
  let { node: n } = e;
  return [n.postfix ? "" : r, U(e, t), n.postfix ? r : ""];
}
function dn(e, t, r) {
  let { node: n } = e;
  return ["...", ...n.type === "TupleTypeSpreadElement" && n.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function Cn(e, t, r) {
  let { node: n } = e;
  return [n.variance ? r("variance") : "", r("label"), n.optional ? "?" : "", ": ", r("elementType")];
}
var Ql = /* @__PURE__ */ new WeakSet();
function U(e, t, r = "typeAnnotation") {
  let { node: { [r]: n } } = e;
  if (!n) return "";
  let s = false;
  if (n.type === "TSTypeAnnotation" || n.type === "TypeAnnotation") {
    let i = e.call(Eo, r);
    (i === "=>" || i === ":" && C(n, T.Leading)) && (s = true), Ql.add(n);
  }
  return s ? [" ", t(r)] : t(r);
}
var Eo = (e) => e.match((t) => t.type === "TSTypeAnnotation", (t, r) => (r === "returnType" || r === "typeAnnotation") && (t.type === "TSFunctionType" || t.type === "TSConstructorType")) ? "=>" : e.match((t) => t.type === "TSTypeAnnotation", (t, r) => r === "typeAnnotation" && (t.type === "TSJSDocNullableType" || t.type === "TSJSDocNonNullableType" || t.type === "TSTypePredicate")) || e.match((t) => t.type === "TypeAnnotation", (t, r) => r === "typeAnnotation" && t.type === "Identifier", (t, r) => r === "id" && t.type === "DeclareFunction") || e.match((t) => t.type === "TypeAnnotation", (t, r) => r === "typeAnnotation" && t.type === "Identifier", (t, r) => r === "id" && t.type === "DeclareHook") || e.match((t) => t.type === "TypeAnnotation", (t, r) => r === "bound" && t.type === "TypeParameter" && t.usesExtendsBound) ? "" : ":";
function An(e, t, r) {
  let n = Eo(e);
  return n ? [n, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function Tn(e) {
  return [e("elementType"), "[]"];
}
function xn({ node: e }, t) {
  let r = e.type === "TSTypeQuery" ? "exprName" : "argument";
  return ["typeof ", t(r), t("typeArguments")];
}
function gn(e, t) {
  let { node: r } = e;
  return [r.type === "TSTypePredicate" && r.asserts ? "asserts " : r.type === "TypePredicate" && r.kind ? `${r.kind} ` : "", t("parameterName"), r.typeAnnotation ? [" is ", U(e, t)] : ""];
}
function V(e) {
  let { node: t } = e;
  return !t.optional || t.type === "Identifier" && t === e.parent.key ? "" : M(t) || R(t) && t.computed || t.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function ln(e) {
  return e.node.definite || e.match(void 0, (t, r) => r === "id" && t.type === "VariableDeclarator" && t.definite) ? "!" : "";
}
var zl = P(["DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function z(e) {
  let { node: t } = e;
  return t.declare || zl(t) && e.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var Zl = P(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function tr({ node: e }) {
  return e.abstract || Zl(e) ? "abstract " : "";
}
function tn(e, t, r) {
  return ["::", r("callee")];
}
function dt(e, t, r) {
  return e.type === "EmptyStatement" ? C(e, T.Leading) ? [" ", t] : t : e.type === "BlockStatement" || r ? [" ", t] : m([A, t]);
}
function hn(e, t) {
  return ["...", t("argument"), U(e, t)];
}
function rr(e) {
  return e.accessibility ? e.accessibility + " " : "";
}
function em(e, t, r, n) {
  let { node: s } = e, i = s.inexact ? "..." : "";
  return C(s, T.Dangling) ? c([r, i, v(e, t, { indent: true }), f, n]) : [r, i, n];
}
function nr(e, t, r) {
  let { node: n } = e, s = [], i = "[", u = "]", o = n.type === "TupleTypeAnnotation" && n.types ? "types" : n.type === "TSTupleType" || n.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", a2 = n[o];
  if (a2.length === 0) s.push(em(e, t, i, u));
  else {
    let p = _(0, a2, -1), D2 = p?.type !== "RestElement" && !n.inexact, l2 = p === null, E = Symbol("array"), d2 = !t.__inJestEach && a2.length > 1 && a2.every((S2, L2, g2) => {
      let x2 = S2?.type;
      if (!G(S2) && !se(S2)) return false;
      let h = g2[L2 + 1];
      if (h && x2 !== h.type) return false;
      let N = G(S2) ? "elements" : "properties";
      return S2[N] && S2[N].length > 1;
    }), F2 = bs(n, t), B2 = D2 ? l2 ? "," : ie(t) ? F2 ? b(",", "", { groupId: E }) : b(",") : "" : "";
    s.push(c([i, m([f, F2 ? rm(e, t, r, B2) : [tm(e, t, r, o, n.inexact), B2], v(e, t)]), f, u], { shouldBreak: d2, id: E }));
  }
  return s.push(V(e), U(e, r)), s;
}
function bs(e, t) {
  return G(e) && e.elements.length > 0 && e.elements.every((r) => r && (Fe(r) || Yn(r) && !C(r.argument)) && !C(r, T.Trailing | T.Line, (n) => !Q2(t.originalText, O(n), { backwards: true })));
}
function Fo({ node: e }, { originalText: t }) {
  let r = k(e);
  if (r === O(e)) return false;
  let { length: n } = t;
  for (; r < n && t[r] !== ","; ) r = Gt(t, Wt(t, r + 1));
  return qt(t, r);
}
function tm(e, t, r, n, s) {
  let i = [];
  return e.each(({ node: u, isLast: o }) => {
    i.push(u ? c(r()) : ""), (!o || s) && i.push([",", A, u && Fo(e, t) ? f : ""]);
  }, n), s && i.push("..."), i;
}
function rm(e, t, r, n) {
  let s = [];
  return e.each(({ isLast: i, next: u }) => {
    s.push([r(), i ? n : ","]), i || s.push(Fo(e, t) ? [y, y] : C(u, T.Leading | T.Line) ? y : A);
  }, "elements"), Hr(s);
}
var Ms = /* @__PURE__ */ new WeakMap();
function Co(e) {
  return Ms.has(e) || Ms.set(e, e.type === "ConditionalExpression" && !fe2(e, (t) => t.type === "ObjectExpression")), Ms.get(e);
}
var nm = (e) => e.type === "SequenceExpression";
function Ao(e, t, r, n = {}) {
  let s = [], i, u = [], o = false, a2 = !n.expandLastArg && e.node.body.type === "ArrowFunctionExpression", p;
  (function L2() {
    let { node: g2 } = e, x2 = sm(e, t, r, n);
    if (s.length === 0) s.push(x2);
    else {
      let { leading: h, trailing: N } = Mt(e, t);
      s.push([h, x2]), u.unshift(N);
    }
    a2 && (o || (o = g2.returnType && $(g2).length > 0 || g2.typeParameters || $(g2).some((h) => h.type !== "Identifier"))), !a2 || g2.body.type !== "ArrowFunctionExpression" ? (i = r("body", n), p = g2.body) : e.call(L2, "body");
  })();
  let D2 = !de(t.originalText, p) && (nm(p) || im(p, i, t) || !o && Co(p)), l2 = e.key === "callee" && mt(e.parent), E = Symbol("arrow-chain"), d2 = um(e, n, { signatureDocs: s, shouldBreak: o }), F2 = false, B2 = false, S2 = false;
  return a2 && (l2 || n.assignmentLayout) && (B2 = true, S2 = !C(e.node, T.Leading & T.Line), F2 = n.assignmentLayout === "chain-tail-arrow-chain" || l2 && !D2), i = om(e, t, n, { bodyDoc: i, bodyComments: u, functionBody: p, shouldPutBodyOnSameLine: D2 }), c([c(B2 ? m([S2 ? f : "", d2]) : d2, { shouldBreak: F2, id: E }), " =>", a2 ? ft(i, { groupId: E }) : c(i), a2 && l2 ? b(f, "", { groupId: E }) : ""]);
}
function sm(e, t, r, n) {
  let { node: s } = e, i = [];
  if (s.async && i.push("async "), an(e, t)) i.push(r(["params", 0]));
  else {
    let o = n.expandLastArg || n.expandFirstArg, a2 = Zt(e, r);
    if (o) {
      if (re(a2)) throw new yt();
      a2 = c(Ot(a2));
    }
    i.push(c([Ke2(e, t, r, o, true), a2]));
  }
  let u = v(e, t, { filter(o) {
    let a2 = pt(t.originalText, k(o));
    return a2 !== false && t.originalText.slice(a2, a2 + 2) === "=>";
  } });
  return u && i.push(" ", u), i;
}
function im(e, t, r) {
  return G(e) || se(e) || e.type === "ArrowFunctionExpression" || e.type === "DoExpression" || e.type === "BlockStatement" || Y2(e) || t.label?.hug !== false && (t.label?.embed || jr(e, r.originalText));
}
function um(e, t, { signatureDocs: r, shouldBreak: n }) {
  if (r.length === 1) return r[0];
  let { parent: s, key: i } = e;
  return i !== "callee" && mt(s) || Ae(s) ? c([r[0], " =>", m([A, I([" =>", A], r.slice(1))])], { shouldBreak: n }) : i === "callee" && mt(s) || t.assignmentLayout ? c(I([" =>", A], r), { shouldBreak: n }) : c(m(I([" =>", A], r)), { shouldBreak: n });
}
function om(e, t, r, { bodyDoc: n, bodyComments: s, functionBody: i, shouldPutBodyOnSameLine: u }) {
  let { node: o, parent: a2 } = e, p = r.expandLastArg && ie(t, "all") ? b(",") : "", D2 = (r.expandLastArg || a2.type === "JSXExpressionContainer") && !C(o) ? f : "";
  return u && Co(i) ? [" ", c([b("", "("), m([f, n]), b("", ")"), p, D2]), s] : u ? [" ", n, s] : [m([A, n, s]), p, D2];
}
var am = Array.prototype.findLast ?? function(e) {
  for (let t = this.length - 1; t >= 0; t--) {
    let r = this[t];
    if (e(r, t, this)) return r;
  }
}, pm = Jt("findLast", function() {
  if (Array.isArray(this)) return am;
}), To = pm;
function hr(e, t, r, n) {
  let { node: s } = e, i = [], u = To(0, s[n], (o) => o.type !== "EmptyStatement");
  return e.each(({ node: o }) => {
    o.type !== "EmptyStatement" && (i.push(r()), o !== u && (i.push(y), ue2(o, t) && i.push(y)));
  }, n), i;
}
function Sn(e, t, r) {
  let n = cm(e, t, r), { node: s, parent: i } = e;
  if (s.type === "Program" && i?.type !== "ModuleExpression") return n ? [n, y] : "";
  let u = [];
  if (s.type === "StaticBlock" && u.push("static "), u.push("{"), n) u.push(m([y, n]), y);
  else {
    let o = e.grandparent;
    i.type === "ArrowFunctionExpression" || i.type === "FunctionExpression" || i.type === "FunctionDeclaration" || i.type === "ComponentDeclaration" || i.type === "HookDeclaration" || i.type === "ObjectMethod" || i.type === "ClassMethod" || i.type === "ClassPrivateMethod" || i.type === "ForStatement" || i.type === "WhileStatement" || i.type === "DoWhileStatement" || i.type === "DoExpression" || i.type === "ModuleExpression" || i.type === "CatchClause" && !o.finalizer || i.type === "TSModuleDeclaration" || i.type === "MatchStatementCase" || s.type === "StaticBlock" || u.push(y);
  }
  return u.push("}"), u;
}
function cm(e, t, r) {
  let { node: n } = e, s = j(n.directives), i = n.body.some((a2) => a2.type !== "EmptyStatement"), u = C(n, T.Dangling);
  if (!s && !i && !u) return "";
  let o = [];
  return s && (o.push(hr(e, t, r, "directives")), (i || u) && (o.push(y), ue2(_(0, n.directives, -1), t) && o.push(y))), i && o.push(hr(e, t, r, "body")), u && o.push(v(e, t)), o;
}
var lm = P(["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"]);
function _s(e) {
  return lm(e) ? _s(e.expression) : e;
}
var xo = P(["FunctionExpression", "ArrowFunctionExpression"]);
function go(e) {
  return e.type === "MemberExpression" || e.type === "OptionalMemberExpression" || e.type === "Identifier" && e.name !== "undefined";
}
function ho(e, t) {
  if (t.semi || vs(e, t) || Rs(e, t) || js(e, t)) return false;
  let { node: r, key: n, parent: s } = e;
  return !!(r.type === "ExpressionStatement" && (n === "body" && (s.type === "Program" || s.type === "BlockStatement" || s.type === "StaticBlock" || s.type === "TSModuleBlock") || n === "consequent" && s.type === "SwitchCase") && e.call(() => So(e, t), "expression"));
}
function So(e, t) {
  let { node: r } = e;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return true;
    case "ArrowFunctionExpression":
      if (!an(e, t)) return true;
      break;
    case "UnaryExpression": {
      let { prefix: n, operator: s } = r;
      if (n && (s === "+" || s === "-")) return true;
      break;
    }
    case "BindExpression":
      if (!r.object) return true;
      break;
    case "Literal":
      if (r.regex) return true;
      break;
    default:
      if (Y2(r)) return true;
  }
  return xe(e, t) ? true : Ut(r) ? e.call(() => So(e, t), ..._r(r)) : false;
}
var Ns = ({ node: e, parent: t }) => e.type === "ExpressionStatement" && t.type === "Program" && t.body.length === 1 && (Array.isArray(t.directives) && t.directives.length === 0 || !t.directives);
function vs(e, t) {
  return (t.parentParser === "markdown" || t.parentParser === "mdx") && Ns(e) && Y2(e.node.expression);
}
function js(e, t) {
  return t.__isHtmlInlineEventHandler && Ns(e);
}
function Rs(e, t) {
  return (t.parser === "__vue_event_binding" || t.parser === "__vue_ts_event_binding") && Ns(e);
}
function mm(e, t) {
  if (Rs(e, t)) {
    let r = _s(e.node.expression);
    return xo(r) || go(r);
  }
  return !(!t.semi || vs(e, t) || js(e, t));
}
function Bo(e, t, r) {
  return [r("expression"), mm(e, t) ? ";" : ""];
}
function bo(e, t, r) {
  if (t.__isVueBindings || t.__isVueForBindingLeft) {
    let n = e.map(r, "program", "body", 0, "params");
    if (n.length === 1) return n[0];
    let s = I([",", A], n);
    return t.__isVueForBindingLeft ? ["(", m([f, c(s)]), f, ")"] : s;
  }
  if (t.__isEmbeddedTypescriptGenericParameters) {
    let n = e.map(r, "program", "body", 0, "typeParameters", "params");
    return I([",", A], n);
  }
}
function Io(e, t) {
  let { node: r } = e;
  switch (r.type) {
    case "RegExpLiteral":
      return Po(r);
    case "BigIntLiteral":
      return Bn(r.extra.raw);
    case "NumericLiteral":
      return Et(r.extra.raw);
    case "StringLiteral":
      return Ge2(ut(r.extra.raw, t));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DirectiveLiteral":
      return ko(r.extra.raw, t);
    case "Literal": {
      if (r.regex) return Po(r.regex);
      if (r.bigint) return Bn(r.raw);
      let { value: n } = r;
      return typeof n == "number" ? Et(r.raw) : typeof n == "string" ? Dm(e) ? ko(r.raw, t) : Ge2(ut(r.raw, t)) : String(n);
    }
  }
}
function Dm(e) {
  if (e.key !== "expression") return;
  let { parent: t } = e;
  return t.type === "ExpressionStatement" && typeof t.directive == "string";
}
function Bn(e) {
  return e.toLowerCase();
}
function Po({ pattern: e, flags: t }) {
  return t = [...t].sort().join(""), `/${e}/${t}`;
}
function ko(e, t) {
  let r = e.slice(1, -1);
  if (r.includes('"') || r.includes("'")) return e;
  let n = t.singleQuote ? "'" : '"';
  return n + r + n;
}
function fm(e, t, r) {
  let n = e.originalText.slice(t, r);
  for (let s of e[Symbol.for("comments")]) {
    let i = O(s);
    if (i > r) break;
    let u = k(s);
    if (u < t) continue;
    let o = i - t, a2 = u - t;
    n = n.slice(0, o) + J(0, n.slice(o, a2), /[^\n]/gu, " ") + n.slice(a2);
  }
  return n;
}
var jt = fm;
var Lo = P(["ImportDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportDeclaration", "DeclareExportAllDeclaration"]), ym = P(["EnumBooleanBody", "EnumNumberBody", "EnumBigIntBody", "EnumStringBody", "EnumSymbolBody"]);
function sr(e, t, r) {
  let { node: n, parent: s } = e, i = ym(n), u = n.type === "TSEnumBody" || i, o = Lo(n), a2 = i && n.hasUnknownMembers, p = u ? "members" : o ? "attributes" : "properties", D2 = n[p], l2 = u || n.type === "ObjectPattern" && s.type !== "FunctionDeclaration" && s.type !== "FunctionExpression" && s.type !== "ArrowFunctionExpression" && s.type !== "ObjectMethod" && s.type !== "ClassMethod" && s.type !== "ClassPrivateMethod" && s.type !== "AssignmentPattern" && s.type !== "CatchClause" && n.properties.some((S2) => S2.value && (S2.value.type === "ObjectPattern" || S2.value.type === "ArrayPattern")) || n.type !== "ObjectPattern" && t.objectWrap === "preserve" && D2.length > 0 && Em(n, D2[0], t), E = [], d2 = e.map(({ node: S2 }) => {
    let L2 = [...E, c(r())];
    return E = [",", A], ue2(S2, t) && E.push(y), L2;
  }, p);
  if (a2) {
    let S2;
    if (C(n, T.Dangling)) {
      let L2 = C(n, T.Line);
      S2 = [v(e, t), L2 || Q2(t.originalText, k(_(0, Ze2(n), -1))) ? y : A, "..."];
    } else S2 = ["..."];
    d2.push([...E, ...S2]);
  }
  let F2 = !(a2 || _(0, D2, -1)?.type === "RestElement"), B2;
  if (d2.length === 0) {
    if (!C(n, T.Dangling)) return ["{}", U(e, r)];
    B2 = c(["{", v(e, t, { indent: true }), f, "}", V(e), U(e, r)]);
  } else {
    let S2 = t.bracketSpacing ? A : f;
    B2 = ["{", m([S2, ...d2]), b(F2 && ie(t) ? "," : ""), S2, "}", V(e), U(e, r)];
  }
  return e.match((S2) => S2.type === "ObjectPattern" && !j(S2.decorators), Nt) || We2(n) && (e.match(void 0, (S2, L2) => L2 === "typeAnnotation", (S2, L2) => L2 === "typeAnnotation", Nt) || e.match(void 0, (S2, L2) => S2.type === "FunctionTypeParam" && L2 === "typeAnnotation", Nt)) || !l2 && e.match((S2) => S2.type === "ObjectPattern", (S2) => S2.type === "AssignmentExpression" || S2.type === "VariableDeclarator") ? B2 : c(B2, { shouldBreak: l2 });
}
function Em(e, t, r) {
  let n = r.originalText, s = O(e), i = O(t);
  if (Lo(e)) {
    let u = O(e), o = jt(r, u, i);
    s = u + o.lastIndexOf("{");
  }
  return oe(n, s, i);
}
function Oo(e, t, r) {
  let { node: n } = e;
  return ["import", n.phase ? ` ${n.phase}` : "", Gs(n), _o(e, t, r), Mo(e, t, r), vo(e, t, r), t.semi ? ";" : ""];
}
var wo = (e) => e.type === "ExportDefaultDeclaration" || e.type === "DeclareExportDeclaration" && e.default;
function bn(e, t, r) {
  let { node: n } = e, s = [ju(e, t, r), z(e), "export", wo(n) ? " default" : ""], { declaration: i, exported: u } = n;
  return C(n, T.Dangling) && (s.push(" ", v(e, t)), Rr(n) && s.push(y)), i ? s.push(" ", r("declaration")) : (s.push(Cm(n)), n.type === "ExportAllDeclaration" || n.type === "DeclareExportAllDeclaration" ? (s.push(" *"), u && s.push(" as ", r("exported"))) : s.push(_o(e, t, r)), s.push(Mo(e, t, r), vo(e, t, r))), s.push(dm(n, t)), s;
}
var Fm = P(["ClassDeclaration", "ComponentDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "HookDeclaration", "TSDeclareFunction", "EnumDeclaration"]);
function dm(e, t) {
  return t.semi && (!e.declaration || wo(e) && !Fm(e.declaration)) ? ";" : "";
}
function Js(e, t = true) {
  return e && e !== "value" ? `${t ? " " : ""}${e}${t ? "" : " "}` : "";
}
function Gs(e, t) {
  return Js(e.importKind, t);
}
function Cm(e) {
  return Js(e.exportKind);
}
function Mo(e, t, r) {
  let { node: n } = e;
  return n.source ? [No(n, t) ? " from" : "", " ", r("source")] : "";
}
function _o(e, t, r) {
  let { node: n } = e;
  if (!No(n, t)) return "";
  let s = [" "];
  if (j(n.specifiers)) {
    let i = [], u = [];
    e.each(() => {
      let o = e.node.type;
      if (o === "ExportNamespaceSpecifier" || o === "ExportDefaultSpecifier" || o === "ImportNamespaceSpecifier" || o === "ImportDefaultSpecifier") i.push(r());
      else if (o === "ExportSpecifier" || o === "ImportSpecifier") u.push(r());
      else throw new $e2(n, "specifier");
    }, "specifiers"), s.push(I(", ", i)), u.length > 0 && (i.length > 0 && s.push(", "), u.length > 1 || i.length > 0 || n.specifiers.some((a2) => C(a2)) ? s.push(c(["{", m([t.bracketSpacing ? A : f, I([",", A], u)]), b(ie(t) ? "," : ""), t.bracketSpacing ? A : f, "}"])) : s.push(["{", t.bracketSpacing ? " " : "", ...u, t.bracketSpacing ? " " : "", "}"]));
  } else s.push("{}");
  return s;
}
function No(e, t) {
  return e.type !== "ImportDeclaration" || j(e.specifiers) || e.importKind === "type" ? true : jt(t, O(e), O(e.source)).trimEnd().endsWith("from");
}
function Am(e, t) {
  if (e.extra?.deprecatedAssertSyntax) return "assert";
  let r = jt(t, k(e.source), e.attributes?.[0] ? O(e.attributes[0]) : k(e)).trimStart();
  return r.startsWith("assert") ? "assert" : r.startsWith("with") || j(e.attributes) ? "with" : void 0;
}
var Tm = (e) => {
  let { attributes: t } = e;
  if (t.length !== 1) return false;
  let [r] = t, { type: n, key: s, value: i } = r;
  return n === "ImportAttribute" && (s.type === "Identifier" && s.name === "type" || H(s) && s.value === "type") && H(i) && !C(r) && !C(s) && !C(i);
};
function vo(e, t, r) {
  let { node: n } = e;
  if (!n.source) return "";
  let s = Am(n, t);
  if (!s) return "";
  let i = sr(e, t, r);
  return Tm(n) && (i = Ot(i)), [` ${s} `, i];
}
function jo(e, t, r) {
  let { node: n } = e, { type: s } = n, i = s.startsWith("Import"), u = i ? "imported" : "local", o = i ? "local" : "exported", a2 = n[u], p = n[o], D2 = "", l2 = "";
  return s === "ExportNamespaceSpecifier" || s === "ImportNamespaceSpecifier" ? D2 = "*" : a2 && (D2 = r(u)), p && !xm(n) && (l2 = r(o)), [Js(s === "ImportSpecifier" ? n.importKind : n.exportKind, false), D2, D2 && l2 ? " as " : "", l2];
}
function xm(e) {
  if (e.type !== "ImportSpecifier" && e.type !== "ExportSpecifier") return false;
  let { local: t, [e.type === "ImportSpecifier" ? "imported" : "exported"]: r } = e;
  if (t.type !== r.type || !ii(t, r)) return false;
  if (H(t)) return t.value === r.value && pe2(t) === pe2(r);
  switch (t.type) {
    case "Identifier":
      return t.name === r.name;
    default:
      return false;
  }
}
function gm(e) {
  let t = [e];
  for (let r = 0; r < t.length; r++) {
    let n = t[r];
    for (let s of ["test", "consequent", "alternate"]) {
      let i = n[s];
      if (Y2(i)) return true;
      i.type === "ConditionalExpression" && t.push(i);
    }
  }
  return false;
}
function hm(e, t, r) {
  let { node: n } = e, s = n.type === "ConditionalExpression", i = s ? "alternate" : "falseType", { parent: u } = e, o = s ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return u.type === n.type && u[i] === n ? Te(2, o) : o;
}
var Sm = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function Bm(e) {
  let { node: t } = e;
  if (t.type !== "ConditionalExpression") return false;
  let r, n = t;
  for (let s = 0; !r; s++) {
    let i = e.getParentNode(s);
    if (i.type === "ChainExpression" && i.expression === n || M(i) && i.callee === n || R(i) && i.object === n || i.type === "TSNonNullExpression" && i.expression === n) {
      n = i;
      continue;
    }
    i.type === "NewExpression" && i.callee === n || Ce2(i) && i.expression === n ? (r = e.getParentNode(s + 1), n = i) : r = i;
  }
  return n === t ? false : r[Sm.get(r.type)] === n;
}
function Ro(e, t, r) {
  let { node: n } = e, s = n.type === "ConditionalExpression", i = s ? "consequent" : "trueType", u = s ? "alternate" : "falseType", o = s ? ["test"] : ["checkType", "extendsType"], a2 = n[i], p = n[u], D2 = [], l2 = false, { parent: E } = e, d2 = E.type === n.type && o.some((q2) => E[q2] === n), F2 = E.type === n.type && !d2, B2, S2, L2 = 0;
  do
    S2 = B2 || n, B2 = e.getParentNode(L2), L2++;
  while (B2 && B2.type === n.type && o.every((q2) => B2[q2] !== S2));
  let g2 = B2 || E, x2 = S2;
  if (s && (Y2(n[o[0]]) || Y2(a2) || Y2(p) || gm(x2))) {
    l2 = true, F2 = true;
    let q2 = (Z2) => [b("("), m([f, Z2]), f, b(")")], K2 = (Z2) => Z2.type === "NullLiteral" || Z2.type === "Literal" && Z2.value === null || Z2.type === "Identifier" && Z2.name === "undefined";
    D2.push(" ? ", K2(a2) ? r(i) : q2(r(i)), " : ", p.type === n.type || K2(p) ? r(u) : q2(r(u)));
  } else {
    let q2 = (Z2) => t.useTabs ? m(r(Z2)) : Te(2, r(Z2)), K2 = [A, "? ", a2.type === n.type ? b("", "(") : "", q2(i), a2.type === n.type ? b("", ")") : "", A, ": ", q2(u)];
    D2.push(E.type !== n.type || E[u] === n || d2 ? K2 : t.useTabs ? Ur(m(K2)) : Te(Math.max(0, t.tabWidth - 2), K2));
  }
  let h = (q2) => E === g2 ? c(q2) : q2, N = !l2 && (R(E) || E.type === "NGPipeExpression" && E.left === n) && !E.computed, W2 = Bm(e), De2 = h([hm(e, t, r), F2 ? D2 : m(D2), s && N && !W2 ? f : ""]);
  return d2 || W2 ? c([m([f, De2]), f]) : De2;
}
function bm(e, t) {
  return (R(t) || t.type === "NGPipeExpression" && t.left === e) && !t.computed;
}
function Pm(e, t, r, n) {
  return [...e.map((i) => Ze2(i)), Ze2(t), Ze2(r)].flat().some((i) => ne(i) && oe(n.originalText, O(i), k(i)));
}
var km = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function Im(e) {
  let { node: t } = e;
  if (t.type !== "ConditionalExpression") return false;
  let r, n = t;
  for (let s = 0; !r; s++) {
    let i = e.getParentNode(s);
    if (i.type === "ChainExpression" && i.expression === n || M(i) && i.callee === n || R(i) && i.object === n || i.type === "TSNonNullExpression" && i.expression === n) {
      n = i;
      continue;
    }
    i.type === "NewExpression" && i.callee === n || Ce2(i) && i.expression === n ? (r = e.getParentNode(s + 1), n = i) : r = i;
  }
  return n === t ? false : r[km.get(r.type)] === n;
}
var Ws = (e) => [b("("), m([f, e]), f, b(")")];
function ir(e, t, r, n) {
  if (!t.experimentalTernaries) return Ro(e, t, r);
  let { node: s } = e, i = s.type === "ConditionalExpression", u = qe(s), o = i ? "consequent" : "trueType", a2 = i ? "alternate" : "falseType", p = i ? ["test"] : ["checkType", "extendsType"], D2 = s[o], l2 = s[a2], E = p.map((pr2) => s[pr2]), { parent: d2 } = e, F2 = d2.type === s.type, B2 = F2 && p.some((pr2) => d2[pr2] === s), S2 = F2 && d2[a2] === s, L2 = D2.type === s.type, g2 = l2.type === s.type, x2 = g2 || S2, h = t.tabWidth > 2 || t.useTabs, N, W2, De2 = 0;
  do
    W2 = N || s, N = e.getParentNode(De2), De2++;
  while (N && N.type === s.type && p.every((pr2) => N[pr2] !== W2));
  let q2 = N || d2, K2 = n && n.assignmentLayout && n.assignmentLayout !== "break-after-operator" && (d2.type === "AssignmentExpression" || d2.type === "VariableDeclarator" || d2.type === "ClassProperty" || d2.type === "PropertyDefinition" || d2.type === "ClassPrivateProperty" || d2.type === "ObjectProperty" || d2.type === "Property"), Z2 = (d2.type === "ReturnStatement" || d2.type === "ThrowStatement") && !(L2 || g2), be2 = i && q2.type === "JSXExpressionContainer" && e.grandparent.type !== "JSXAttribute", nt2 = Im(e), w = bm(s, d2), te2 = u && xe(e, t), ae2 = h ? t.useTabs ? "	" : " ".repeat(t.tabWidth - 1) : "", st2 = Pm(E, D2, l2, t) || L2 || g2, ht2 = !x2 && !F2 && !u && (be2 ? D2.type === "NullLiteral" || D2.type === "Literal" && D2.value === null : fr(D2, t) && Hn(s.test, 3)), wn = x2 || S2 || u && !F2 || F2 && i && Hn(s.test, 1) || ht2, Sr2 = [];
  !L2 && C(D2, T.Dangling) && e.call(() => {
    Sr2.push(v(e, t), y);
  }, "consequent");
  let or2 = [];
  C(s.test, T.Dangling) && e.call(() => {
    or2.push(v(e, t));
  }, "test"), !g2 && C(l2, T.Dangling) && e.call(() => {
    or2.push(v(e, t));
  }, "alternate"), C(s, T.Dangling) && or2.push(v(e, t));
  let Hs2 = Symbol("test"), ca = Symbol("consequent"), Br2 = Symbol("test-and-consequent"), la = i ? [Ws(r("test")), s.test.type === "ConditionalExpression" ? Be : ""] : [r("checkType"), " ", "extends", " ", qe(s.extendsType) || s.extendsType.type === "TSMappedType" ? r("extendsType") : c(Ws(r("extendsType")))], Xs2 = c([la, " ?"], { id: Hs2 }), ma = r(o), br2 = m([L2 || be2 && (Y2(D2) || F2 || x2) ? y : A, Sr2, ma]), Da = wn ? c([Xs2, x2 ? br2 : b(br2, c(br2, { id: ca }), { groupId: Hs2 })], { id: Br2 }) : [Xs2, br2], Mn = r(a2), Vs2 = ht2 ? b(Mn, Ur(Ws(Mn)), { groupId: Br2 }) : Mn, ar2 = [Da, or2.length > 0 ? [m([y, or2]), y] : g2 ? y : ht2 ? b(A, " ", { groupId: Br2 }) : A, ":", g2 ? " " : h ? wn ? b(ae2, b(x2 || ht2 ? " " : ae2, " "), { groupId: Br2 }) : b(ae2, " ") : " ", g2 ? Vs2 : c([m(Vs2), be2 && !ht2 ? f : ""]), w && !nt2 ? f : "", st2 ? Be : ""];
  return K2 && !st2 ? c(m([f, c(ar2)])) : K2 || Z2 ? c(m(ar2)) : nt2 || u && B2 ? c([m([f, ar2]), te2 ? f : ""]) : d2 === q2 ? c(ar2) : ar2;
}
function Jo(e, t, r, n) {
  let { node: s } = e;
  if (Nr(s)) return Io(e, t);
  switch (s.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [v(e, t), r("node"), y];
    case "File":
      return bo(e, t, r) ?? r("program");
    case "ExpressionStatement":
      return Bo(e, t, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !C(s.expression) && (se(s.expression) || G(s.expression)) ? ["(", r("expression"), ")"] : c(["(", m([f, r("expression")]), f, ")"]);
    case "AssignmentExpression":
      return Ku(e, t, r);
    case "VariableDeclarator":
      return Qu(e, t, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return en(e, t, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return Yu(e, t, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return [r("object"), c(m([f, tn(e, t, r)]))];
    case "Identifier":
      return [s.name, V(e), ln(e), U(e, r)];
    case "V8IntrinsicIdentifier":
      return ["%", s.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return hn(e, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return un(e, t, r, n);
    case "ArrowFunctionExpression":
      return Ao(e, t, r, n);
    case "YieldExpression":
      return [`yield${s.delegate ? "*" : ""}`, s.argument ? [" ", r("argument")] : ""];
    case "AwaitExpression": {
      let i = ["await"];
      if (s.argument) {
        i.push(" ", r("argument"));
        let { parent: u } = e;
        if (M(u) && u.callee === s || R(u) && u.object === s) {
          i = [m([f, ...i]), f];
          let o = e.findAncestor((a2) => a2.type === "AwaitExpression" || a2.type === "BlockStatement");
          if (o?.type !== "AwaitExpression" || !fe2(o.argument, (a2) => a2 === s)) return c(i);
        }
      }
      return i;
    }
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return bn(e, t, r);
    case "ImportDeclaration":
      return Oo(e, t, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return jo(e, t, r);
    case "ImportAttribute":
      return sn(e, t, r);
    case "Program":
    case "BlockStatement":
    case "StaticBlock":
      return Sn(e, t, r);
    case "ClassBody":
      return vt(e, t, r);
    case "ThrowStatement":
      return ao(e, t, r);
    case "ReturnStatement":
      return oo(e, t, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return _t(e, t, r);
    case "ObjectExpression":
    case "ObjectPattern":
      return sr(e, t, r);
    case "Property":
      return lt2(s) ? gr(e, t, r) : sn(e, t, r);
    case "ObjectProperty":
      return sn(e, t, r);
    case "ObjectMethod":
      return gr(e, t, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
      return nr(e, t, r);
    case "SequenceExpression": {
      let { parent: i } = e;
      if (i.type === "ExpressionStatement" || i.type === "ForStatement") {
        let o = [];
        return e.each(({ isFirst: a2 }) => {
          a2 ? o.push(r()) : o.push(",", m([A, r()]));
        }, "expressions"), c(o);
      }
      let u = I([",", A], e.map(r, "expressions"));
      return (i.type === "ReturnStatement" || i.type === "ThrowStatement") && e.key === "argument" || i.type === "ArrowFunctionExpression" && e.key === "body" ? c(b([m([f, u]), f], u)) : c(u);
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), t.semi ? ";" : ""];
    case "UnaryExpression": {
      let i = [s.operator];
      return /[a-z]$/u.test(s.operator) && i.push(" "), C(s.argument) ? i.push(c(["(", m([f, r("argument")]), f, ")"])) : i.push(r("argument")), i;
    }
    case "UpdateExpression":
      return [s.prefix ? s.operator : "", r("argument"), s.prefix ? "" : s.operator];
    case "ConditionalExpression":
      return ir(e, t, r, n);
    case "VariableDeclaration": {
      let i = e.map(r, "declarations"), u = e.parent, o = u.type === "ForStatement" || u.type === "ForInStatement" || u.type === "ForOfStatement", a2 = s.declarations.some((D2) => D2.init), p;
      return i.length === 1 && !C(s.declarations[0]) ? p = i[0] : i.length > 0 && (p = m(i[0])), c([z(e), s.kind, p ? [" ", p] : "", m(i.slice(1).map((D2) => [",", a2 && !o ? y : A, D2])), t.semi && !(o && u.body !== s) ? ";" : ""]);
    }
    case "WithStatement":
      return c(["with (", r("object"), ")", dt(s.body, r("body"))]);
    case "IfStatement": {
      let i = dt(s.consequent, r("consequent")), o = [c(["if (", c([m([f, r("test")]), f]), ")", i])];
      if (s.alternate) {
        let a2 = C(s.consequent, T.Trailing | T.Line) || Rr(s), p = s.consequent.type === "BlockStatement" && !a2;
        o.push(p ? " " : y), C(s, T.Dangling) && o.push(v(e, t), a2 ? y : " "), o.push("else", c(dt(s.alternate, r("alternate"), s.alternate.type === "IfStatement")));
      }
      return o;
    }
    case "ForStatement": {
      let i = dt(s.body, r("body")), u = v(e, t), o = u ? [u, f] : "";
      return !s.init && !s.test && !s.update ? [o, c(["for (;;)", i])] : [o, c(["for (", c([m([f, r("init"), ";", A, r("test"), ";", s.update ? [A, r("update")] : b("", A)]), f]), ")", i])];
    }
    case "WhileStatement":
      return c(["while (", c([m([f, r("test")]), f]), ")", dt(s.body, r("body"))]);
    case "ForInStatement":
      return c(["for (", r("left"), " in ", r("right"), ")", dt(s.body, r("body"))]);
    case "ForOfStatement":
      return c(["for", s.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", dt(s.body, r("body"))]);
    case "DoWhileStatement": {
      let i = dt(s.body, r("body"));
      return [c(["do", i]), s.body.type === "BlockStatement" ? " " : y, "while (", c([m([f, r("test")]), f]), ")", t.semi ? ";" : ""];
    }
    case "DoExpression":
      return [s.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return [s.type === "BreakStatement" ? "break" : "continue", s.label ? [" ", r("label")] : "", t.semi ? ";" : ""];
    case "LabeledStatement":
      return [r("label"), `:${s.body.type === "EmptyStatement" && !C(s.body, T.Leading) ? "" : " "}`, r("body")];
    case "TryStatement":
      return ["try ", r("block"), s.handler ? [" ", r("handler")] : "", s.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (s.param) {
        let i = C(s.param, (o) => !ne(o) || o.leading && Q2(t.originalText, k(o)) || o.trailing && Q2(t.originalText, O(o), { backwards: true })), u = r("param");
        return ["catch ", i ? ["(", m([f, u]), f, ") "] : ["(", u, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [c(["switch (", m([f, r("discriminant")]), f, ")"]), " {", s.cases.length > 0 ? m([y, I(y, e.map(({ node: i, isLast: u }) => [r(), !u && ue2(i, t) ? y : ""], "cases"))]) : "", y, "}"];
    case "SwitchCase": {
      let i = [];
      s.test ? i.push("case ", r("test"), ":") : i.push("default:"), C(s, T.Dangling) && i.push(" ", v(e, t));
      let u = s.consequent.filter((o) => o.type !== "EmptyStatement");
      if (u.length > 0) {
        let o = hr(e, t, r, "consequent");
        i.push(u.length === 1 && u[0].type === "BlockStatement" ? [" ", o] : m([y, o]));
      }
      return i;
    }
    case "DebuggerStatement":
      return ["debugger", t.semi ? ";" : ""];
    case "ClassDeclaration":
    case "ClassExpression":
      return er(e, t, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return pn(e, t, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return cn(e, t, r);
    case "TemplateElement":
      return Ge2(s.value.raw);
    case "TemplateLiteral":
      return $r(e, t, r);
    case "TaggedTemplateExpression":
      return ru(e, t, r);
    case "PrivateIdentifier":
      return ["#", s.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression":
      return ["module ", r("body")];
    case "VoidPattern":
      return "void";
    case "EmptyStatement":
      if (bt(e)) return ";";
    case "InterpreterDirective":
    default:
      throw new $e2(s, "ESTree");
  }
}
var Lm = P(["SatisfiesExpression", "TSSatisfiesExpression"]);
function Pn(e, t, r) {
  let { parent: n, node: s, key: i } = e, o = s.type === "AsConstExpression" ? "const" : r("typeAnnotation"), a2 = [r("expression"), " ", Lm(s) ? "satisfies" : "as", " ", o];
  return i === "callee" && M(n) || i === "object" && R(n) ? c([m([f, ...a2]), f]) : a2;
}
function Go(e, t, r) {
  let { node: n } = e, s = [z(e), "component"];
  n.id && s.push(" ", r("id")), s.push(r("typeParameters"));
  let i = Om(e, t, r);
  return n.rendersType ? s.push(c([i, " ", r("rendersType")])) : s.push(c([i])), n.body && s.push(" ", r("body")), t.semi && n.type === "DeclareComponent" && s.push(";"), s;
}
function Om(e, t, r) {
  let { node: n } = e, s = n.params;
  if (n.rest && (s = [...s, n.rest]), s.length === 0) return ["(", v(e, t, { filter: (u) => Ne(t.originalText, k(u)) === ")" }), ")"];
  let i = [];
  return Mm(e, (u, o) => {
    let a2 = o === s.length - 1;
    a2 && n.rest && i.push("..."), i.push(r()), !a2 && (i.push(","), ue2(s[o], t) ? i.push(y, y) : i.push(A));
  }), ["(", m([f, ...i]), b(ie(t, "all") && !wm(n, s) ? "," : ""), f, ")"];
}
function wm(e, t) {
  return e.rest || _(0, t, -1)?.type === "RestElement";
}
function Mm(e, t) {
  let { node: r } = e, n = 0, s = (i) => t(i, n++);
  e.each(s, "params"), r.rest && e.call(s, "rest");
}
function Wo(e, t, r) {
  let { node: n } = e;
  return n.shorthand ? r("local") : [r("name"), " as ", r("local")];
}
function qo(e, t, r) {
  let { node: n } = e, s = [];
  return n.name && s.push(r("name"), n.optional ? "?: " : ": "), s.push(r("typeAnnotation")), s;
}
function kn(e, t, r) {
  return sr(e, t, r);
}
function In(e, t) {
  let { node: r } = e, n = t("id");
  r.computed && (n = ["[", n, "]"]);
  let s = "";
  return r.initializer && (s = t("initializer")), r.init && (s = t("init")), s ? [n, " = ", s] : n;
}
function Ln(e, t) {
  let { node: r } = e;
  return [z(e), r.const ? "const " : "", "enum ", t("id"), " ", t("body")];
}
function Uo(e, t, r) {
  let { node: n } = e, s = ["hook"];
  n.id && s.push(" ", r("id"));
  let i = Ke2(e, t, r, false, true), u = Zt(e, r), o = ct2(n, u);
  return s.push(c([o ? c(i) : i, u]), n.body ? " " : "", r("body")), s;
}
function Ho(e, t, r) {
  let { node: n } = e, s = [z(e), "hook"];
  return n.id && s.push(" ", r("id")), t.semi && s.push(";"), s;
}
function Yo(e) {
  let { node: t } = e;
  return t.type === "HookTypeAnnotation" && e.getParentNode(2)?.type === "DeclareHook";
}
function Xo(e, t, r) {
  let { node: n } = e, s = Ke2(e, t, r, false, true), i = [Yo(e) ? ": " : " => ", r("returnType")];
  return c([Yo(e) ? "" : "hook ", ct2(n, i) ? c(s) : s, i]);
}
function _m(e) {
  switch (e) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function $o(e, t, r) {
  let { node: n } = e;
  return [c([n.variance ? r("variance") : "", "[", m([r("keyTparam"), " in ", r("sourceType")]), "]", _m(n.optional), ": ", r("propType")]), ve(e, t)];
}
function Vo(e, t) {
  return e === "+" || e === "-" ? e + t : t;
}
function Ko(e, t, r) {
  let { node: n } = e, s = false;
  if (t.objectWrap === "preserve") {
    let i = O(n), u = jt(t, i + 1, O(n.key)), o = i + 1 + u.search(/\S/u);
    oe(t.originalText, i, o) && (s = true);
  }
  return c(["{", m([t.bracketSpacing ? A : f, C(n, T.Dangling) ? c([v(e, t), y]) : "", c([n.readonly ? [Vo(n.readonly, "readonly"), " "] : "", "[", r("key"), " in ", r("constraint"), n.nameType ? [" as ", r("nameType")] : "", "]", n.optional ? Vo(n.optional, "?") : "", n.typeAnnotation ? ": " : "", r("typeAnnotation")]), t.semi ? b(";") : ""]), t.bracketSpacing ? A : f, "}"], { shouldBreak: s });
}
function Qo(e, t, r) {
  let { node: n } = e;
  return [c(["match (", m([f, r("argument")]), f, ")"]), " {", n.cases.length > 0 ? m([y, I(y, e.map(({ node: s, isLast: i }) => [r(), !i && ue2(s, t) ? y : ""], "cases"))]) : "", y, "}"];
}
function zo(e, t, r) {
  let { node: n } = e, s = C(n, T.Dangling) ? [" ", v(e, t)] : [], i = n.type === "MatchStatementCase" ? [" ", r("body")] : m([A, r("body"), ","]);
  return [r("pattern"), n.guard ? c([m([A, "if (", r("guard"), ")"])]) : "", c([" =>", s, i])];
}
function Zo(e, t, r) {
  let { node: n } = e;
  switch (n.type) {
    case "MatchOrPattern":
      return jm(e, t, r);
    case "MatchAsPattern":
      return [r("pattern"), " as ", r("target")];
    case "MatchWildcardPattern":
      return ["_"];
    case "MatchLiteralPattern":
      return r("literal");
    case "MatchUnaryPattern":
      return [n.operator, r("argument")];
    case "MatchIdentifierPattern":
      return r("id");
    case "MatchMemberPattern": {
      let s = n.property.type === "Identifier" ? [".", r("property")] : ["[", m([f, r("property")]), f, "]"];
      return c([r("base"), s]);
    }
    case "MatchBindingPattern":
      return [n.kind, " ", r("id")];
    case "MatchObjectPattern": {
      let s = e.map(r, "properties");
      return n.rest && s.push(r("rest")), c(["{", m([f, I([",", A], s)]), n.rest ? "" : b(","), f, "}"]);
    }
    case "MatchArrayPattern": {
      let s = e.map(r, "elements");
      return n.rest && s.push(r("rest")), c(["[", m([f, I([",", A], s)]), n.rest ? "" : b(","), f, "]"]);
    }
    case "MatchObjectPatternProperty":
      return n.shorthand ? r("pattern") : c([r("key"), ":", m([A, r("pattern")])]);
    case "MatchRestPattern": {
      let s = ["..."];
      return n.argument && s.push(r("argument")), s;
    }
  }
}
var ea = P(["MatchWildcardPattern", "MatchLiteralPattern", "MatchUnaryPattern", "MatchIdentifierPattern"]);
function Nm(e) {
  let { patterns: t } = e;
  if (t.some((n) => C(n))) return false;
  let r = t.find((n) => n.type === "MatchObjectPattern");
  return r ? t.every((n) => n === r || ea(n)) : false;
}
function vm(e) {
  return ea(e) || e.type === "MatchObjectPattern" ? true : e.type === "MatchOrPattern" ? Nm(e) : false;
}
function jm(e, t, r) {
  let { node: n } = e, { parent: s } = e, i = s.type !== "MatchStatementCase" && s.type !== "MatchExpressionCase" && s.type !== "MatchArrayPattern" && s.type !== "MatchObjectPatternProperty" && !de(t.originalText, n), u = vm(n), o = e.map(() => {
    let p = r();
    return u || (p = Te(2, p)), me(e, p, t);
  }, "patterns");
  if (u) return I(" | ", o);
  let a2 = [b(["| "]), I([A, "| "], o)];
  return xe(e, t) ? c([m([b([f]), a2]), f]) : s.type === "MatchArrayPattern" && s.elements.length > 1 ? c([m([b(["(", f]), a2]), f, b(")")]) : c(i ? m(a2) : a2);
}
function Rm(e, t, r) {
  let { node: n } = e;
  return $(n).length === 1 && n.type.startsWith("TS") && !n[r][0].constraint && e.parent.type === "ArrowFunctionExpression" && !(t.filepath && /\.ts$/u.test(t.filepath));
}
function Rt(e, t, r, n) {
  let { node: s } = e;
  if (!s[n]) return "";
  if (!Array.isArray(s[n])) return r(n);
  let i = Pt(e.grandparent), u = e.match((p) => !(p[n].length === 1 && We2(p[n][0])), void 0, (p, D2) => D2 === "typeAnnotation", (p) => p.type === "Identifier", ks);
  if (s[n].length === 0 || !u && (i || s[n].length === 1 && (s[n][0].type === "NullableTypeAnnotation" || Os(s[n][0])))) return ["<", I(", ", e.map(r, n)), Jm(e, t), ">"];
  let a2 = s.type === "TSTypeParameterInstantiation" ? "" : Rm(e, t, n) ? "," : ie(t) ? b(",") : "";
  return c(["<", m([f, I([",", A], e.map(r, n))]), a2, f, ">"]);
}
function Jm(e, t) {
  let { node: r } = e;
  if (!C(r, T.Dangling)) return "";
  let n = !C(r, T.Line), s = v(e, t, { indent: !n });
  return n ? s : [s, y];
}
function On(e, t, r) {
  let { node: n } = e, s = [n.const ? "const " : ""], i = n.type === "TSTypeParameter" ? r("name") : n.name;
  if (n.variance && s.push(r("variance")), n.in && s.push("in "), n.out && s.push("out "), s.push(i), n.bound && (n.usesExtendsBound && s.push(" extends "), s.push(U(e, r, "bound"))), n.constraint) {
    let u = Symbol("constraint");
    s.push(" extends", c(m(A), { id: u }), we2, ft(r("constraint"), { groupId: u }));
  }
  if (n.default) {
    let u = Symbol("default");
    s.push(" =", c(m(A), { id: u }), we2, ft(r("default"), { groupId: u }));
  }
  return c(s);
}
function ta(e, t, r) {
  let { node: n } = e;
  if (Or(n)) return n.type.slice(0, -14).toLowerCase();
  switch (n.type) {
    case "ComponentDeclaration":
    case "DeclareComponent":
    case "ComponentTypeAnnotation":
      return Go(e, t, r);
    case "ComponentParameter":
      return Wo(e, t, r);
    case "ComponentTypeParameter":
      return qo(e, t, r);
    case "HookDeclaration":
      return Uo(e, t, r);
    case "DeclareHook":
      return Ho(e, t, r);
    case "HookTypeAnnotation":
      return Xo(e, t, r);
    case "DeclareFunction":
      return [z(e), "function ", r("id"), r("predicate"), t.semi ? ";" : ""];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", U(e, r), t.semi ? ";" : ""];
    case "DeclareNamespace":
      return ["declare namespace ", r("id"), " ", r("body")];
    case "DeclareVariable":
      return [z(e), n.kind ?? "var", " ", r("id"), t.semi ? ";" : ""];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return bn(e, t, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return yo(e, t, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return mn(e, t, r);
    case "IntersectionTypeAnnotation":
      return Dn(e, t, r);
    case "UnionTypeAnnotation":
      return fn(e, t, r);
    case "ConditionalTypeAnnotation":
      return ir(e, t, r);
    case "InferTypeAnnotation":
      return Fn(e, t, r);
    case "FunctionTypeAnnotation":
      return yn(e, t, r);
    case "TupleTypeAnnotation":
      return nr(e, t, r);
    case "TupleTypeLabeledElement":
      return Cn(e, t, r);
    case "TupleTypeSpreadElement":
      return dn(e, t, r);
    case "GenericTypeAnnotation":
      return [r("id"), Rt(e, t, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return En(e, t, r);
    case "TypeAnnotation":
      return An(e, t, r);
    case "TypeParameter":
      return On(e, t, r);
    case "TypeofTypeAnnotation":
      return xn(e, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return Tn(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return Ln(e, r);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumBigIntBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return [n.type === "EnumSymbolBody" || n.explicitType ? `of ${n.type.slice(4, -4).toLowerCase()} ` : "", kn(e, t, r)];
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumBigIntMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return In(e, r);
    case "FunctionTypeParam": {
      let s = n.name ? r("name") : e.parent.this === n ? "this" : "";
      return [s, V(e), s ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareClass":
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return er(e, t, r);
    case "ObjectTypeAnnotation":
      return vt(e, t, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: s } = n;
      return s === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [n.static ? "static " : "", r("value"), ve(e, t)];
    case "ObjectTypeMappedTypeProperty":
      return $o(e, t, r);
    case "ObjectTypeIndexer":
      return [n.static ? "static " : "", n.variance ? r("variance") : "", "[", r("id"), n.id ? ": " : "", r("key"), "]: ", r("value"), ve(e, t)];
    case "ObjectTypeProperty": {
      let s = "";
      return n.proto ? s = "proto " : n.static && (s = "static "), [s, n.kind !== "init" ? n.kind + " " : "", n.variance ? r("variance") : "", Ft(e, t, r), V(e), lt2(n) ? "" : ": ", r("value"), ve(e, t)];
    }
    case "ObjectTypeInternalSlot":
      return [n.static ? "static " : "", "[[", r("id"), "]]", V(e), n.method ? "" : ": ", r("value"), ve(e, t)];
    case "ObjectTypeSpreadProperty":
      return hn(e, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(n.value);
    case "StringLiteralTypeAnnotation":
      return Ge2(ut(pe2(n), t));
    case "NumberLiteralTypeAnnotation":
      return Et(pe2(n));
    case "BigIntLiteralTypeAnnotation":
      return Bn(pe2(n));
    case "TypeCastExpression":
      return ["(", r("expression"), U(e, r), ")"];
    case "TypePredicate":
      return gn(e, r);
    case "TypeOperator":
      return [n.operator, " ", r("typeAnnotation")];
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return Rt(e, t, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [e.key === "predicate" && e.parent.type !== "DeclareFunction" && !e.parent.returnType ? ": " : " ", "%checks", ...n.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return Pn(e, t, r);
    case "MatchExpression":
    case "MatchStatement":
      return Qo(e, t, r);
    case "MatchExpressionCase":
    case "MatchStatementCase":
      return zo(e, t, r);
    case "MatchOrPattern":
    case "MatchAsPattern":
    case "MatchWildcardPattern":
    case "MatchLiteralPattern":
    case "MatchUnaryPattern":
    case "MatchIdentifierPattern":
    case "MatchMemberPattern":
    case "MatchBindingPattern":
    case "MatchObjectPattern":
    case "MatchObjectPatternProperty":
    case "MatchRestPattern":
    case "MatchArrayPattern":
      return Zo(e, t, r);
  }
}
function ra(e, t, r) {
  let { node: n } = e;
  if (n.type.startsWith("TS")) {
    if (wr(n)) return n.type.slice(2, -7).toLowerCase();
    switch (n.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        let s = !(G(n.expression) || se(n.expression)), i = c(["<", m([f, r("typeAnnotation")]), f, ">"]), u = [b("("), m([f, r("expression")]), f, b(")")];
        return s ? rt2([[i, r("expression")], [i, c(u, { shouldBreak: true })], [i, r("expression")]]) : c([i, r("expression")]);
      }
      case "TSDeclareFunction":
        return un(e, t, r);
      case "TSExportAssignment":
        return ["export = ", r("expression"), t.semi ? ";" : ""];
      case "TSModuleBlock":
        return Sn(e, t, r);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return vt(e, t, r);
      case "TSTypeAliasDeclaration":
        return mn(e, t, r);
      case "TSQualifiedName":
        return [r("left"), ".", r("right")];
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return pn(e, t, r);
      case "TSAbstractAccessorProperty":
      case "TSAbstractPropertyDefinition":
        return cn(e, t, r);
      case "TSInterfaceHeritage":
      case "TSClassImplements":
      case "TSInstantiationExpression":
        return [r("expression"), r("typeArguments")];
      case "TSTemplateLiteralType":
        return $r(e, t, r);
      case "TSNamedTupleMember":
        return Cn(e, t, r);
      case "TSRestType":
        return dn(e, t, r);
      case "TSOptionalType":
        return [r("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return er(e, t, r);
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return Rt(e, t, r, "params");
      case "TSTypeParameter":
        return On(e, t, r);
      case "TSAsExpression":
      case "TSSatisfiesExpression":
        return Pn(e, t, r);
      case "TSArrayType":
        return Tn(r);
      case "TSPropertySignature":
        return [n.readonly ? "readonly " : "", Ft(e, t, r), V(e), U(e, r), ve(e, t)];
      case "TSParameterProperty":
        return [rr(n), n.static ? "static " : "", n.override ? "override " : "", n.readonly ? "readonly " : "", r("parameter")];
      case "TSTypeQuery":
        return xn(e, r);
      case "TSIndexSignature": {
        let s = n.parameters.length > 1 ? b(ie(t) ? "," : "") : "", i = c([m([f, I([", ", f], e.map(r, "parameters"))]), s, f]);
        return [e.key === "body" && e.parent.type === "ClassBody" && n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? i : "", "]", U(e, r), ve(e, t)];
      }
      case "TSTypePredicate":
        return gn(e, r);
      case "TSNonNullExpression":
        return [r("expression"), "!"];
      case "TSImportType":
        return [_t(e, t, r), n.qualifier ? [".", r("qualifier")] : "", Rt(e, t, r, "typeArguments")];
      case "TSLiteralType":
        return r("literal");
      case "TSIndexedAccessType":
        return En(e, t, r);
      case "TSTypeOperator":
        return [n.operator, " ", r("typeAnnotation")];
      case "TSMappedType":
        return Ko(e, t, r);
      case "TSMethodSignature": {
        let s = [], i = n.kind && n.kind !== "method" ? `${n.kind} ` : "";
        s.push(rr(n), i, n.computed ? "[" : "", r("key"), n.computed ? "]" : "", V(e));
        let u = Ke2(e, t, r, false, true), o = U(e, r, "returnType"), a2 = ct2(n, o);
        return s.push(a2 ? c(u) : u), n.returnType && s.push(c(o)), [c(s), ve(e, t)];
      }
      case "TSNamespaceExportDeclaration":
        return ["export as namespace ", r("id"), t.semi ? ";" : ""];
      case "TSEnumDeclaration":
        return Ln(e, r);
      case "TSEnumBody":
        return kn(e, t, r);
      case "TSEnumMember":
        return In(e, r);
      case "TSImportEqualsDeclaration":
        return ["import ", Gs(n, false), r("id"), " = ", r("moduleReference"), t.semi ? ";" : ""];
      case "TSExternalModuleReference":
        return _t(e, t, r);
      case "TSModuleDeclaration":
        return [z(e), n.kind === "global" ? "" : `${n.kind} `, r("id"), n.body ? [" ", c(r("body"))] : t.semi ? ";" : ""];
      case "TSConditionalType":
        return ir(e, t, r);
      case "TSInferType":
        return Fn(e, t, r);
      case "TSIntersectionType":
        return Dn(e, t, r);
      case "TSUnionType":
        return fn(e, t, r);
      case "TSFunctionType":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
      case "TSConstructSignatureDeclaration":
        return yn(e, t, r);
      case "TSTupleType":
        return nr(e, t, r);
      case "TSTypeReference":
        return [r("typeName"), Rt(e, t, r, "typeArguments")];
      case "TSTypeAnnotation":
        return An(e, t, r);
      case "TSEmptyBodyFunctionExpression":
        return on(e, t, r);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return ws(e, r, "?");
      case "TSJSDocNonNullableType":
        return ws(e, r, "!");
      case "TSParenthesizedType":
      default:
        throw new $e2(n, "TypeScript");
    }
  }
}
function Gm(e, t, r, n) {
  for (let s of [vu, wu, ta, ra, Jo]) {
    let i = s(e, t, r, n);
    if (i !== void 0) return i;
  }
}
var Wm = P(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function qm(e, t, r, n) {
  e.isRoot && t.__onHtmlBindingRoot?.(e.node, t);
  let { node: s } = e, i = Qt(e) ? t.originalText.slice(O(s), k(s)) : Gm(e, t, r, n);
  if (!i) return "";
  if (Wm(s)) return i;
  let u = j(s.decorators), o = Ru(e, t, r), a2 = s.type === "ClassExpression";
  if (u && !a2) return Fr(i, (l2) => c([o, l2]));
  let p = xe(e, t), D2 = ho(e, t);
  return !o && !p && !D2 ? i : Fr(i, (l2) => [D2 ? ";" : "", p ? "(" : "", p && a2 && u ? [m([A, o, l2]), A] : [o, l2], p ? ")" : ""]);
}
var qs = qm;
var Ym = { experimental_avoidAstMutation: true };
var na = [{ name: "JSON.stringify", type: "data", aceMode: "json", extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], tmScope: "source.json", aliases: ["geojson", "jsonl", "sarif", "topojson"], codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], linguistLanguageId: 174 }, { name: "JSON", type: "data", aceMode: "json", extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".json.example", ".mcmeta", ".sarif", ".tact", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], tmScope: "source.json", aliases: ["geojson", "jsonl", "sarif", "topojson"], codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json"], vscodeLanguageIds: ["json"], linguistLanguageId: 174 }, { name: "JSON with Comments", type: "data", aceMode: "javascript", extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-color-scheme", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], tmScope: "source.json.comments", aliases: ["jsonc"], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", group: "JSON", parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"], linguistLanguageId: 423 }, { name: "JSON5", type: "data", aceMode: "json5", extensions: [".json5"], tmScope: "source.js", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"], linguistLanguageId: 175 }];
var Us = {};
_n(Us, { getVisitorKeys: () => ia, massageAstNode: () => oa, print: () => Xm });
var Um = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, sa = Um;
var Hm = Ir(sa), ia = Hm;
function Xm(e, t, r) {
  let { node: n } = e;
  switch (n.type) {
    case "JsonRoot":
      return [r("node"), y];
    case "ArrayExpression": {
      if (n.elements.length === 0) return "[]";
      let s = e.map(() => e.node === null ? "null" : r(), "elements");
      return ["[", m([y, I([",", y], s)]), y, "]"];
    }
    case "ObjectExpression":
      return n.properties.length === 0 ? "{}" : ["{", m([y, I([",", y], e.map(r, "properties"))]), y, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [n.operator === "+" ? "" : n.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return n.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(n.value);
    case "NumericLiteral":
      return ua(e) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
    case "Identifier":
      return ua(e) ? JSON.stringify(n.name) : n.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(n.value.cooked);
    default:
      throw new $e2(n, "JSON");
  }
}
function ua(e) {
  return e.key === "key" && e.parent.type === "ObjectProperty";
}
var Vm = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function oa(e, t) {
  let { type: r } = e;
  if (r === "ObjectProperty") {
    let { key: n } = e;
    n.type === "Identifier" ? t.key = { type: "StringLiteral", value: n.name } : n.type === "NumericLiteral" && (t.key = { type: "StringLiteral", value: String(n.value) });
    return;
  }
  if (r === "UnaryExpression" && e.operator === "+") return t.argument;
  if (r === "ArrayExpression") {
    for (let [n, s] of e.elements.entries()) s === null && t.elements.splice(n, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral") return { type: "StringLiteral", value: e.quasis[0].value.cooked };
}
oa.ignoredProperties = Vm;
var ur = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var gt = "JavaScript", $m = { arrowParens: { category: gt, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: ur.bracketSameLine, objectWrap: ur.objectWrap, bracketSpacing: ur.bracketSpacing, jsxBracketSameLine: { category: gt, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: gt, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalOperatorPosition: { category: gt, type: "choice", default: "end", description: "Where to print operators when binary expressions wrap lines.", choices: [{ value: "start", description: "Print operators at the start of new lines." }, { value: "end", description: "Print operators at the end of previous lines." }] }, experimentalTernaries: { category: gt, type: "boolean", default: false, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: ur.singleQuote, jsxSingleQuote: { category: gt, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { category: gt, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: gt, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: ur.singleAttributePerLine }, aa = $m;
var Km = { estree: Ys, "estree-json": Us }, Qm = [...$s, ...na];
function flattenDoc(doc) {
  if (Array.isArray(doc)) {
    return doc.flatMap(flattenDoc);
  } else if (typeof doc === "string") {
    return [doc];
  } else if ("contents" in doc) {
    return flattenDoc(doc.contents);
  } else {
    return [];
  }
}
const printer$1 = Km["estree"];
function saveCurrentPrintOnSiblingNode(path2, printed) {
  const { index, siblings } = path2;
  if (index === null) {
    return;
  }
  const nextNode = siblings?.slice(index + 1).find((n) => n?.type !== "EmptyStatement");
  if (nextNode) {
    nextNode.extra = nextNode.extra || {};
    nextNode.extra["prevTemplatePrinted"] = printed;
  }
}
function fixPreviousPrint(previousTemplatePrinted, path2, options2, print2, args) {
  const printedSemiFalse = printer$1.print(
    path2,
    { ...options2, semi: false },
    print2,
    args
  );
  const flat = flattenDoc(printedSemiFalse);
  const previousFlat = flattenDoc(previousTemplatePrinted);
  if (flat[0]?.startsWith(";") && previousFlat.at(-1) !== ";") {
    previousTemplatePrinted.push(";");
  }
}
function hasPrettierIgnore(path2) {
  let possibleComment = path2.node?.leadingComments?.at(-1)?.value.trim();
  if (!path2.node?.leadingComments && path2.node?.comments) {
    possibleComment = path2.node.comments?.at(-1)?.value.trim();
  }
  return possibleComment === "prettier-ignore";
}
function checkPrettierIgnore(path2) {
  if (hasPrettierIgnore(path2)) {
    return true;
  }
  return Boolean(path2.getParentNode()) && path2.callParent((parent) => checkPrettierIgnore(parent));
}
function isGlimmerTemplate(node2) {
  return node2.extra?.["isGlimmerTemplate"] === true;
}
function isGlimmerTemplateParent(node2) {
  if (!node2) return false;
  return isGlimmerStatementTS(node2) || isGlimmerExportDefaultDeclaration(node2) || isGlimmerExportDefaultDeclarationTS(node2);
}
function isGlimmerStatementTS(node2) {
  return node2.type === "ExpressionStatement" && node2.expression.type === "TSAsExpression" && node2.expression.expression.type === "ObjectExpression" && isGlimmerTemplate(node2.expression.expression);
}
function isGlimmerExportDefaultDeclaration(node2) {
  return node2.type === "ExportDefaultDeclaration" && node2.declaration.type === "ObjectExpression" && isGlimmerTemplate(node2.declaration);
}
function isGlimmerExportDefaultDeclarationTS(node2) {
  return node2.type === "ExportDefaultDeclaration" && node2.declaration.type === "TSAsExpression" && node2.declaration.expression.type === "ObjectExpression" && isGlimmerTemplate(node2.declaration.expression);
}
function docMatchesString(doc, string2) {
  return typeof doc === "string" && doc.trim() === string2;
}
function printRawText({ node: node2 }, options2) {
  if (!node2) {
    return "";
  }
  if (isGlimmerTemplate(node2)) {
    return TEMPLATE_TAG_OPEN + node2.extra.template.contents + TEMPLATE_TAG_CLOSE;
  }
  assert("expected start", typeof node2.start == "number");
  assert("expected end", typeof node2.end == "number");
  return options2.originalText.slice(node2.start, node2.end);
}
async function printTemplateContent(text, textToDoc, options2) {
  return await textToDoc(text.trim(), {
    ...options2,
    parser: "glimmer",
    singleQuote: options2.templateSingleQuote ?? options2.singleQuote
  });
}
function printTemplateTag(content) {
  const contents = flattenDoc(content);
  const useHardline = contents.some(
    (c2) => (
      // contains angle bracket tag
      /<.+>/.test(c2) || // contains hbs block
      /{{~?#.+}}/.test(c2)
    )
  );
  const line = useHardline ? prettier.doc.builders.hardline : prettier.doc.builders.softline;
  const doc = [
    TEMPLATE_TAG_OPEN,
    prettier.doc.builders.indent([line, prettier.doc.builders.group(content)]),
    line,
    TEMPLATE_TAG_CLOSE
  ];
  return [prettier.doc.builders.group(doc)];
}
function trimPrinted(printed) {
  while (docMatchesString(printed[0], "")) {
    printed.shift();
  }
  while (docMatchesString(printed.at(-1), "")) {
    printed.pop();
  }
}
const printer = Km["estree"];
function embed(path2, options2) {
  const { node: node2 } = path2;
  return async (textToDoc) => {
    if (node2 && isGlimmerTemplate(node2)) {
      if (checkPrettierIgnore(path2)) {
        return printRawText(path2, options2);
      }
      try {
        const content = await printTemplateContent(
          node2.extra.template.contents,
          textToDoc,
          options2
        );
        const printed = printTemplateTag(content);
        saveCurrentPrintOnSiblingNode(path2, printed);
        return printed;
      } catch (error) {
        console.error(error);
        const printed = [printRawText(path2, options2)];
        saveCurrentPrintOnSiblingNode(path2, printed);
        return printed;
      }
    }
    return;
  };
}
function getVisitorKeys(node2, nonTraversableKeys) {
  if (node2 && isGlimmerTemplate(node2)) {
    return [];
  }
  return printer.getVisitorKeys?.(node2, nonTraversableKeys) || [];
}
function print(path2, options2, print2, args) {
  const { node: node2 } = path2;
  if (isGlimmerTemplateParent(node2)) {
    if (checkPrettierIgnore(path2)) {
      return printRawText(path2, options2);
    } else {
      let printed = printer.print(path2, options2, print2, args);
      assert("Expected Glimmer doc to be an array", Array.isArray(printed));
      trimPrinted(printed);
      if (docMatchesString(printed[0], ";")) {
        printed.shift();
      }
      if (docMatchesString(printed.at(-1), ";")) {
        printed.pop();
      }
      trimPrinted(printed);
      if (docMatchesString(printed[0], "export") && docMatchesString(printed[1], "default")) {
        printed = printed.slice(2);
        trimPrinted(printed);
      }
      if (options2.templateExportDefault) {
        printed.unshift("export ", "default ");
      }
      saveCurrentPrintOnSiblingNode(path2, printed);
      return printed;
    }
  }
  if (options2.semi && node2?.extra?.["prevTemplatePrinted"]) {
    fixPreviousPrint(
      node2.extra["prevTemplatePrinted"],
      path2,
      options2,
      print2,
      args
    );
  }
  return printer.print(path2, options2, print2, args);
}
function printPrettierIgnored(path2, options2) {
  return printRawText(path2, options2);
}
const printers = {
  [PRINTER_NAME]: {
    ...printer,
    // @ts-expect-error: Type <...> is not assignable to <...>
    embed,
    getVisitorKeys,
    print,
    printPrettierIgnored
  }
};
exports.languages = languages;
exports.options = options$1;
exports.parsers = parsers;
exports.printers = printers;
